<!DOCTYPE html>
    <html>
<!-- Created 2024-10-23 / Release 0.1 2024-11-21 -->
<head>
  <meta charset="UTF-8">
  <title>Comp/Decomp Country</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="icon" href="data:image/svg+xml;base64,PHN2ZwogICB3aWR0aD0iNjkuMzg5NTcybW0iCiAgIGhlaWdodD0iODcuNDI1MTg2bW0iCiAgIHZpZXdCb3g9IjAgMCA2OS4zODk1NzIgODcuNDI1MTg2IgogICB2ZXJzaW9uPSIxLjEiCiAgIGlkPSJzdmcxIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxkZWZzCiAgICAgaWQ9ImRlZnMxIiAvPgogIDxnCiAgICAgaWQ9ImxheWVyMSIKICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTIuMjU5NDUxLC0zLjcwMjU1MzUpIj4KICAgIDxwYXRoCiAgICAgICBpZD0icGF0aDEiCiAgICAgICBzdHlsZT0iZmlsbDojYjNiMzAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDowLjM2Njk7c3Ryb2tlLW9wYWNpdHk6MC42OSIKICAgICAgIGQ9Im0gNTkuNDA2NDQzLDMuNzAyNTUzNSAtMi4yNjczMDUsMC42NTI0MTQgLTIuNDI0OTE1LDEuOTIyMzY1IDMuOTI4Nyw3LjY1OTczNzUgYyAwLDAgLTAuMDI1NTcsMjQuMTMzMTExIC02LjY0NDI5NywzNC4wNDA1NjEgLTEwLjAyOTEsMTYuNjM0NDk3IC0zNS43MjU1MywyNi4yOTgwNjIgLTM3Ljk0OTg4LDM3LjUzMzg4MiBsIC0xLjc4OTI5NSwyLjYwMDYxOCAwLjkyMjQyMiwyLjM3NTgyNSAyLjc0NDAyLC0wLjIwNTQyNSBjIDAsMCAxMy4zNjQyMSw0LjcyNzU5NyAzMy4zOTMzMSwtOC4xNzkwODggQyA3MC44NzE1MjgsNjguMjE1MTk4IDgyLjg0OTc3MSw1NS42MTEyNzEgODEuNTUzNjcxLDM0LjI4MzM2NiA4MC40NjQyMjgsMTYuMzU1OTkgNjYuNDgyMjM4LDExLjgyMzQ5NSA2Ni40ODIyMzgsMTEuODIzNDk1IFoiIC8+CiAgPC9nPgo8L3N2Zz4K" />

</head>
<style>

*{
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  
}
:root {
  /* --bitplaneViewerTransition: 3s cubic-bezier( 0.33, 0, 0.31, 1 ) 0s;
  --bitplaneViewerTransition2: 2s cubic-bezier( 0.33, 0, 0.31, 1 ) 3s; */
  --bitplaneViewerTransition: 3s cubic-bezier( 0.31, 0, 0, 1 );
  --bitplaneViewerTransition2: 3s cubic-bezier( 0.99, 0, 0.34, 1 );
  --bp0bg: 0;
  --bp0fg: 255;
}

body{

  background: rgb(30,50,30);
  color: rgb(59, 172, 98);
  color: rgb(255,255,255);
  font-family: monospace;
  overflow: hidden;
  position: relative;
}

h3{
  margin:1ch;

  font-size: 1.2em;;
}

h4{
  margin:0.5ch;
  /* font-size: 1.2em;; */
}


a{text-align: center;}
g{overflow: visible}
button{
  margin: 1ch;
  padding: 3px;
  /* 
  background-color: rgb(50,50,50); */
}

#main{
  position:absolute;
    display: flex;
    flex-grow: 1;
    justify-items: stretch;
    flex-direction: column;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
}

#navbar{
    height: 2em;
    width: 100%;
    background-color: gray;
    display: flex;
    flex-shrink: 0;
    overflow: hidden;
}

#panelgrid{
    position: relative;
    display: grid;
    width: 100%;
    height: 100%;
    grid-template-columns: repeat(32, 1fr);
    grid-template-rows: repeat(28, 1fr);
    grid-auto-flow: row;
    overflow: hidden;

}

.checker{
    background-color: rgb(66, 12, 12);
    z-index: -7;
}

/* grid version... */
/* .panel_outer{
    display: flex;
    grid-row-start: 1;
    grid-row-end: 14;
    background: none;
    border-radius: 7px;
    overflow: hidden;
    overflow-x: visible;
    overflow: visible;
    justify-content: center;

} */
/* draggable version... */
.panel_outer{
    --edge: 10px;
    position: absolute;
    display: grid;
    /* grid-template-columns: 0.5em auto 0.5em;
    grid-template-rows: 0.5em auto 0.5em; */
    grid-template-columns: var(--edge) auto var(--edge);
    grid-template-rows: var(--edge) auto var(--edge);
    background: none;
    /* border: 1px solid blue; */
    border-radius: 7px;
    overflow: hidden;
    overflow-x: visible;
    overflow: visible;
    justify-content: center;  
    /* overflow-y: scroll; */
    /* max-height: 20em; */
}

.panel_edge{
  /* background-color: rgba(255,0,0,0.5); */
}

/* Global classes used by all panels */

.panel_inner{

    /* background-color: rgba(7, 7, 80, 0.5); */
    /* border: 2px solid black; */
    background-color:rgb(41, 8, 8);
    border-radius: 7px;
    justify-self: center;
    overflow: hidden;
    grid-column: 1 / -1;
    grid-row: 1 / -1;
    
    /* display: grid;
    align-items: stretch;
    grid-template-rows: 3em 1.5em 1fr;
    grid-template-rows: 3em 1fr; */
    
    /* grid-template-columns: 2fr 16fr 0fr;
    transition:  var(--bitplaneViewerTransition); */
    box-shadow: 1em 1em black;
    transition: grid-template-rows 2s ease;
    /* height: minmax(max-content, 20em); */
    /* max-height: 800px; */
    height: max-content;
    
    display: grid;
    grid-template-columns: 1fr;
}
/* .panel_inner::after{
  background-color: yellow;
  margin-left: 20px;
  width: 500px;
  height: 300px;
  display: block;
} */


.collapser{
  cursor:pointer;
}
.collapser_collapsed{
  transform: rotateX(180deg);
}

.panel_menu{
  /* display: grid; */
  grid-row: 2;
  grid-column: 1;
  z-index: 1;
  background-color: blue;
  display: flex;
  /* margin and padding cause weird overflow issues...? */
  /* margin-top: 2em;
  margin-bottom: 2em; */
  overflow-y: auto;
  font-family: Arial, Helvetica, sans-serif;


  /* initial, unopened */
  z-index: -1;
  opacity: 0;
  height: 0;
  pointer-events: none;
}

.panel_menu_opened{
  z-index: 10;
  opacity: 1;
  height: max-content;
  pointer-events: default;
}

.panel_menu_button{
  cursor:pointer;

}
.panel_menu_button_opened{
  /* border-left: 2px solid white;
  border-top: 2px solid white; */
  border-radius: 6px 6px 0px 0px;
  background-color: blue;
  
}

.panel_header{
    /* height: 2em; */
    background-color: rgb(10, 30, 10);
    display: grid;
    grid-template-columns: auto 3ch 3ch;
    /* flex-direction: row; */
    /* justify-content: space-between; */
    align-items: center;
    grid-area: 1 / 1 / 2 / -1;
    overflow: hidden;
    cursor: move;
    /* transition:  var(--bitplaneViewerTransition); */
}
.panel_header > div{
  
  height: 100%;
  align-content: center;
}

.panel_content{
  
  display: grid;
  /* grid-template-columns: 2fr repeat(16, 1fr);
  grid-area: 2 / 1 / 3 / -1; */
  grid-column: 1 / -1;
  grid-row: 2 / 3;
  overflow-y: auto; /* allows scrolling */
  overflow-x: hidden;
}

.panel_header_title{
  
  margin:1ch;
  margin-right: 2ch;
  font-size: 1em;;
  font-family:Arial, Helvetica, sans-serif;
}


/* panel type -specific classes */


.bitplane_header{
    /* height: 2em; */
    background-color: rgb(20, 40, 20);
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    grid-area: 1 / 1 / 2 / -1;
    transition:  var(--bitplaneViewerTransition);
}

.panel_inner_bitplane{
  /* grid-template-columns: 2fr 16fr 0fr; */
}



.panel_inner_tileset{

  grid-template-rows: 3em 1fr;
  grid-template-columns: 1fr;
  /* overflow: hidden; */
}

.tileset_content{
  display: flex;
  /* display: grid;
  place-content: stretch; */
  flex-direction: row;
  flex-wrap: wrap;
  width: 100%;;
  /* overflow-y: scroll; */
  /* align-content: stretch; */
  scroll-snap-type: both proximity;
}
.levelMap_content{
  display: grid;
  /* display: grid;
  place-content: stretch; */
  grid-auto-flow: column;
  grid-template-rows: repeat(16, 1fr);
  flex-wrap: wrap;
  height: 100%;;
  overflow-x: scroll;
  /* align-content: stretch; */
  scroll-snap-type: both proximity;
}
/* for wrapper of <canvas> element */
.tile_wrapper{
  flex-grow: 1;
  flex-shrink: 0;
  aspect-ratio: 1 / 1;
  display: grid;
  grid-template-columns: 1fr;
  grid-template-rows: 1fr;
  width: 6.25%; /* works ok */
  width: 25%;
}
/* for actual <canvas> element */
.tile_item{
  max-width: 100%;
  min-height: 100%;
  aspect-ratio: 1 / 1;
  image-rendering: pixelated;
  border: 1px solid rgba(255,0,0,0.25);
}
.metatile_wrapper{
  
  flex-grow: 1;
  aspect-ratio: 1 / 1;
  width: 10ch;
  /* height: 10ch;  */
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  grid-template-rows: repeat(4, 1fr);
  place-items: stretch;
  grid-gap: 0;
  aspect-ratio: 1 / 1;
  image-rendering: pixelated;
  border: 1px solid rgba(0,255,0,0.5);
  width: 25%; /* works ok */

}

.panel_inner_palette{
  grid-template-rows: 3em 1fr;
  grid-template-columns: 1fr;

}
.palette_content{
  /* display: flex; */
  display: grid;
  grid-template-columns: repeat(16, 1fr);
  flex-direction: row;
  flex-wrap: wrap;
  width: 100%;
  /* width: 20em; */
  /* overflow-y: scroll; */
  align-content: stretch;
  place-content: stretch;
  scroll-snap-type: both proximity;
}
.color_item{
  flex-grow: 1;
  aspect-ratio: 1 / 1;
  /* width: 5ch; */
  background-color: rgba(0,0,0,0);
  
  box-sizing: border-box;
  /* width: 2ch; */
}
/* when we select this palette */
.color_item_selected{
  box-sizing: border-box;
  border-top: dashed 3px rgba(255, 255, 0, 0.75);
  border-bottom: dashed 3px rgba(255, 255, 0, 0.75);
}

.color_label{
  text-shadow: 1px 1px 0px black, -1px -1px 0px black;
  color: rgba(255, 255, 255, 0.75);;
  pointer-events: none;
}

.fileButton{}
.byteWidthButton{}

.seekButtons{
  background-color: rgba(0,0,0,0.5);
}
.seekTileUpButton{}
.seekTileDownButton{}

.hex_header{
    background-color: rgb(20, 40, 20);
    display: grid;
    /* grid-template-columns: 2fr repeat(16, 1fr);
    grid-area: 2 / 1 / 3 / -1; */
    grid-column: 1 / -1;
    /* grid-row: 2 / 3; */
    grid-template-columns: subgrid;

    place-items: center;
    transition: var(--bitplaneViewerTransition);

    /* this adds padding so it lines up with hex_content,
    because windows adds the weird scrollbar */
    overflow:auto;
    scrollbar-gutter: stable;
    place-items: stretch;

    /* for 1-byte-wide: */
    /* grid-template-columns: 2fr 16fr; */
}
/* labels across the top header:  */
.hex_header_offset{
  display: grid;
  place-items: stretch;
  grid-row: 1 / 2;

}

.hex_content{
    
    /* background-color: rgba(23, 23, 23, 1); */
    display: grid;
    /* grid-area: 3 / 1 / 4 / 5;
    
    grid-auto-flow: row;
    grid-template-columns: 18fr 0fr; */
    grid-column: 1 / -1;
    /* grid-row: 3 / 4; */
    grid-template-columns: subgrid;
    /* grid-template-rows: 100%; /*HACK: assumes viewing only 32 bytes */
    /* grid-template-rows: 1fr; */
    /* grid-template-columns: subgrid; */
    scrollbar-gutter: stable;
    
    /* transition: var(--bitplaneViewerTransition); */

    /* scroll-snap-type: mandatory; */
    scroll-snap-points-y: repeat(100%);
    scroll-snap-type: both proximity;
  
    overflow-y: auto;
    overflow-x: hidden;
    transition: grid-template-rows 1s ease;
}


.g32_plain{
  display:grid;
  grid-template-columns: 2fr repeat(16, 1fr) 0fr 0fr; 
  grid-template-rows: 2em 2em;
  height: 4em;
}

.g32l{
    scroll-snap-align: start;
    /* display: grid; */
    grid-column: 1 / 2;
    grid-row: 1;
    /* grid-template-columns: subgrid;
    grid-auto-flow: row;
    align-items: start;
    justify-items: center; */
  min-width:fit-content;
    position: relative;
}

.g32r{
    scroll-snap-align: start;
    /* display: grid; */
    grid-column: 2 / 3;
    grid-row: 1;
    /* grid-template-columns: subgrid; */
    /* grid-auto-flow: row; */
    /* align-items: start; */
    /* justify-items: center; */
  min-width:fit-content;
    position: relative;
}
.g32_item{
  position:absolute;
  transform-origin: center;
  transform: translate(-50%,-50%);
}
.g32l_offset_sometimes{}
.g32l_offset_sometimes_b16{opacity:0;}
.g32l_offset_sometimes_b1{opacity:1;}

.g32b{
    scroll-snap-align: start;
    /* display: grid; */
    grid-column: 3 / 4;
    grid-row: 1;
    /* grid-template-columns: subgrid; */
    /* grid-auto-flow: row; */
    /* align-items: start; */
    /* justify-items: center; */
    overflow: hidden;
    position: relative;
}

.g32bg{
  display: grid;
  grid-column: 1 / 4;
  grid-row: 1;
  grid-template-columns: 1fr;
  grid-template-rows: repeat(32, 1fr);
  grid-auto-flow: row;
}
.g32bg_row{
  width: 100%;
  height:100%;
}
.g32bg_b16{
  opacity:0;
}
.g32bg_b1{
  opacity:1;
}
  
/* .g32b{
  display: grid;
  grid-column: 3 / 4;
  grid-template-rows: repeat(32, 1fr);
  grid-template-columns: 1fr;
  grid-template-columns: subgrid;
  overflow: hidden;
  min-height: 0;
  align-items: center;
} */

.g32s{
    grid-column: -1;
    grid-template-columns: subgrid;
    overflow: hidden;
    /* overflow: visible; */
    /* keep this; somehow prevents weird unnecessary scrollbar: */
    /* content-visibility: auto;  */
    /* margin-left: -1ch; */
}
.g32s_b16{
  opacity:0;
}
.g32s_b1{
  opacity:1;
}




.bpsvg{
  height:100%;
  /* width: 100%; */
  overflow: visible;
  /* width: 0; */
}



.byteHex{
  direction: ltr;
  align-items: center;
  text-align: center;
  background-color: rgba(0, 0, 0, 0.25);
  width: 100%;
  height: 100%;
  /* transition: var(--bitplaneViewerTransition2); */
}



.hex_header_labels_left{
  display: grid;
  place-items: stretch;
  grid-row: 1 / 2;  
  grid-column: 2 / 3;
  grid-template-columns: repeat(16, 1fr);
  grid-template-rows: 1fr;
  place-self: stretch;
  opacity: 1;
  /* transition: var(--bitplaneViewerTransition2) */
}


.hex_header_labels_right{
  display: grid;
  place-items: stretch;
  grid-row: 1 / 2;    
  grid-column: 3 / 4;
  grid-template-columns: 1fr;
  grid-template-rows: 1fr;
  place-self: stretch;
  min-width: 0;
  overflow: hidden;

}
/* .hex_header_labels_right_b16{

  width: 0%;
  opacity: 0;
}
.hex_header_labels_right_b1{

  width: 100%;
  opacity: 1;
} */
/*
.hex_base_labels{
  display: grid;
  place-items: stretch;
  grid-row: 1 / 2;  
  grid-column: 2 / 3;
  grid-template-columns:2fr 4fr;
  place-self: stretch;
  
  opacity: 0;
 
}
.hex_header_base_label_b16{

  width: 0%;
  opacity: 0;
}
.hex_header_base_label_b1{

  width: 100%;
  opacity: 1;
}
*/
/*

.byteBin{
  direction: ltr;
  opacity: 0;
  align-items: center;
  text-align: right;
  width: 0%;
  overflow: hidden;
}
.byteBin_b16{
  width: 0%;
  opacity: 0;
}
.byteBin_b1{
  width: 100%;
  opacity: 1;
}

*/

/* 

classes for bitplane animation 
(in order of expanding from 16-wide to 1-wide) 

*/

/* 0 */
.g32{
  display: grid;
  grid-column: 1 / -1;
  grid-template-rows: 1fr;

}
.g32_b16{
  grid-template-columns: subgrid;
  /* height: 4em; */
}
.g32_b1{
  grid-template-columns: subgrid;
  height: 100%;
}


/* 1 */
.hex_header_offset_label{
  /* width:0; */
  overflow: hidden;
}
.hex_header_offset_label_b16{
  opacity: 1;
}
.hex_header_offset_label_b1{
  opacity: 0;
}


/* 2 */
.g32r_b16{
  grid-column: 2 / -1;
}
.g32r_b1{
  grid-column: 2 / 3;
}

/* 3 */
.byteOffsetPrefix{
  direction: rtl; /* doing weird stuff so it overflows to the left */
  color: white;
  opacity: 0;
  width: 0;
  /* transition: var(--bitplaneViewerTransition2); */
}
.byteOffsetPrefix_b16{
  opacity: 0;
}
.byteOffsetPrefix_b1{
  opacity: 1;
}


/* 4    and   6  */
/* panel_content goes here */
.panel_content_b16{
  grid-template-rows: 1.5em 1fr; /* this attr is the only one custom to bitplane viewer */
  grid-template-columns: 7ch 16fr 0fr 0fr;
}
.panel_content_intermediate{
  grid-template-rows: 3em 1.5em 1fr; /* this attr is the only one custom to bitplane viewer */
  grid-template-columns: 3fr 1fr 3fr 0fr;
}
.panel_content_b1{
  grid-template-rows: 3em 1.5em 1fr; /* this attr is the only one custom to bitplane viewer */
  grid-template-columns: 7ch 1fr 3fr 10fr;
}
/* also 4 */
.hex_header_base_label_b16{
  /* width: 0%; */
  opacity: 0;
}
.hex_header_base_label_b1{
  /* width: 100%; */
  opacity: 1;
}
/* also 4 */
.byteBin{
  /* direction: ltr;
  opacity: 0;
  align-items: center;
  text-align: right;
  width: 0%;
  overflow: hidden; */
  min-width: 0; 
  min-height: 0;
}
.byteBin_b16{
  opacity: 0;
  width: 0%;
  /* width: 0;
  height: 0;
  overflow: hidden; */
}
.byteBin_b1{
  width: 100%;
  opacity: 1;
}

/* 5 */
.byte{
  grid-area: 2 / 2 / 3 / 3;
  display: grid;
  

}
.byte_b16{

}
.byte_b1{

}
.byte_by16RowEven{
  background-color: rgba(86, 86, 86, 0.35);
}
.byte_by16RowOdd{
  background-color: rgba(0,0,0,0.35); 
}
/* here we would have all 64 .byte_valueXX classes...? */
.fg_bp0{
  --bg: 0;
  --fg: 255;
  /* background-color: rgb(  var(--bg), var(--bg), var(--bg)  ); */
  color: rgb(  var(--fg), var(--fg), var(--fg) );
}
.fg_bp1{
  --bg: 85;
  --fg: 255;
  /* background-color: rgb(  var(--bg), var(--bg), var(--bg)  ); */
  color: rgb(  var(--fg), var(--fg), var(--fg) );
}
.fg_bp2{
  --bg: 170;
  --fg: 0;
  /* background-color: rgb(  var(--bg), var(--bg), var(--bg)  ); */
  color: rgb(  var(--fg), var(--fg), var(--fg) );
}
.fg_bp3{
  --bg: 255;
  --fg: 0;
  /* background-color: rgb(  var(--bg), var(--bg), var(--bg)  ); */
  color: rgb(  var(--fg), var(--fg), var(--fg) );
}
.bg_bp0{
  --bg: 0;
  --fg: 255;
  background-color: rgb(  var(--bg), var(--bg), var(--bg)  );
  color: rgb(  var(--fg), var(--fg), var(--fg) );
}
.bg_bp1{
  --bg: 85;
  --fg: 255;
  background-color: rgb(  var(--bg), var(--bg), var(--bg)  );
  color: rgb(  var(--fg), var(--fg), var(--fg) );
}
.bg_bp2{
  --bg: 170;
  --fg: 0;
  background-color: rgb(  var(--bg), var(--bg), var(--bg)  );
  color: rgb(  var(--fg), var(--fg), var(--fg) );
}
.bg_bp3{
  --bg: 255;
  --fg: 0;
  background-color: rgb(  var(--bg), var(--bg), var(--bg)  );
  color: rgb(  var(--fg), var(--fg), var(--fg) );
}


/* 
end of animation classes
 */




.panel_inner_text{
  grid-template-rows: 3em 1fr;
  grid-template-columns: 1fr;
  max-height: 100px;
}
.text_content{
  width: 100%;
  height: 100%;
  /* max-height: 15em; */
  /* height: 20em;  */
  /* overflow-y:scroll; */
  font-family:Arial, Helvetica, sans-serif;
  padding: 1ch;
  
}
p{
  text-indent: 4ch;
}
ul{
  margin-left: 4ch;
}



/*
Generated ...
*/
.g32rb_item_0_b16{top:25%;left:3.125%;}
.g32rb_item_0_b1{top:1.5625%;left:50%;}
.g32l_item_0_b16{top:25%;left:50%;}
.g32l_item_0_b1{top:1.5625%;left:50%;}
.g32rb_item_1_b16{top:25%;left:9.375%;}
.g32rb_item_1_b1{top:4.6875%;left:50%;}
.g32l_item_1_b16{top:25%;left:50%;}
.g32l_item_1_b1{top:4.6875%;left:50%;}
.g32rb_item_2_b16{top:25%;left:15.625%;}
.g32rb_item_2_b1{top:7.8125%;left:50%;}
.g32l_item_2_b16{top:25%;left:50%;}
.g32l_item_2_b1{top:7.8125%;left:50%;}
.g32rb_item_3_b16{top:25%;left:21.875%;}
.g32rb_item_3_b1{top:10.9375%;left:50%;}
.g32l_item_3_b16{top:25%;left:50%;}
.g32l_item_3_b1{top:10.9375%;left:50%;}
.g32rb_item_4_b16{top:25%;left:28.125%;}
.g32rb_item_4_b1{top:14.0625%;left:50%;}
.g32l_item_4_b16{top:25%;left:50%;}
.g32l_item_4_b1{top:14.0625%;left:50%;}
.g32rb_item_5_b16{top:25%;left:34.375%;}
.g32rb_item_5_b1{top:17.1875%;left:50%;}
.g32l_item_5_b16{top:25%;left:50%;}
.g32l_item_5_b1{top:17.1875%;left:50%;}
.g32rb_item_6_b16{top:25%;left:40.625%;}
.g32rb_item_6_b1{top:20.3125%;left:50%;}
.g32l_item_6_b16{top:25%;left:50%;}
.g32l_item_6_b1{top:20.3125%;left:50%;}
.g32rb_item_7_b16{top:25%;left:46.875%;}
.g32rb_item_7_b1{top:23.4375%;left:50%;}
.g32l_item_7_b16{top:25%;left:50%;}
.g32l_item_7_b1{top:23.4375%;left:50%;}
.g32rb_item_8_b16{top:25%;left:53.125%;}
.g32rb_item_8_b1{top:26.5625%;left:50%;}
.g32l_item_8_b16{top:25%;left:50%;}
.g32l_item_8_b1{top:26.5625%;left:50%;}
.g32rb_item_9_b16{top:25%;left:59.375%;}
.g32rb_item_9_b1{top:29.6875%;left:50%;}
.g32l_item_9_b16{top:25%;left:50%;}
.g32l_item_9_b1{top:29.6875%;left:50%;}
.g32rb_item_10_b16{top:25%;left:65.625%;}
.g32rb_item_10_b1{top:32.8125%;left:50%;}
.g32l_item_10_b16{top:25%;left:50%;}
.g32l_item_10_b1{top:32.8125%;left:50%;}
.g32rb_item_11_b16{top:25%;left:71.875%;}
.g32rb_item_11_b1{top:35.9375%;left:50%;}
.g32l_item_11_b16{top:25%;left:50%;}
.g32l_item_11_b1{top:35.9375%;left:50%;}
.g32rb_item_12_b16{top:25%;left:78.125%;}
.g32rb_item_12_b1{top:39.0625%;left:50%;}
.g32l_item_12_b16{top:25%;left:50%;}
.g32l_item_12_b1{top:39.0625%;left:50%;}
.g32rb_item_13_b16{top:25%;left:84.375%;}
.g32rb_item_13_b1{top:42.1875%;left:50%;}
.g32l_item_13_b16{top:25%;left:50%;}
.g32l_item_13_b1{top:42.1875%;left:50%;}
.g32rb_item_14_b16{top:25%;left:90.625%;}
.g32rb_item_14_b1{top:45.3125%;left:50%;}
.g32l_item_14_b16{top:25%;left:50%;}
.g32l_item_14_b1{top:45.3125%;left:50%;}
.g32rb_item_15_b16{top:25%;left:96.875%;}
.g32rb_item_15_b1{top:48.4375%;left:50%;}
.g32l_item_15_b16{top:25%;left:50%;}
.g32l_item_15_b1{top:48.4375%;left:50%;}
.g32rb_item_16_b16{top:75%;left:3.125%;}
.g32rb_item_16_b1{top:51.5625%;left:50%;}
.g32l_item_16_b16{top:75%;left:50%;}
.g32l_item_16_b1{top:51.5625%;left:50%;}
.g32rb_item_17_b16{top:75%;left:9.375%;}
.g32rb_item_17_b1{top:54.6875%;left:50%;}
.g32l_item_17_b16{top:75%;left:50%;}
.g32l_item_17_b1{top:54.6875%;left:50%;}
.g32rb_item_18_b16{top:75%;left:15.625%;}
.g32rb_item_18_b1{top:57.8125%;left:50%;}
.g32l_item_18_b16{top:75%;left:50%;}
.g32l_item_18_b1{top:57.8125%;left:50%;}
.g32rb_item_19_b16{top:75%;left:21.875%;}
.g32rb_item_19_b1{top:60.9375%;left:50%;}
.g32l_item_19_b16{top:75%;left:50%;}
.g32l_item_19_b1{top:60.9375%;left:50%;}
.g32rb_item_20_b16{top:75%;left:28.125%;}
.g32rb_item_20_b1{top:64.0625%;left:50%;}
.g32l_item_20_b16{top:75%;left:50%;}
.g32l_item_20_b1{top:64.0625%;left:50%;}
.g32rb_item_21_b16{top:75%;left:34.375%;}
.g32rb_item_21_b1{top:67.1875%;left:50%;}
.g32l_item_21_b16{top:75%;left:50%;}
.g32l_item_21_b1{top:67.1875%;left:50%;}
.g32rb_item_22_b16{top:75%;left:40.625%;}
.g32rb_item_22_b1{top:70.3125%;left:50%;}
.g32l_item_22_b16{top:75%;left:50%;}
.g32l_item_22_b1{top:70.3125%;left:50%;}
.g32rb_item_23_b16{top:75%;left:46.875%;}
.g32rb_item_23_b1{top:73.4375%;left:50%;}
.g32l_item_23_b16{top:75%;left:50%;}
.g32l_item_23_b1{top:73.4375%;left:50%;}
.g32rb_item_24_b16{top:75%;left:53.125%;}
.g32rb_item_24_b1{top:76.5625%;left:50%;}
.g32l_item_24_b16{top:75%;left:50%;}
.g32l_item_24_b1{top:76.5625%;left:50%;}
.g32rb_item_25_b16{top:75%;left:59.375%;}
.g32rb_item_25_b1{top:79.6875%;left:50%;}
.g32l_item_25_b16{top:75%;left:50%;}
.g32l_item_25_b1{top:79.6875%;left:50%;}
.g32rb_item_26_b16{top:75%;left:65.625%;}
.g32rb_item_26_b1{top:82.8125%;left:50%;}
.g32l_item_26_b16{top:75%;left:50%;}
.g32l_item_26_b1{top:82.8125%;left:50%;}
.g32rb_item_27_b16{top:75%;left:71.875%;}
.g32rb_item_27_b1{top:85.9375%;left:50%;}
.g32l_item_27_b16{top:75%;left:50%;}
.g32l_item_27_b1{top:85.9375%;left:50%;}
.g32rb_item_28_b16{top:75%;left:78.125%;}
.g32rb_item_28_b1{top:89.0625%;left:50%;}
.g32l_item_28_b16{top:75%;left:50%;}
.g32l_item_28_b1{top:89.0625%;left:50%;}
.g32rb_item_29_b16{top:75%;left:84.375%;}
.g32rb_item_29_b1{top:92.1875%;left:50%;}
.g32l_item_29_b16{top:75%;left:50%;}
.g32l_item_29_b1{top:92.1875%;left:50%;}
.g32rb_item_30_b16{top:75%;left:90.625%;}
.g32rb_item_30_b1{top:95.3125%;left:50%;}
.g32l_item_30_b16{top:75%;left:50%;}
.g32l_item_30_b1{top:95.3125%;left:50%;}
.g32rb_item_31_b16{top:75%;left:96.875%;}
.g32rb_item_31_b1{top:98.4375%;left:50%;}
.g32l_item_31_b16{top:75%;left:50%;}
.g32l_item_31_b1{top:98.4375%;left:50%;}

</style>
<script>

/*
*/

//------------------------------------------------------------------------------
//
//      "3D" SVG stuff (mostly from another project)
//
// Has some features that aren't used much...


// Shorthand
let cos = Math.cos, sin = Math.sin, round = Math.round;


//HACK probably a better method
function hex(integer, chars=2){
    var s = Number(integer).toString(16);
    let caps = {
        'a':'A',
        'b':'B',
        'c':'C',
        'd':'D',
        'e':'E',
        'f':'F'
    }
    while (s.length < chars){
        s = "0"+s;
    }
    return s.replace(/[abcdef]/g, m => caps[m]);
}
//binar(0x8fff,16)
function binar(integer,bit=8,sp=0){
    // assumes 8-bits
    // if space is specified, will add a narrow non-breaking space
    // every sp characters, and a space before and after the string.
    let str = "";
    let b1 = bit-1;
    let mask = 1 << b1;
    for (let i=0; i<bit; i++){
        str+= `${ (integer  & (mask >> i)) >> (b1-i)}`;
        if (sp) if ( (i+1)%sp==0) str+= "&#8239;";
        // if (sp) if ( (i+1)%sp==0) str+= " ";
    }
    return `${sp!=0?"&#8239;":""}${str}`;
    // return `${sp!=0?" ":""}${str}`;
}
// version specifically for html titles, and other non-html character sets (?)
function binart(integer,bit=8,sp=0){
    // assumes 8-bits
    // if space is specified, will add a narrow non-breaking space
    // every sp characters, and a space before and after the string.
    let str = "";
    let b1 = bit-1;
    let mask = 1 << b1;
    for (let i=0; i<bit; i++){
        str+= `${ (integer  & (mask >> i)) >> (b1-i)}`;
        // if (sp) if ( (i+1)%sp==0) str+= "&#8239;";
        if (sp) if ( (i+1)%sp==0) str+= " ";
    }
    // return `${sp!=0?"&#8239;":""}${str}`;
    return `${sp!=0?" ":""}${str}`;
}
// This generates a 2D array pre-filled with zeros. Much like np.zeros() in python.
// Probably pretty efficient...?
function zeros(m,n){
  return [...Array(m)].map( d => Array(n).fill(0));
}


// 
class State {

  constructor(details,kind) {

    
    Object.assign(this, details);

    if (kind == null){
      kind = 'pixels';
    }
    this.kind = kind;
    //HACK: must be a better way of doing this, with .assign?
    switch (kind){
      case 'pixels':
        this.pixels = details; // y, x, channel; 3D array of pixel values
        this.xStartCentered = -sqs*this.pixels[0].length/2;
        this.yStartCentered = -sqs*this.pixels.length/2;
        this.width = sqs*this.pixels[0].length;
        this.height = sqs*this.pixels.length;
        break;
      case 'path':
        this.pathPoints = details.pathPoints;
        this.fill = details.fill;
        this.stroke = details.stroke;
        break;
      case 'pathCurve':
        this.pathPoints = details.pathPoints;
        this.pathPointsExtra = details.pathPointsExtra;
        this.fixedPoints = details.fixedPoints;
        this.fill = details.fill;
        this.stroke = details.stroke;
        break;

    }


  }
}

class Sprite {
  constructor(states, x, y, width, height, untethered, animation) {
    if (untethered==null){
      this.untethered = false;
    } else {
      this.untethered = untethered;
    }
    if (animation==null){
      this.animation = false;
    } else {
      this.animation = animation;
    }
  	this.states = states;
    this.kind = states[0].kind;
    this.x = x;
    this.y = y;
    this.height = height;
    this.width = width;
    this.state = states[0];
  }

}

//https
function bringToTopofSVG(targetElement){
  let parent = targetElement.ownerSVGElement;
  parent.appendChild(targetElement);
}


//https
function bringToTopofSVG(targetElement){
  let parent = targetElement.ownerSVGElement;
  parent.appendChild(targetElement);
}

function moveToendOfSVG(el){
  let parent = el.ownerSVGElement; //without this, weird DOM issues??
  parent.appendChild( el );
}


// View object
class View {
  constructor({name, parent, /*name to append to svg id; parent html node*/
    angleh, anglev, anglehs, anglevs, observation, distance,/*render settings*/
    squaresize, scale,/*sizing settings*/
    sprites, viewBox, className /* sprites, each containing states, containing a pixel array*/}) {
      // console.log(sprites);
  	Object.assign(this, {name, parent, /*name to append to svg id; parent html node*/
      angleh, anglev, anglehs, anglevs, observation, distance,/*render settings*/
      squaresize, scale,/*sizing settings*/
      sprites, viewBox, className /* sprites, each containing states, containing a pixel array*/});


    if (!parent){
      console.log("Error: View() constructor received a null parent node.");
      
    }
    // to be populaed and used later:
    this.elemsObj = []; // objects for each element to be remdered
    this.elemsSVG = []; // the SVG string for each
    this.groups = {};
    this.oldOrder = '';
    this.newOrder = '';

    this.width = null;
    this.height = null;
    this.index = null;
    this.point = null;
    this.rgba = {};

    // center x and y
    // x is slightly offset
    this.x3dfactor = 0.6;
    this.y3dfactor = 0.6;
    
    this.x3d = this.viewBox[2] * this.x3dfactor;
    this.y3d = this.viewBox[3] * this.y3dfactor;

    // which wawy the scene is facing
    this.up = false;
    this.right = false;

    // generate the points based on each sprite's initial state,
    // and assign all the things that will be attributes of the svg element, to .state
    //NOTE: a bit confusing: there is at least 1 state for each "sprite". There is also a
    // "state" used by each element that reflects the current state to be rendered.
    for (var spri = 0; spri < this.sprites.length; spri+=1){
      let sp = this.sprites[spri];
      // console.log(sp.state.pathPoints);
      // console.log(sp.state.dmake(sp.state.pathPoints));
      this.groups[sp.state.group] = {
        name: sp.state.group,
        tags:[`<g id="elements_${this.name}_group_${sp.state.group}" index="${sp.state.group[sp.state.group.length-1]}">`,`</g>`],
        elems: [],
        dist: 0,
        index: 0
      };

    	this.elemsObj.push({
          ...sp.state,
          r: 1,
          untethered: this.sprites[spri].untethered,
          animation: this.sprites[spri].animation,
          kind: sp.kind,
          state: {
            fill: sp.state.fill=="none"?"none":`rgb(${sp.state.fill.join(", ")})`,
            'fill-opacity': sp.state['fill-opacity']=="none"?"none":sp.state['fill-opacity'],
            stroke: sp.state.stroke=="none"?"none":`rgb(${sp.state.stroke.join(", ")})`,
            'stroke-opacity': sp.state['stroke-opacity']=="none"?"none":sp.state['stroke-opacity'],
            d: sp.state.dmake(sp.state.pathPoints),
            'stroke-width': sp.state['stroke-width']?sp.state['stroke-width']:1,
          },
        });
        
    }

    // Assign the actual SVG:
    parent.innerHTML = `<svg id="svg_${this.name}"
                          class="${this.className}"
                            viewBox="${this.viewBox.join(" ")}"
                            preserveAspectRatio="none" >
                            <g id="elements_${this.name}"></g>
                          </svg>`;
    this.svg = document.getElementById(`svg_${this.name}`);
    console.log(`elements_${this.name}`);
    this.svgGroup = document.getElementById(`elements_${this.name}`);
    
    // Now make SVG strings for each element:
    this.elemsSVG = this.elemsObj.map( (d,i) => `\
      <${d.kind} class="${(d.untethered?'untethered':'tethered')} ${d.classes?d.classes.join(" "):""}"
        stroke-linecap="round"
        stroke-linejoin="round"
        ></${d.kind}>`);
        // index="${this.elemsSVG.length+i}" ></${d.kind}>`);
    
    // assign to groups
    this.elemsSVG.forEach((d,i) => this.groups[this.elemsObj[i].group].elems.push( d ) );
    
    // now join all groups together:
    this.svgGroup.innerHTML = ``;
    for (let prop in this.groups) {
      this.svgGroup.innerHTML+=`${this.groups[prop].tags.join(
        this.groups[prop].elems.join('')
      )}`;
    }
    // this.svgGroup.innerHTML = this.elemsSVG.join('');


    this.allNodes = this.svgGroup.querySelectorAll('g > path, g > rect, g > text');

    // store start time, for animation
    this.startTime = Date.now();


    // Setup and event listeners
    //
    // wrapper
    let eventwrap = (t, f) => this.svg.addEventListener(t, e => this.renderRects( f(e) ));

    // User actions
    // for clicking and dragging to rotate:
    eventwrap('click', evt => {
      evt.preventDefault();
      evt.stopPropagation();
      this.index = this.elemsObj[evt.target.getAttribute('index')]
    });
    // clear the point that was clicked on mousup
    eventwrap('mouseup', evt => this.point = null);
    // Get the point clicked
    eventwrap('mousedown', evt => this.point = { x: evt.x,
                                              y: evt.y,
                                              angleh: this.angleh,
                                              anglev: this.anglev});
    // if not null, move to new vertical and horizontal anlges while simultaneously
    // updating the stored horizontal and vertical angle values
    eventwrap('mousemove', evt => {
      evt.preventDefault();
      evt.stopPropagation();
      this.point && (this.angleh = this.point.angleh+(evt.x - this.point.x)/this.anglehs) + (this.anglev = this.point.anglev-(evt.y - this.point.y)/this.anglevs); 
      // console.log("svg View mouse move");
    });

    // for scrolling to zoom:
    eventwrap('wheel', evt => {
      if (evt.ctrlKey) {
        // let hexContent = this.svg.parentNode.parentNode;
        // hexContent.style.overflow = "hidden";
        evt.preventDefault();
        evt.stopPropagation();
        this.observation *= 1-Math.sign(evt.deltaY)*0.015;

        // hexContent.style.overflow = "scroll";
      }
    });

    // resizing the parent element. 
    //TODO: make more performant. There's currently a sort of debounce,
    // but there should just be an alternative to this.renderREcts()
    //  that just moves the current positions instead of re-rendering 3d
    this.debounceResize = false;
    this.resizeObs = new ResizeObserver(
      evt => {
        if (!this.debounceResize){
          this.renderRects();
          // console.log("svg View parentNode resized: just rendered.");
          this.debounceResize = true;
          setTimeout( () => {this.debounceResize = false;}, 200)
        }
      }
    ).observe(this.svg.parentNode);



    // Also set a timeout, so we can have animatinos play:
    // (not used here yet)
    // this.timeout = setInterval(() => this.renderRects(), 1000/30);

    // initial render
    this.renderRects();

  }

  project(el){
    // console.log('Here is where we would project a path');
    let pp = [];
    let rrr = Infinity; //
    let zd = 0;
    let count = 0;
    let distSum = 0;
    // console.log("el.pathPoints:");
    // console.log(el.pathPoints);
    for (let i=0; i < el.pathPoints.length; i++){

      let pt = el.pathPoints[i];
      // console.log( el.pathPoints[i]);
      // Indexing past the array length, as in for extras, should still work:
      if (!el.fixedPoints[i]){
        // console.log("not fixed");
        // console.log(pt);
        // Note the x, y, and z are set up such that z is up,
        // because we assume paths are expected to be more conventional 3D
        let ptx = pt[0];
        let pty = -pt[2];
        let ptz = pt[1];
        let x = ptx*cos(-this.angleh) + ptz*sin(-this.angleh);
        let z = ptz*cos(-this.angleh) - ptx*sin(-this.angleh);
        let y = pty*cos(this.anglev) + z*sin(this.anglev);
        let dist = z*cos(this.anglev) - pty*sin(this.anglev) + this.distance;
        distSum+=dist;
        // let x = pt[0]*cos(this.angleh) + pt[2]*sin(this.angleh);
        // let z = pt[1]*cos(this.angleh) + pt[0]*sin(this.angleh);
        // let y = -pt[2]*cos(this.anglev) + z*sin(this.anglev);
        // let dist = z*cos(this.anglev) + pt[2]*sin(this.anglev) + this.distance;
        // console.log(`(this.observation/dist)*x + this.width: ${[this.observation,dist,x,this.width]}`);
        // pp.push( [(this.observation/dist)*x + this.width/2,
        //                   (this.observation/dist)*y + this.height/2] );
        // pp.push( [(this.observation/dist)*x + this.viewBox[2]/2,
        //                   (this.observation/dist)*y + this.viewBox[3]/2]  );
        // pp.push( [ (this.observation/dist)*x + this.x3d,
        //            (this.observation/dist)*y + this.y3d ]  ); // perspective
        pp.push( [ (this.observation*x) + this.x3d,
                   (this.observation*y) + this.y3d ]  ); // ortho/no perspective

        // Here's where we'd resize the rect element based on z-distance,
        // or radius if using circles
        rrr = Math.min(rrr, this.distance/dist*el.r);
        count++;
      }
      else{
        // console.log("fixed");
        pp.push( [pt[0], pt[1]] ); // or should it be pt[2]. ..?
      }
    }
    // console.log(`rr:4${rr}`);

    // Form the path string from the coordinates we just updated
    // console.log('path pts in project:');
    // console.log(pathPts);

    // can move this to a function/method of this object/elements?
    // console.log(pp);
    el.state.d = el.dmake(pp, this.right, this.up );
    el.state.r = rrr;
    this.groups[el.group].dist+= distSum/count;

    // console.log(px);
    // console.log(`px.state.x, px.state.y, px.state.z,dist,r: ${[px.state.x,px.state.y,px.state.z,dist,px.state.r]}`);

  }

  renderRects(){

    // this.pixels.forEach( (d) => this.project(d));
    // this.pixels.sort( (a,b) => a.state.r - b.state.r );
    // // unpack attributes
    // this.pixels.forEach( (d, i) => Object.entries(d.state)
    //   .forEach(e => this.rectNodes[i].setAttribute(...e)));

    // to help center:
    
    const bbox = this.svg.getBoundingClientRect();
    //HACK: exit the render if there is a null parent node
    if (!this.svg.parentNode) return 1;
    const pbox = this.svg.parentNode.getBoundingClientRect();
    // const xsc = bbox.height/(bbox.width);
    // console.log(this.svg.parentNode);
    // console.log(pbox);
    // console.log(this.svg);
    // console.log(bbox);
    if (pbox.width > 0){
      this.x3d = this.svg.viewBox.animVal.width *this.x3dfactor * pbox.width/bbox.width;
    }

    // Determine which way the 3d scene is facing based on rotation:
    // this.up = Math.floor( (this.anglev+Math.PI) / Math.PI ) % 2
    // works for positive but not negative:
    // this.up = Math.floor( Math.abs( (this.anglev+Math.PI)/Math.PI))%2;
    // this.right = Math.floor( Math.abs( (this.angleh+Math.PI)/Math.PI))%2;

    // probably a more efficient way... 
    let au = (this.anglev+Math.PI)%(Math.PI*2);
    this.up = ( au < 0 ? au+(Math.PI*2) : au ) >= Math.PI;
    let ar = (this.angleh+Math.PI)%(Math.PI*2);
    this.right = ( ar < 0 ? ar+(Math.PI*2) : ar ) >= Math.PI;


    // console.log( `up ${this.up}   right ${this.right}     h ${this.angleh} rad, v ${this.anglev} rad` );



    // console.log(this.x3d);

    // let hyphenate = {
    //   fillOpacity: "fill-opacity",
    //   strokeOpacity: "stroke-opacity"
    // }
    // this.allElements



    for (let g in this.groups) this.groups[g].dist = 0; // Clear the values in group's distance
    
    // project
    // this.elemsObj.forEach( (d) => this.project(d));

    // average groups' new dist values
    // for (let g in this.groups){
    //   this.groups[g].dist/= this.groups[g].elems.length;
    // }

    
    this.elemsObj.forEach( (d) => this.project(d));
    
    for (let g in this.groups) this.groups[g].dist/= this.groups[g].elems.length; // average group's new dist values



    // Sort the groups (descending, because further back will be higher, we "paint" that first)
    // this.elemsObj.sort( (a,b) => a.state.r - b.state.r );
    //TODO: maybe only sort if we enter a new octant, based on this.up and this.right changing?
    this.groupsArray = Object.entries( this.groups ).sort( (entryA,entryB) => entryA[1].dist - entryB[1].dist ).reverse().map( d => d[1] );


    // this.newOrder = this.groupsArray.map( d => `${d.name}[${Math.round(d.dist)}]`).join(' -> ');
    this.newOrder = this.groupsArray.map( d => `${d.name}`).join(' -> ');
    let orderChange = this.newOrder+'' != this.oldOrder+''; 
    if (orderChange) console.log( this.newOrder );
    this.oldOrder = this.newOrder+'';
    // console.log(this.groupsArray);
   
    // bringToTopofSVG();

    // this.elemsObj.sort( (a,b) => a.state.r - b.state.r );
    
    // unpack attributes
    //HACK: uses dictionary to replace certain keys with a hyphenated version,
    // probably a more efficient method to do this...
    // this.elemsObj.forEach( (d, i) => Object.entries(d.state)
    //   .forEach(e => this.allNodes[i].setAttribute(
    //     hyphenate[e[0]] ? hyphenate[e[0]] : e[0], e[1] )
    //   )
    // );
    if (orderChange) {
      for (let i=0; i < this.groupsArray.length; i++){
        let key = this.groupsArray[i].name;

        this.elemsObj.forEach( 
          (d, i) => {
            if (d.group==key) {
              moveToendOfSVG(this.allNodes[i]);
              Object.entries(d.state).forEach( e => this.allNodes[i].setAttribute( e[0], e[1] ) );
            }
          }
        );
      }
    }
    else{
      this.elemsObj.forEach( 
          (d, i) => Object.entries(d.state).forEach( e => this.allNodes[i].setAttribute( e[0], e[1] ) )  
        );
    }
    
    
  }

  newFrame(){
    // This will move to the next frame (pixels of the next state for a sprite)
    return 0
  }

}


function makeBitplaneSVG(parent, name, dat, angleh=0, anglev=0, observation=1, palette=null){

  //NOTE: this uses format "bitplane 0" as first bp index... not bp 1.

  if (!parent) {
    // console.log("Error: parent element passed to makeBitplaneSVG() is null.");
    return null;
  }

  let curvs = [];
  // console.log(dat);
  // console.log(parent);
  if (!dat){
    dat = Array.from(Array(32)).map(d=> Math.round(Math.random()*255));
  }

  // console.log("received palette...");
  // console.log(palette);

  // console.log("Generating svg with palette...");
  // console.log(pal);
  // A lot of variables... maybe too much, but should simplify later...
  // byte column / 2d svg fixed coordinates

  // let bprgbfg = [
  //   [127,127,127],
  //   [255,255,255],
  //   [127,127,127],
  //   [0,0,0]
  // ]; // colors for stroke of each bitplane
  // let bprgbbg = [
  //   [0,0,0],
  //   [127,127,127],
  //   [255,255,255],
  //   [127,127,127]
  // ]; // background
  
  // let bprgbfg = [
  //   [127,127,127],
  //   [212,212,212],
  //   [42,42,42],
  //   [127,127,127]
  // ]; // colors for stroke of each bitplane
  let bprgbfg = [
    [255,255,255],
    [255,255,255],
    [0,0,0],
    [0,0,0]
  ]; // colors for stroke of each bitplane
  let bprgbbg = [
    [0,0,0],
    [85,85,85],
    [170,170,170],
    [255,255,255]
  ]; // background

  // (also used by indices square):
  var textDefaults = {
    fill: "none",
    'fill-opacity': 0,
    stroke: [255, 255, 255],
    'stroke-opacity': 0.95,
    'stroke-width': 1,
  };
  var solidsDefaults = {
    'fill-opacity': 1,
    'stroke-opacity': 0.0,
    'stroke-width': 2,
  };
  // arrows: 
  var outlinesDefaults = {
    fill: "none",
    'fill-opacity': "0",
    'stroke-opacity': 0.95,
    'stroke-width': 1,
  }
  

  let height = 1000;
  let bscx = 80;
  let bscy = height/32;


  // weird 3d coordinates:
  // let scx = 50/2;
  // let scy = 50/2;
  let scx = 25;
  let scy = 25;
  let scz = 120;
  // let bpcx = 10*scx;
  let bpcx = 0; //default 0?
  // let bpcy = 16*scy;
  let bpcy = 0;
  let bps = scy*16; // bitplane side
  let bpc = bps/8; // bitplane cell length
  let bpch = bps/16; // bitplane cell length half
  let bpcq = bps/32; // bitplane cell length quarter

  let bpl = bpcx-(bps/2); // bitplane left edge
  let bpll = bpl-(6*scx); // slightly left of bitplane left edge
  let arrowHandle = bpl - (5*bpc);
  let arrowHead = bpl - (0.45*bpc);
  let arrowTip = bpl - (0.2*bpc);
  
  
  // let bpd = 1.5*scz; // pb 0 depth
  let bpd = 1.5*bpc*8; // pb 0 depth
  let indexplane = -1.5; // remember bp 0 will be 0, bp 1 will be 1, etc
  scz = bpc*8;
  let bpt = bpcy-(bps/2); // bitplane top edge
  let bptph = -(bpt + bpch); // top plus half a cell length

  let bpnz = bpd/100; // bit plane numbers z depth (offset from their plane)

  // text height, width, x and y offsets
  // let txthsc = 0.5;
  // let txtwsc = 0.25;
  let txthsc = 1;
  let txtwsc = 1;
  let txthu = txthsc *bpc; // not pre-scaled
  let txtwu = txtwsc *bpc;
  let txth = txthsc *bpc/8; // pre-scaled by 8 so it can be multiplied by numsvg
  let txtw = txtwsc *bpc/8;
  let txty = ( bpc - (bpc * txthsc) )/2;
  let txtx = ( bpc - (bpc * txtwsc) )/2;
  

  let bpr = [0,0,0,0]; // bitplane rows completed
  

  // setup for data
  var numsvg = {
    "0":[ [3,1],  [5,1],  [6,2],  [6,6],  [5,7],  [3,7],  [2,6], [2,2], [3,1]  ],
    "1":[ [3,2],  [4,1],  [4,7],  [5,7],  [3,7] ],
    "2":[ [2,2], [3,1], [5,1], [6,2], [2,7], [6,7] ],
    "3":[ [2,2], [3,1], [5,1], [6,2], [6,3], [5,4], [3,4], [5,4], [6,5], [6,6], [5,7], [3,7], [2,6] ],
    "4":[ [6,5], [2,5], [5,1], [5,7]],
    "5":[ [6,1], [2,1], [2,4], [3,3], [5,3], [6,4], [6,6], [5,7], [3,7], [2,6] ],
    "6":[ [5,1], [3,1], [2,2], [2,6], [3,7], [5,7], [6,6], [6,4], [5,3], [3,3], [2,4] ],
    "7":[ [2,1], [6,1], [5,2], [3,7] ],
    "8": [ [5,4], [3,4], [2,3], [2,2], [3,1], [5,1], [6,2], [6,3], [5,4], [6,5], [6,6], [5,7], [3,7], [2,6], [2,5], [3,4] ],
    "9": [ [6,4], [3,4], [2,3], [2,2], [3,1], [5,1], [6,2], [6,4], [3,7] ],
    "10": [ [2,7], [2.5,5.5], [5.5,5.5], [2.5,5.5], [4,1], [6,7] ],
    // "11": [ [5,4], [2,4], [2,1], [5,1], [6,2], [6,3], [5,4], [6,5], [6,7], [2,7], [2,4] ],
    "11": [ [2,1], [5,1], [6,1.5], [6,2.5], [5,3], [2.5,3], [5,3], [6,4], [6,6], [5,7], [2,7], [2.5,7], [2.5,1] ],
    "12": [ [6,6],  [5,7],  [3,7],  [2,6], [2,2], [3,1],  [5,1],  [6,2]  ],
    "13": [ [2,1],  [5,1],  [6,2],  [6,6],  [5,7],  [2,7], [2.5,7], [2.5,1]   ],
    "14": [ [6,1], [2,1], [2,4], [5,4], [2,4], [2,7], [6,7] ],
    "15": [ [6,1], [2,1], [2,4], [5,4], [2,4], [2,7] ],
    
  }
  // convert values to strings:
  // data = data.map(
  //   d =>  Array.from(Array(8).keys()).reduce(
  //       (accum, val, i) => accum+= `${ (d  & (0b10000000 >> i)) >> (7-i)}`, ``)
  //   );
  var data = [];
  // console.log(dat);
  for (let i=0; i<dat.length; i++){
    data.push( binar( dat[i] ) );
    // console.log( [i, binar( dat[i] )] );
  }
  
  while(data.length<32) data.push( '00000000' ); // zero fill if needed
  // dat.forEach( d => data.push( binar( d ) ) );
  
  let tile = zeros(8,8);
  
  // console.log(data);

  let dataPaths = [];

  for (let i=0; i<32; i++){

    let bp = ((i>15)*2) + i%2;
    // console.log(`Y 2D coord: ${(i+0.5)*bscy}`);
    // cast from string to number, shift left the appropriate amount, or this to the value
    for (let j=0; j<8; j++) tile[bpr[bp]][j] |= (1*data[i][j]) << bp;

    // ARROWS
    //
    // Add the arrows going from left side of SVG to left side of each bitplane
    // note that y and z are swapped weirdly...
    // BG ARROW
    curvs.push(
      new Sprite([
      new State(
        {
          pathPoints: [
            [0, (i+0.5)*bscy, 0],
            [bscx, (i+0.5)*bscy, 0],
            [arrowHandle, bpd-(bp*scz), bptph-(bpr[bp]*bpc)],
            [arrowTip, bpd-(bp*scz), bptph-(bpr[bp]*bpc)],
            
            [arrowHead, bpd-(bp*scz), bptph-(bpr[bp]*bpc)-bpcq],
            [arrowTip, bpd-(bp*scz), bptph-(bpr[bp]*bpc)],
            [arrowHead, bpd-(bp*scz), bptph-(bpr[bp]*bpc)+bpcq]
          ],
          fixedPoints: [true, true, false, false],
          ...outlinesDefaults,
          stroke: bprgbbg[bp],
          'stroke-width': 5,
          group: `bp${bp}`,
          dmake(p){
            return `M ${p[0].join(" ")} \
                    C ${p.slice(1,4).map(e => e.join(" ")).join(", ")} \
                    L ${p.slice(4).map(e => e.join(" ") ).join(" L ")}`;
          }
        },
        'path')
      ], 0,0,0,0)
    );
    // FG ARROW
    // (removed: too busy-looking)
    // curvs.push(
    //   new Sprite([
    //   new State(
    //     {
    //       pathPoints: [
    //         [0, ((i+0.5)*bscy) - bpnz, 0],
    //         [bscx, ((i+0.5)*bscy) - bpnz, 0],
    //         [arrowHandle, bpd - (bp*scz) - bpnz, bptph-(bpr[bp]*bpc)],
    //         [arrowTip, bpd - (bp*scz) - bpnz, bptph-(bpr[bp]*bpc)],
            
    //         [arrowHead, bpd - (bp*scz) - bpnz, bptph-(bpr[bp]*bpc)-bpcq],
    //         [arrowTip, bpd - (bp*scz) - bpnz, bptph-(bpr[bp]*bpc)],
    //         [arrowHead, bpd - (bp*scz) - bpnz, bptph-(bpr[bp]*bpc)+bpcq]
    //       ],
    //       fixedPoints: [true, true, false, false],
    //       ...outlinesDefaults,
    //       stroke: bprgbfg[bp],
    //       'stroke-width': 2,
    //       group: `bp${bp}`,
    //       dmake(p){
    //         return `M ${p[0].join(" ")} \
    //                 C ${p.slice(1,4).map(e => e.join(" ")).join(", ")} \
    //                 L ${p.slice(4).map(e => e.join(" ") ).join(" L ")}`;
    //       }
    //     },
    //     'path')
    //   ], 0,0,0,0)
    // );

    // 1S AND 0S
    //
    // Now do the data: numeric characters
    // (working "up" from the "next" row since we already incremented bpr[bp])
    for (let j=0; j<8; j++){
      // console.log( data[i][j]);
      dataPaths.push(
      new Sprite([
        new State(
          {
            pathPoints: numsvg[data[i][j]].map( 
              (d,ii) => [ 
                bpl + (bpc*j) + (d[0]*txtw) + txtx, 
                bpd-(bp*scz)-bpnz,
                -bpt - (bpc*bpr[bp]) - (d[1]*txth) - txty 
              ] ),
            fixedPoints: [], 
            ...textDefaults,
            stroke: bprgbfg[bp],
            group: `bp${bp}`,
            dmake(p){
              return `M${(p.map(e => e[0]+','+e[1])).join(" L")}`;
            }
          },
          'path')
        ], 0,0,0,0)
        
    )
    }

    
    bpr[bp]++; // increment to next row


  }

  // setup for pixel bubbles/boxes
  //
  // txthu
  // txtwu
  // txty
  // txtx
  let txthscbox = txthsc * 1.5;
  let txtwscbox = txtwsc * 1.5;
  let txthbox = txthscbox *bpc; // not pre-scaled
  let txtwbox = txtwscbox *bpc;
  let txtybox = ( bpc - (bpc * txthscbox) )/2;
  let txtxbox = ( bpc - (bpc * txtwscbox) )/2;
  // var cornersFront = [ [0,0], [0,1], [1,1], [1,0] ];
  // var cornersBack = [ [1,1], [1,0], [0,0], [0,1] ];
  var cornersFront = [ [0,0], [0,0.5], [0,1], [0.5,1], [1,1], [1,0.5], [1,0], [0.5,0] ];
  var cornersBack = [ [1,1],  [1,0.5], [1,0], [0.5,0], [0,0], [0,0.5], [0,1], [0.5,1] ];

  for (let i=0; i<8; i++){

    for (let j=0; j<8; j++){

      
      // INDICES CHARACTERS 0-F
      //
      dataPaths.push(
      new Sprite([
        new State(
          {
            pathPoints: numsvg[tile[i][j]].map(
              (d,ii) => [ 
                bpl + (bpc*j) + (d[0]*txtw) + txtx, 
                bpd-(indexplane*scz)-bpnz,
                -bpt - (bpc*i) - (d[1]*txth) - txty 
              ] ),
            fixedPoints: [], 
            ...textDefaults,
            'stroke-opacity': 1,
            group: `indices`,
            classes: [`${tile[i][j]}`],
            dmake(p){
              return `M${( p.map(e => e.join(", ") )).join(" L")}`;
            }
          },
          'path')
        ], 0,0,0,0)
      );

      // PIXEL SQUARES
      //
      if (palette != null ) dataPaths.push(
        new Sprite([
          new State(
            {
              pathPoints: [ 
                [ bpl + (bpc*j) ,  bpd-(indexplane*scz), -bpt - (bpc*i) ], 
                [ bpl + (bpc*j) + bpc ,  bpd-(indexplane*scz), -bpt - (bpc*i) ], 
                [ bpl + (bpc*j) + bpc ,  bpd-(indexplane*scz), -bpt - (bpc*i) - bpc],
                [ bpl + (bpc*j) ,  bpd-(indexplane*scz), -bpt - (bpc*i) - bpc]
              ],
              fixedPoints: [], 
              fill: palette[ tile[i][j] ],
              stroke: [0,0,0],
              'stroke-opacity': 0,
              'fill-opacity': 0.9,
              group: `pixels`,
              classes: [`pixels_${tile[i][j]}`],
              dmake(p){
                return `M${( p.map(e => e.join(", ") )).join(" L")} z`;
              }
            },
            'path')
          ], 0,0,0,0)
        );
      
    // PIXEL BUBBLES
    //
    // dataPaths.push(
    //   new Sprite([
    //     new State(
    //       {
    //         pathPoints: [
    //           ...cornersFront.map(
    //             (d,ii) => [ 
    //               bpl + (bpc*j) + (d[0]*txtwbox) + txtxbox, 
    //               bpd-( 3 *scz)-bpnz,
    //               -bpt - (bpc*i) - (d[1]*txthbox) - txtybox 
    //             ] 
    //           ),
    //           ...cornersBack.map(
    //             (d,ii) => [ 
    //               bpl + (bpc*j) + (d[0]*txtwbox) + txtxbox, 
    //               bpd-(indexplane*scz)-bpnz,
    //               -bpt - (bpc*i) - (d[1]*txthbox) - txtybox 
    //             ] 
    //           )
    //         ],
    //         fixedPoints: [], 
    //         ...textDefaults,
    //         group: `boxes`,
    //         classes: [`box_${tile[i][j]}`],

    //         dmake(p, right, up){
    //           //HACK: convenient but might be slow...
    //           let n = p.map( d => d.join(",") ); 
    //           let f = n.slice(0,8); // front
    //           let b = n.slice(8); // back
    //           // let y = (p[1][1] + p[0][1]) / 2;
    //           // let x = (p[3][0] + p[0][0]) / 2;
    //           // console.log(`y = (${p[1][1]} - ${p[0][1]}) / 2 = ${y} <-> ymid ${ymid}\nx = (${p[3][0]} - ${p[0][0]}) = ${x} <-> xmid ${xmid}`);
    //           //TODO: this could be way cleaner...      arrows front to back ( bp 3-> 2 -> 1 -> 0 -> index ) [opposite of what object is "facing", towards viewer...]
    //           // if ( !right ){
    //           //   if ( !up) return `M${p[0].join(",")} C${p[1].join(",")},${p[1].join(",")},${p[2].join(",")} L${p[4].join(",")} C${p[5].join(",")},${p[5].join(",")},${p[6].join(",")} Z`; //   ↗ 	 	
    //           //   if ( up ) return `M${p[3].join(",")} C${p[0].join(",")},${p[0].join(",")},${p[1].join(",")} L${p[7].join(",")} C${p[4].join(",")},${p[4].join(",")},${p[5].join(",")} Z`; //   ↘
    //           // }
    //           // else if ( right ) {
    //           //   if ( !up) return `M${p[1].join(",")} C${p[2].join(",")},${p[2].join(",")},${p[3].join(",")} L${p[5].join(",")} C${p[6].join(",")},${p[6].join(",")},${p[7].join(",")} Z`; //   ↖ 
    //           //   if ( up ) return `M${p[2].join(",")} C${p[3].join(",")},${p[3].join(",")},${p[0].join(",")} L${p[6].join(",")} C${p[7].join(",")},${p[7].join(",")},${p[4].join(",")} Z`; //   ↙ GOOD
    //           // }
    //           // we are sort of wrapping around the points counterclockwise depending on which direction.
    //           let o = 0;
    //           if ( !right ){
    //             if ( !up) o = 0; //   ↗ 	 	
    //             if ( up ) o = 6; //   ↘
    //           }
    //           else if ( right ) {
    //             if ( !up) o = 2; //   ↖ 
    //             if ( up ) o = 4; //   ↙ 
    //           }
    //           // return `M${p[0].join(",")} C${p[1].join(",")},${p[1].join(",")},${p[2].join(",")} L${p[4].join(",")} C${p[5].join(",")},${p[5].join(",")},${p[6].join(",")} Z`;
    //           return `\
    //             M ${f[(1+o)%8]} 
    //             C ${f[(2+o)%8]},${f[(2+o)%8]},${f[(3+o)%8]}
    //             C ${f[(4+o)%8]},${b[(0+o)%8]},${b[(1+o)%8]}
    //             C ${b[(2+o)%8]},${b[(2+o)%8]},${b[(3+o)%8]}
    //             C ${b[(4+o)%8]},${f[(0+o)%8]},${f[(1+o)%8]}`;
    //         }
    //       },
    //       'path')
    //     ], 0,0,0,0)
    //   );

    }
  }

  // ARROW TOWARD INDICES PLANE
  //
  // INDICES CHARACTERS 0-F
  //
  dataPaths.push(
  new Sprite([
    new State(
      {
        pathPoints: [
           [ 
            0, 
            bpd-(indexplane*0.35*scz) ,
            0
          ],
          [ 
            0, 
            bpd-(indexplane*0.6*scz) ,
            0
          ],
          [ 
            bpc, 
            bpd-(indexplane*0.525*scz) ,
            0
          ],
          
          [ 
            0, 
            bpd-(indexplane*0.6*scz) ,
            0
          ],
          [ 
            -bpc, 
            bpd-(indexplane*0.525*scz) ,
            0
          ],
          
          [ 
            0, 
            bpd-(indexplane*0.6*scz) ,
            0
          ],
        ],
        fixedPoints: [], 
        ...textDefaults,
        group: `indicesArrow`,
        classes: [`arrowToIndicesPlane`],
        dmake(p){
          return `M${( p.map(e => e.join(", ") )).join(" L")}`;
        }
      },
      'path')
    ], 0,0,0,0)
  );

  //
  // BITPLANE SQUARES
  //
  let bprects = [];

  for (let bp=0;bp<4;bp++){

    bprects.push(
      new Sprite([
        new State(
          {
            pathPoints: [
              [bpl, bpd-(bp*scz), bpt],
              [bpl+bps, bpd-(bp*scz), bpt],
              [bpl+bps, bpd-(bp*scz), bpt+bps],
              [bpl, bpd-(bp*scz), bpt+bps]
            ],
            fixedPoints: [], 
            ...solidsDefaults,
            fill: bprgbbg[bp],
            stroke: bprgbfg[bp],
            group: `bp${bp}`,
            dmake(p){
              return `M${([...p,p[0]].map(e => e[0]+','+e[1])).join(" L")}`;
            }
          },
          'path')
        ], 0,0,0,0)
    );

  }

  //
  // INDICES PLANE SQUARE
  //
  //TODO: break this into a separate function to be called for both bitplanes and indices plane?
  let bp = indexplane;
  bprects.push(
      new Sprite([
        new State(
          {
            pathPoints: [
              [bpl, bpd-(bp*scz), bpt],
              [bpl+bps, bpd-(bp*scz), bpt],
              [bpl+bps, bpd-(bp*scz), bpt+bps],
              [bpl, bpd-(bp*scz), bpt+bps]
            ],
            fixedPoints: [], 
            ...textDefaults,
            'stroke-opacity':0,
            group: `indices`,
            dmake(p){
              return `M${([...p,p[0]].map(e => e[0]+','+e[1])).join(" L")}`;
            }
          },
          'path')
        ], 0,0,0,0)
    )

  // return [curvs, bprects];
  // var bpsvg = makeBitplaneSVG();

  // console.log("all paths:");
  // console.log([...curvs, ...bprects, ...dataPaths]);

  return new View({
    name: name,
    parent: parent, /* replace with document.body for safe / reliable functioning */
    angleh: angleh,
    anglev: anglev,
    anglehs: 100,
    anglevs: 100,
    observation: observation,
    distance: 1,
    squaresize: 1,
    scale: 1,
    sprites: [...curvs, ...bprects, ...dataPaths],
    viewBox: [0, 0, height*0.75, height],
    className: "bpsvg",
    // sprites: [...segments, head11],
  });



}


// var bpsvg = makeBitplaneSVG();
//
//
// var view2 = new View({
//   name: '2',
//   parent: document.body, /* replace with document.body for safe / reliable functioning */
//   angleh: 0,
//   anglev: 0,
//   anglehs: 100,
//   anglevs: 100,
//   observation: 1000,
//   distance: 1000,
//   squaresize: sqs,
//   scale: 1,
//   sprites: [...bpsvg[0], ...bpsvg[1]],
//   // sprites: [...segments, head11],
// });
//NOTES:
//
// WEIRD MODE
// set distance and observation to a small number, like 10, and
// rotate to see the pixels wrap around to the other side of the screen.
//
// ISOMETRIC-ISH MODE (already default now)
// Set distance much higher than observation. Ex: dist 100000, obser 100.
// You'll have to zoom in or scale everything appropriately, but it should look
// more isometric. Scale=1 works well, but might not matter??
//


</script>





<body>

  <svg width="100vw" height="100vh" style="position:absolute;">
    <!-- oooh banana -->
    <pattern id="polka-dot" x="0" y="0" width="100" height="100" patternUnits="userSpaceOnUse">
      
      <path d="M 31.320569 9.8309245
      L 30.413647 10.09189
      L 29.443681 10.860836
      L 31.015161 13.924731
      C 31.015161 13.924731 31.004927 23.577975 28.357442 27.540955
      C 24.345802 34.194754 14.06723 38.06018 13.17749 42.554508
      L 12.461772 43.594755
      L 12.830741 44.545085
      L 13.928349 44.462919
      C 13.928349 44.462919 19.274033 46.353958 27.285673 41.191284
      C 35.906603 35.635986 40.6979 30.594415 40.17946 22.063253
      C 39.743683 14.892303 34.150887 13.079305 34.150887 13.079305
      L 31.320569 9.8309245
      z
      
      M 81.320618 59.830973
      L 80.413696 60.091939
      L 79.44373 60.860885
      L 81.01521 63.92478
      C 81.01521 63.92478 81.004976 73.578023 78.357491 77.541003
      C 74.345851 84.194802 64.067279 88.060229 63.177539 92.554557
      L 62.46182 93.594804
      L 62.83079 94.545133
      L 63.928398 94.462968
      C 63.928398 94.462968 69.274082 96.354007 77.285722 91.191333
      C 85.906652 85.636035 90.697948 80.594464 90.179508 72.063302
      C 89.743731 64.892352 84.150936 63.079354 84.150936 63.079354
      L 81.320618 59.830973
      z" stroke="none" fill="rgb(50,50,30)" ></path>
    </pattern>
      
    <rect x="0" y="0" width="100vw" height="100vh" fill="url(#polka-dot)"></rect>
  
  </svg>

  <div class="main" id="main">
    <div id="navbar"><h2><i style="padding-left:5ch;">Comp / Decomp Country</i></h2></div>
    <div id="panelgrid"></div>
  </div>




<script>

// for animation... for each element we want to locate
// .getBoundingClientRect();
// console.log(rect.top, rect.right, rect.bottom, rect.left);
// const pal = [
//         [32,32,32],
//         [0,63,63],
//         [0,63,127],
//         [30,15,115],

//         [51,19,105],
//         [67,27,97],
//         [83,40,80],
//         [105,60,75],

//         [140,70,72],
//         [215, 83, 83],
//         [230, 100, 70],
//         [240, 140, 60],

//         [250,200, 50],
//         [255, 255, 40],
//         [255,255,0],
//         [255,255,255]
//     ];

// grayscale
// Array.from(Array(16).keys()).map(d=>[Math.round(255*d/16),Math.round(255*d/16),Math.round(255*d/16)])
const pal = [
  [ 0, 0, 0 ],       [ 16, 16, 16 ],
  [ 32, 32, 32 ],    [ 48, 48, 48 ],
  [ 64, 64, 64 ],    [ 80, 80, 80 ],
  [ 96, 96, 96 ],    [ 112, 112, 112 ],
  [ 128, 128, 128 ], [ 143, 143, 143 ],
  [ 159, 159, 159 ], [ 175, 175, 175 ],
  [ 191, 191, 191 ], [ 207, 207, 207 ],
  [ 223, 223, 223 ], [ 239, 239, 239 ]
];

// each panel of the ui; comes in different kinds
class Panel {
  constructor(parentUI, kind, rowStart, rowEnd, columnStart, columnEnd, name=null, links=null) {
    // panel templats:
    // this.templates = {
    //     binin: {
    //         dom: {

    //         }
    //     }
    // }
    this.ui = parentUI;
    this.outer = document.createElement("div");
    this.ui.grid.append(this.outer);
    if (name != null){
        this.outer.id = name;
    }
    this.outer.className = "panel_outer";

    this.inner = document.createElement("div");
    if (name != null){
        this.inner.id = name+"_inner";
    }
    this.inner.className = "panel_inner";

    this.outer.appendChild(this.inner);

    // set up the dragging "grid"
    for (let i=1; i<4; i++){
      for (let j=1; j<4; j++){
        var edge;
        if ( !( (i==2) && (j==2) ) ){
          edge = this.outer.appendChild( document.createElement("div") );
          edge.classList.add("panel_edge");
          edge.style.gridRow = `${i} / ${i+1}`;
          edge.style.gridColumn = `${j} / ${j+1}`;
          edge.title = `row ${i} / col ${j}`;
        }
        if ( (i==3) && (j==3) ){
          edge.style.cursor = "se-resize";
          console.log(edge);
          this.assignResize(this, edge);
        }
      }
    }


    this.name = name;
    this.nameValid = this.name.replace(/\s/g, ""); // should make a valid html id
    this.kind = kind;
    this.source = null; // input data source
    this.links = []; // references to other panels that might have transformed a .source
    this.nexts = [];
    this.palette = pal; //TODO: re-work palette system
    this.fileInputs = []; // will be populated if there are file <input>s
    // assume it's an array
    if (links){
      links.forEach(d => this.links.push(this.ui.panels[d]) );
    }

    this.eventListeners = []; // need to add them after their on the page...?

    this.index = this.ui.panels.length;
    console.log(`panel  ${this.name} should be index ${this.index}`);

    // HEADER
    // create a header 
    this.inner.appendChild(document.createElement("div") );
    this.panelHeader = this.inner.children[this.inner.children.length-1];
    this.panelHeader.id = this.name+"_header";
    this.panelHeader.className = "panel_header";
    
    // add the title
    this.title = document.createElement("div");
    this.title.innerHTML += this.name;
    this.title.classList.add("panel_header_title");
    this.title = this.panelHeader.appendChild(this.title);

    // add the settings/menu button
    this.menuButton = document.createElement("div");
    this.menuButton.innerHTML += "☰";
    this.menuButton = this.panelHeader.appendChild(this.menuButton);
    this.menuButton.classList.add("panel_menu_button");

    // add the collapse button
    this.collapse = document.createElement("div");
    this.collapse.innerHTML += "˄";
    this.collapse.classList.add("collapser");
    this.collapse = this.panelHeader.appendChild(this.collapse);
    var collapseTime = 2000; // only source of collapse timing, to prevent redundancy
    this.collapse.style.transition = `height ${collapseTime/1000}s ease 0s`;
    // Event listener for collapsing the panelContent
    this.collapse.addEventListener("click", (event) => { 
        
        // handle the css for transition animation
        event.target.classList.toggle("collapser_collapsed");
        this.panelContent.classList.add("panel_content_collapsing_expanding");
        this.panelContent.style.transition = `height ${collapseTime/1000}s ease 0s`;
        setTimeout( () => {this.panelContent.style.transition = ``;}, collapseTime );
        
        // set the actual new height
        if (this.inner.getAttribute("data-collapsed")=="true"){
          this.menu.style.height = "max-content";
          this.panelContent.style.height = this.inner.getAttribute("data-user-height")+"px";
          this.inner.setAttribute("data-collapsed", "false");
        } else {
          this.menu.style.height = "0px";
          this.panelContent.style.height = "0px";
          this.inner.setAttribute("data-collapsed", "true");
        }
      }
    );


    // CONTENT
    // create the content
    this.inner.appendChild(document.createElement("div") );
    this.panelContent = this.inner.children[this.inner.children.length-1];
    this.panelContent.id = this.name+"_content";
    this.panelContent.className = "panel_content";

    // MENU
    // create the settings menu which will normally be hidden
    this.inner.appendChild(document.createElement("div") );
    this.menu = this.inner.children[this.inner.children.length-1];
    this.menu.id = this.name+"_menu";
    this.menu.className = "panel_menu";
    this.menu.innerHTML = "<h4>Settings</h4>";

    // Event listener for opening the menu
    //HACK: using setTimeout...
    setTimeout(
      ()=> {
        this.panelHeader.querySelector(".panel_menu_button").addEventListener("click", (event) => { 
            console.log("toggling menu");

            // change button appearance
            event.target.classList.toggle("panel_menu_button_opened");
            // change menu appearance (show it)
            this.inner.querySelector(".panel_menu").classList.toggle("panel_menu_opened");
            
          }
        );
        console.log("menu event listener added.");
      }, 
      2000);


    // create outer and inner html divs
    // let headerHeight = 0;
    var offsetsTop, m;

    switch (kind){
        case "textDescription":
          //TODO: move the below text to another file
          // this.panelContent.classList.add("panel_inner_text");
          this.panelContent.innerHTML += `\
            <div class="text_content" >
              <p>
                <b>Hello!</b> This app decompresses graphics data from DKC. 
                <br><br>
                It allows users to: 
                <ul>
                  <li> Visualize SNES 4 bit per pixel graphics tiles and their weird intertwined format.<br>More details...
                    <ul>
                      <li> Upload a file to "Input - Compressed Data" to get started. This expects a .bin file that you might get in a disassembly of the game, usually in the "graphics/compressed" folder. Or, copy the hex values from the relevant offset of your ROM to a new file.</li>
                      <li> Click "Change View" to see a diagram of the bitplanes. Click again to return to the hex editor-like view. With the diagram, you can see how they the bits from each plane form a color index of between 0 and 15 (0x0 to 0xF) for each pixel of the tile. for example, if the bitplanes read "1 0 1 0" from front to back for a given pixel, that pixel's index value will be "A".</li>
                      <li> The bitplane diagram is a 3d model and can rotate when dragged. ctrl+scroll to zoom in or out. Smaller windows/displays might encounter issues viewing clearly.</li>
                      <li> Click "<" and ">" to flip through the tiles.</li>
                      <li> Click "Download" to download the raw, decompressed data (still 4BPP intertwined).</li>
                    </ul>
                  </li>
                  <li> View color palettes used in the game's levels. Select a color to have its sub-palette appear in the bitplane viewer and tileset viewer.</li>
                  <li> View the 8x8 pixel tiles in their grayscale form, before they are assigned a color palette.</li>
                  <li> View 32x32 pixel metatiles (each composed of 4x4 tiles) with an assigned palette. Requires graphics tiles, palette, and then tilemap32 to be uploaded. Make sure your tilemap32 matches your 8x8 tiles: for example, don't use a foreground/background tilemap on layer 3 tiles, or vice versa. Mainly meant for FG/BG.</li>
                  <li> View level maps built from the metatiles. Currently limited to only part of the level, for app performance reaons. Requires graphics tiles, palette, tilemap32, and then level map to be uploaded.</li>
                </ul>
                <br><br>
                Most features require uploading a file to the relevant file input panels below. 
              </p>
              <br><br>
              <p>
                The app is at an early stage, but was released to celebrate DKC's 30th anniversary. The goal is to de-mystify DKC hacking and to provide even more appreciation for what Rare developed in the 1990s. Works best in a full screen window, tested most thoroughly with firefox. You can expect more features for visualizing, documenting, and hacking the DKC series soon. Thanks!
              </p>
              <br><br>
              <p>
                Special thanks to the DKC Atlas community members and their previous work. In particular Kingizor's dkcomp program. In the future I will update this page with additional guides and resources, and their proper credits.
              </p>
              <br><br><br>
              <p>
              <b>Disclaimer</b>. This software is not official or supported by Nintendo, nor any other commercial entity. It is provided AS IS, and its use is at your own risk.
              </p>
            </div>`;
          break;

        case "fileIn":
            // Create a file input, save it to the panel object, and add to panel gui
            //TODO: clean up
            // this.panelContent.appendChild( ff() );
            this.fileInputs.push(document.createElement("input"));
            this.fileInputs[this.fileInputs.length-1].id = "ii";
            this.fileInputs[this.fileInputs.length-1].className = "fileInput";
            
            this.fileInputs[this.fileInputs.length-1].type = "file";
            this.fileInputs[this.fileInputs.length-1].value = null;
            // this.input = input;
            // this.fileInputs.push(this.input);
            this.panelContent.appendChild(this.fileInputs[this.fileInputs.length-1]);
            // console.log("panelHeader children");
            // console.log(this.panelHeader.children);
            // headerHeight += this.input.style.height;

            // old way had no break; flow into hexviewer
            break;

        case "bitplaneViewer":
            this.selectedTile = 1;
            // bitplane header (controls)
            //



            // `<div id="Bitplane Viewer - Decompressed Data_bitplane_header" class="bitplane_header">
            //   <button class="byteWidthButton">Change View</button>
            //   <div class="seekButtons">
            //     <button class="seekTileDownButton">&lt;</button>
            //     <a>Tile&nbsp;</a>
            //     <a>1</a>
            //     <a>&nbsp;of&nbsp;</a>
            //     <a>...</a>
            //     <button class="seekTileUpButton">&gt;</button>
            //   </div>
            // </div>`

            // header itself
            let bph = document.createElement("div")
            // bph = this.panelContent.children[this.panelContent.children.length-1];
            bph.id = this.name+"_bitplane_header";
            bph.className = "bitplane_header";

            // this.bitplaneHeader2 = this.panelContent.querySelector(".bitplane_header");
            // console.log("bitplane header query selector:");
            // console.log(this.bitplaneHeader2);

            
            // this.bitplaneHeader3 = this.inner.querySelector(".panel_content > .bitplane_header");
            // console.log(" inner query selector:");
            // console.log(this.bitplaneHeader3.innerHTML);

            
           

            // change view button
            // this.byteWidthButton = document.createElement("button");
            // this.byteWidthButton.innerHTML = "Change View";
            // this.byteWidthButton.className = "byteWidthButton";
            // bph.appendChild(this.byteWidthButton);
            
            // seek tile buttons
            // this.seekTileDownButton = document.createElement("button");
            // this.seekTileDownButton.append("<");
            // this.seekTileDownButton.className = "seekTileDownButton";
            // let seek0 = document.createElement("a");
            // seek0.innerHTML = "Tile&nbsp;";
            // let seek1 = document.createElement("a");
            // seek1.innerHTML = "1";
            // let seek2 = document.createElement("a");
            // seek2.innerHTML = "&nbsp;of&nbsp;";
            // let seek3 = document.createElement("a");
            // seek3.innerHTML = "...";
            // this.seekTileUpButton = document.createElement("button");
            // this.seekTileUpButton.append(">");
            // this.seekTileUpButton.className = "seekTileUpButton";

            let seekButtons = document.createElement("div");
            seekButtons.className = "seekButtons";
            seekButtons.innerHTML = `<button class="seekTileDownButton">&lt;</button><a>Tile&nbsp;</a><a>1</a><a>&nbsp;of&nbsp;</a><a>...</a><button class="seekTileUpButton">&gt;</button>`;
            this.seekButtons = bph.appendChild(seekButtons);

            // this.seekTileDownButton = this.seekButtons.appendChild(this.seekTileDownButton);
            // [ seek0, seek1, seek2, seek3 ].forEach(d => this.seekButtons.appendChild(d));
            // this.seekTileUpButton = this.seekButtons.appendChild(this.seekTileUpButton);

            
            this.bitplaneHeader = this.panelContent.appendChild( bph );
            console.log("bitplane header .children[last]:");
            console.log(this.bitplaneHeader);
            this.inner.classList.add("panel_inner_bitplane");
            this.panelContent.classList.add("panel_content_b1");
            
            //HACK
            setTimeout(()=>{

              // this.inner.querySelector(".panel_content > .bitplane_header > .byteWidthButton").addEventListener("click",
              //   (event) => {
              //     console.log(event);
              //     // changeByteWidth(event.target.parentNode.parentNode);
              //     this.animate16to1();
              //   });

              this.inner.querySelector(".panel_content > .bitplane_header > .seekButtons > .seekTileUpButton").addEventListener("click",
                (event) => { 
                  console.log(event);
                  updateBitplaneSeek(event.target.parentNode.parentNode.parentNode, this, +1)
                }
              );

              this.inner.querySelector(".panel_content > .bitplane_header > .seekButtons > .seekTileDownButton").addEventListener("click",
                (event) => { 
                  console.log(event);
                  updateBitplaneSeek(event.target.parentNode.parentNode.parentNode, this, -1)
                }

              );
              console.log("buttons nodes");
              console.log(this.inner.querySelector(".panel_content > .bitplane_header > .byteWidthButton"));
              console.log(this.inner.querySelector(".panel_content > .bitplane_header > .seekButtons > .seekTileUpButton"));
            }, 2000);

            m = "_b1";

            offsetsTop = `\
              <div class="hex_header_offset"><a>OFFSET</a></div>
              <div class="hex_header_labels_left hex_header_labels_left${m}">
                <a class="hex_header_base_label hex_header_base_label${m}" style="grid-column: 1 / -1;  grid-row: 1;">Hex</a>
              </div>
              <div class="hex_header_labels_right  hex_header_labels_right${m}">
                <a class="hex_header_base_label hex_header_base_label${m}" style="grid-column: 1 / -1;  grid-row: 1;">Binary</a>
              </div>`;

            this.panelContent.innerHTML +=
                `<div class="hex_header">${offsetsTop}</div>
                <div class="hex_content"
                 style="grid-template-rows: 1fr;"></div>`;

            this.panelContent.setAttribute("data-mode","byte1");

            break;

        case "hexViewer":
            // style="height: calc(100% - ${headerHeight}px);"
            //TODO: this is duplicated throughout code, should make modular
            // also, should only show hex offset header if the hex file is loaded and in view?
            m = "_b16";
            let offsets0tof = Array.from( Array(16).keys() ).map(
              (d,i) => `<a class="hex_header_offset_label hex_header_offset_label${m}" style="grid-column: ${1+i};  grid-row: 1;">${hex(d,1)}</a>`
            ).join('');
            offsetsTop = `\
              <div class="hex_header_offset"><a>OFFSET</a></div>
              <div class="hex_header_labels_left hex_header_labels_left${m}">
                ${offsets0tof}
              </div>`;

            setTimeout(()=>{
              // add scroll tracker to hexContent
              this.inner.querySelector(".panel_content > .hex_content").addEventListener("scroll",
                (event)=>{
                  // console.log("scroll");
                  // console.log(event);
                  // console.log(this.inner.querySelector(".panel_content > .hex_content").scrollTop);
                });
            }, 2000);


            ////////////////
            
            this.panelContent.innerHTML +=
                `<div class="hex_header">${offsetsTop}</div>
                <div class="hex_content"
                 style=""></div>`;

            this.panelContent.setAttribute("data-mode","byte16");
                // this.inner.innerHTML +=
                // `<div class="hexViewer" >
                //     <div class="hexViewerTop"></div>

                //     <div class="hexViewerScrollWrapper">
                //         <div class="hexViewerScroll">${sbytes}</div>
                //     </div>
                // </div>`;
                  
            this.panelContent.classList.add("panel_content_b16");

            break;

        case "paletteViewer":
          this.inner.classList.add("panel_inner_palette");
          this.panelContent.innerHTML +=
                `<div class="palette_content" ></div>`;
          break;

        case "tilesetViewer":
          this.inner.classList.add("panel_inner_tileset");
          this.panelContent.innerHTML += `<div class="tileset_content"></div>`;

          break;

        case "metatilesViewer":
          this.inner.classList.add("panel_inner_tileset");
          this.panelContent.innerHTML += `<div class="tileset_content"></div>`;

          break;

        case "levelMapViewer":
          this.inner.classList.add("panel_inner_tileset");
          this.panelContent.innerHTML += `<div class="levelMap_content"></div>`;

          break;
    }



    this.rowStart = rowStart;
    this.rowEnd = rowEnd;
    this.columnStart = columnStart;
    this.columnEnd = columnEnd;

    this.fileData = null;
    this.fileBin = null;

    // Set the CSS:
    // old method, for grid
    // this.updateCSS();

    // new method, absolute/draggable 

    // position the outer
    let pageWidth = document.body.querySelector(".main").clientWidth;
    let left = ((columnStart-1)*pageWidth/32) ;
    this.outer.setAttribute("data-user-left", left);
    this.outer.style.left = left+"px";

    let pageHeight = document.body.querySelector(".main").clientHeight;
    let top = ((rowStart-1)*pageHeight/28);
    this.outer.setAttribute("data-user-top", top);
    this.outer.style.top = top+"px";

    // set widths and height
    let startWidth = (columnEnd-columnStart)*pageWidth/32 ;
    this.inner.setAttribute("data-user-width", startWidth);
    this.inner.style.width = startWidth+"px";
    let bbox = this.inner.getBoundingClientRect();


    // this.inner.style.minHeight = `max-content`;

    // if (bbox.height > (rowEnd-rowStart)*height/28) this.inner.style.height = `${ (rowEnd-rowStart)*height/28 }px`;
    let headerHeight = this.panelHeader.getBoundingClientRect().height;

    // Calculate the height of this panel such that it does not exceed page height,
    // but tries to fit everything to the tallest of 
    // its allocated "grid" space, OR its content
    let startHeightGrid = (rowEnd-rowStart)*pageHeight/28 ;
    let startHeightFitAllContent = this.panelContent.getBoundingClientRect().height + headerHeight;
    var startHeight;
    // But if there's a panel with a lot of content to start with, we'll assume it's meant to scroll
    // (text, for example)
    if (startHeightFitAllContent > pageHeight) startHeight = startHeightGrid;
    else startHeight = Math.min( Math.max(startHeightGrid, startHeightFitAllContent), pageHeight*0.9 );

    // save this for later, so we can collapse to 0, 
    // but later expand back to the previous height
    this.inner.setAttribute("data-user-height", startHeight);
    // this.inner.setAttribute("data-collapsed", false);
    // now actually assign the calculated height to the panelContent
    // (the inner and outer should resize to accomodate, bc of max-content)
    let contentHeightCalculated = startHeight - headerHeight;
    this.panelContent.style.height = `${contentHeightCalculated}px`;

    // console.log(`${this.name}\npageHeight: ${pageHeight}; startHeightGrid: ${startHeightGrid}; startHeightFitAllContent: ${startHeightFitAllContent}; startHeight: ${startHeight}; `);
    // console.log(`${contentHeightCalculated}px`);

    this.outer.style.zIndex = this.index;

    this.assignDrag(this);

    
    this.inner.setAttribute("data-maximized", "false");
    this.outer.setAttribute('data-draggable', "true");
    this.assignMaximize(this);

  }

  sortZ(){

    var panelsZ = this.ui.panels.sort( 
      (a,b) => a.outer.style.zIndex - b.outer.style.zIndex 
    );
    var count = 1;
    // Assumes all Panel.index values are unique...
    panelsZ.forEach( 
      (d,i) => {
        if ( d.index != this.index ){
          d.outer.style.zIndex = count;
          count++;
        }
      }
    );
    this.outer.style.zIndex = count; // put this at the end / on top

  }

  assignDrag(panel){
    // Drag the panel around by grabbing its header
    var element = panel.outer;
    var deltaX = 0, deltaY = 0, startX = 0, startY = 0, left, top;

    this.panelHeader.addEventListener("mousedown", (event) => { 
      event = event || window.event;
      event.preventDefault();
      startX = event.clientX;
      startY = event.clientY;
      document.onmouseup = dragClose;
      document.onmousemove = dragMove;
      
      panel.sortZ();
    });

    function dragMove(event){
      event = event || window.event;
      event.preventDefault();

      if (element.getAttribute('data-draggable')=="false") return 0;
      
        deltaX = startX - event.clientX;
      deltaY = startY - event.clientY;
      startX = event.clientX;
      startY = event.clientY;

      left = element.offsetLeft - deltaX;
      element.style.left = `${left}px`;
      element.setAttribute('data-user-left', left);

      top = Math.max(element.offsetTop - deltaY, 0);
      element.style.top = `${top}px`;
      element.setAttribute('data-user-top', top);

    }

    function dragClose(event){
      document.onmouseup = null;
      document.onmousemove = null;
    }

  }

  assignMaximize(panel){

    let outer = panel.outer, inner = panel.inner;

    this.panelHeader.addEventListener("dblclick", (event) => { 

      event = event || window.event;
      event.preventDefault();
      let content = inner.querySelector(".panel_content");
      console.log("content:");
      console.log(content);
      
      let headerHeight = inner.querySelector(".panel_header").getBoundingClientRect().height;
      let totalHeight = outer.parentNode.getBoundingClientRect().height;

      //
      switch(inner.getAttribute("data-maximized")){
        case "false":
          // move outer to the top left corner   
          outer.style.top = "0px";
          outer.style.left = "0px";
          // expand inner's width and height to full screen
          inner.style.width = "100vw";
          console.log(`headerHeight: ${headerHeight}; panelUserHeight: ${inner.getAttribute("data-user-height")}`);
          // content.style.height = `calc(100vh - ${headerHeight}px)`;
          // content.style.height = "100vh";
          content.style.height = (totalHeight - headerHeight) + "px";
          //
          inner.setAttribute("data-maximized", "true");
          outer.setAttribute('data-draggable', "false");

          break;

        case "true":
          // return to previous size and position:
          [
            [outer,"data-user-top"],
            [outer,"data-user-left"],
            [inner,"data-user-width"],
            [inner,"data-user-height"] 
          ].forEach(d => console.log(`${d[1]}: ${d[0].getAttribute(d[1])}` ));

          outer.style.top = outer.getAttribute("data-user-top")+"px";
          outer.style.left = outer.getAttribute("data-user-left")+"px";
          inner.style.width = inner.getAttribute("data-user-width")+"px";
          content.style.height = (inner.getAttribute("data-user-height")-headerHeight)+"px"; 
          inner.setAttribute("data-maximized", "false");
          outer.setAttribute('data-draggable', "true");
          break;

        default:
          inner.setAttribute("data-maximized", "false");
          break;
          
      }
      
      panel.sortZ();
    });

  }

  assignResize(panel, edge){
    // currently just the bottom right ("southeast") corner.
    var element = panel.inner;
    
    var startWidth, startHeight, startX, startY, bbox, cbox;
    var content, header, headerHeight, collapsed;

    edge.addEventListener("mousedown", (event) => { 
      event = event || window.event;
      event.preventDefault();

      startX = event.clientX;
      startY = event.clientY;

      bbox = element.getBoundingClientRect();
      // cbox = element.querySelector(".panel_content").getBoundingClientRect();

      header = element.querySelector(".panel_header");
      content = element.querySelector(".panel_content");
      headerHeight = header.getBoundingClientRect().height;
      collapsed = this.inner.getAttribute("data-collapsed")=="true";

      startWidth = bbox.width;
      // startHeight = cbox.height;
      startHeight = bbox.height;

      document.onmouseup = resizeClose;
      document.onmousemove = resizeMove;
      
      panel.sortZ();

    });

    function resizeMove(event){
      event = event || window.event;
      event.preventDefault();
      
      let w = Math.max(startWidth + event.clientX - startX, 20) ;
      element.style.width = w+"px";
      element.setAttribute("data-user-width", w);
      // element.style.maxHeight = Math.max(h, element.style.maxHeight.split("px")[0]*1)+"px";
      
      // element.style.height = h;
      if (!collapsed) {
        let h = Math.max(startHeight + event.clientY - startY, headerHeight) ;
        element.setAttribute("data-user-height", h);
        content.style.height = `${h - headerHeight}px`;
      }
      // console.log( content.style.height );

      // console.log(w+" "+h);

    }


    function resizeClose(event){
      document.onmouseup = null;
      document.onmousemove = null;
      console.log("Resize ended.");
      console.log(element.querySelector(".panel_content"));
      console.log(element.querySelector(".panel_header").style.height);
      console.log(headerHeight);
    }

    


  }

  updateBox(rowStartDelta, rowEndDelta, columnStartDelta, columnEndDelta, widthDelta=0, heightDelta=0){
    this.rowStart += rowStartDelta;
    this.rowEnd += rowEndDelta;
    this.columnStart += columnStartDelta;
    this.columnEnd += columnEndDelta;
    // Set the CSS:
    this.updateCSS();
  }
  updateCSS(){
    this.outer.style.gridRowStart = this.rowStart;
    this.outer.style.gridRowEnd = this.rowEnd;
    this.outer.style.gridColumnStart = this.columnStart;
    this.outer.style.gridColumnEnd = this.columnEnd;

  }

  toOneByteWide(){
    // NOTE: needs fine-tuning; can't get the animations to synchronize for some weird reason.
    let ps = document.getElementsByClassName("panel_inner");
    for (let p of ps){
        p.style.width="20em";
    }
    let bs = document.getElementsByClassName("byte");
    for (let b of bs){
        b.style.width="100%";
        b.style.height = "calc(100%/32)";
    }
  }

  generateHexHTML(input = null, offset=0, mode=null, length=32, replace=[]){
    // does main work for generating hex editor-style view and bp viewer ui
    // console.log(input);
    var mode16;
    
    console.log("generateHexHTML");
    [input,
offset,
mode,
length,
replace].forEach(d=>console.log(d));
    var rbytes = [];
    if (input){
      // if we have an input, use it
      rbytes = input;
    }
    else{
      // if we don't  have an input, generate random data (mainly for debug)
      let nbytes = 128;
      // let rbytes = Array.from(Array(nbytes).keys()).map(d => Math.round(Math.random()*255) );
      rbytes = Array.from(Array(nbytes).keys());
    }

    // Get indices of our bytes, and if we have an offset, 
    // grab only those bytes and indices at the offset
    let indices = Array.from( Array(rbytes.length).keys());
    if (offset!=null){
      // we will look only at these 32 bytes.
      rbytes = rbytes.slice(offset, Math.min(offset+length, rbytes.length));
      indices = indices.slice(offset, Math.min(offset+length, indices.length));
    }
    
    // parse the data mode to generate
    if ( mode=="plain") {
      mode16 = true;
    } else if (mode==null){
      mode16 = this.panelContent.getAttribute("data-mode")=='byte16';
    } else{
      mode16 = mode=='byte16';
    }
    var m = mode16?"_b16":"_b1"; // shorthand to be used later
    var notm = !mode16?"_b16":"_b1";

    console.log(`${this.name}: Generating hex html for data with ${rbytes.length} bytes...`);

    // generate hexadecimal and binary strings for each byte
    let rbytesHex = [];
    let rbytesBin = [];
    for (let i=0; i<rbytes.length;i++){
      rbytesHex.push(hex(rbytes[i],2));
      rbytesBin.push(binar(rbytes[i],8,4));
    }

    let sbytes = ``;
    let g32l = ``; //
    let g32r = ``; // 
    let g32b = ``; // running strings
    let bw = 16; // byte width...
    let tw = 32; // total byte width possible...
    let th = 32; // total height (usually just 32 anyway )
    let rows = 1 + (bw<tw); // for normal width
    let tileCount = 0; // will track how many (unnecessary?)
    var g32elem;
    var g32selem;
    var classGen = ``;

    // parent div for following g32 elements
    var hexContent = this.inner.querySelector(" .panel_content > .hex_content");
    var replacing = replace.length!=0;
    if (!replacing){
      hexContent.innerHTML = ''; // clear it all first
      this.numberOfTiles = Math.ceil(rbytes.length/32);
    }

    // hexContent.style.gridTemplateRows = `repeat(${Math.ceil(rbytes.length/32)}, auto)`;

    // loop through all bytes.
    // note that each "tile", or 32 bytes, is contained in a class "g32" div,
    // made up of three columns:
    //
    //  g32l                  g32rr                 g32b       g32s
    //  (left-side offsets)   (actual bytes data)   (binary)   (svg bitplane)
    //                                               \  initially hidden   /
    // if ( !(mode=="plain")){
    for (let i=0; i< rbytes.length; i++){
        let ii = i%32;

        let j = i%th;
        // Mode 16: normal, 16-byte width:
        let row = 1*(j>=bw); // 0 or 1
        let col = j%bw; // 0 to bw
        let gtcn = `${col}fr 1fr ${bw-col-1}fr`;
        let gtrn = `${row}fr 1fr ${rows-(row+1)}fr`;
        let left = 

        //TODO: mode 32...

        row = 1*(j>=tw); // 0 or 1
        col = j%tw; // 0 to bw
        let gtcnn = `${col}fr 1fr ${tw-col-1}fr`;
        let gtrnn = `${row}fr 1fr ${rows-(row+1)}fr`;

        // Mode 1: 1-byte-wide:
        let gtc1 = `0fr 1fr 0fr`;
        let gtr1 = `${j}fr 1fr ${th-j-1}fr`;

        //TODO: better method? Find bitplane
        let bp = (((i>>4)%2)*2)+(i%2);
        let row16Odd = (i>>4)%2;
      
        // // //
        let left16 = 100*((0.5+ii)%16)/16;
        let left1 = 50;
        let top16 = 25+(50*Math.floor(ii/16));
        let top1 = 100*(0.5+ii)/32;
        let classGens = [
          `.g32rb_item_${ii}_b16{top:${top16}%;left:${left16}%;}`,
          `.g32rb_item_${ii}_b1{top:${top1}%;left:${left1}%;}`,
          `.g32l_item_${ii}_b16{top:${top16}%;left:50%;}`,
          `.g32l_item_${ii}_b1{top:${top1}%;left:50%;}\n`
        ] ;
        classGen+=classGens.join(`\n`);

        let offsetType = ((i%16)==0)?'always':'sometimes';
        let fgType = mode16?'':('fg_bp'+bp);

        g32l+=`<div 
          data-bitplane="${bp}" 
        data-gridclass="g32l_item_${ii}" 
        class="g32_item g32_item${m} ${fgType} g32l_offset_${offsetType} g32l_offset_${offsetType}${m} g32l_item_${ii}${m}" 
          >${hex(indices[i],6)}</div>`;

        g32r += `\
        <div 
          data-bitplane="${bp}" 
        data-gridclass="g32rb_item_${ii}" 
        class="g32_item g32_item${m} ${fgType} g32rb_item_${ii}${m}" 
          >${rbytesHex[i]}</div>
        `;
        
        if ( !(mode=="plain")){
          g32b += `\
          <div 
          data-bitplane="${bp}" 
          data-gridclass="g32rb_item_${ii}" 
          class="g32_item g32_item${m} ${fgType} g32rb_item_${ii}${m}" 
          >${rbytesBin[i]}</div>
          `;
          console.log(`Adding binary HTML for ${1+Math.floor( (offset+i)/32 )}`);
        }

        // if we're 1 before the end of the 32-batch, or at the overall end, close up this group:
        if (  ((i+1)%32 == 0) || (i == (rbytes.length-1)) ){

            // wrapper g32
            if (replace[tileCount]){ // if we're replacing content in a pre-existing g32
              g32elem = replace[tileCount];
              g32elem.innerHTML = ''; // delete contents
              g32elem.classList.add("g32"+m);
              g32elem.classList.remove("g32"+notm);
              console.log(`within generateHexHTML, received mode ${mode}, parsed to mode16 ${mode16}, made a g32 with classes ${Array.from(g32elem.classList).join(", ")}`);

            } else { // creating a new g32
              g32elem = document.createElement('div');
              g32elem.className = "g32";
              g32elem.id = "tile_index_"+(1+Math.floor( (offset+i)/32 ) );
              g32elem.classList.add("g32"+m);
              // assign the tile index (1-based, not 0-based)
              g32elem.setAttribute("data-tile-index", 1+Math.floor( (offset+i)/32 ) );
              hexContent.appendChild(g32elem);
            }

            if ( !(mode=="plain")){
              // g32bg (background)
              let g32bgelem = document.createElement('div');
              g32bgelem.className = "g32bg";
              g32bgelem.classList.add("g32bg"+m);
              
              g32bgelem.innerHTML = Array.from(Array(32).keys()).map(
                (ii)=>`<div class="g32bg_row bg_${Math.floor(ii/16)?(ii%2?"bp3":"bp2"):(ii%2?"bp1":"bp0")}"></div>`
              ).join("");
              g32elem.appendChild(g32bgelem);
            }


            // g32l 
            let g32lelem = document.createElement('div');
            g32lelem.className = "g32l";
            g32lelem.innerHTML = `${g32l}`;
            g32elem.appendChild(g32lelem);

            // g32r
            let g32relem = document.createElement('div');
            g32relem.className = "g32r";
            g32relem.classList.add("g32r"+m);
            g32relem.innerHTML = `${g32r}`;
            g32elem.appendChild(g32relem);

            if ( !(mode=="plain")){
              // g32b
              let g32belem = document.createElement('div');
              g32belem.className = "g32b";
              g32belem.innerHTML = `${g32b}`;
              g32elem.appendChild(g32belem);

              // create the g32s, currently empty but will later contain an svg, if bitplane
              g32selem = document.createElement('div');
              g32selem.className = "g32s";
              g32selem.classList.add("g32s"+m);
              g32selem.id=`${this.nameValid}_g32s_${tileCount}`;
              g32elem.appendChild(g32selem); // comment these out for debugging (slow af)

              if ( !(mode16)){
                
                var tileIndex0Based = Math.floor( (offset+i)/32 );
                var offsetbp = tileIndex0Based*32;
                console.log(`Creating bitplane with data ${offsetbp}, ${offsetbp+32}`);
                console.log(g32selem);
                this.generateBitplaneView( 
                  g32selem, 
                  this.source.data.slice(offsetbp, offsetbp+32), 
                  tileIndex0Based);

              }
            }

            // increment and reset for next group of 32 bytes
            tileCount++;
            g32l = ``;
            g32r = ``;
        }


    }

  // if (!replacing){
  //   this.panelContent.querySelector(".hex_content").style.gridTemplateRows = `repeat(${this.numberOfTiles}, calc(100%/8))`;
  // }
  if (mode16){
    this.panelContent.querySelector(".hex_content").style.gridTemplateRows = `repeat(${this.numberOfTiles}, 4em)`;
  }

  }

    

  generateBitplaneView(parent, data, tileIndex){

    // get previous info, if any, to carry over to next tile's bitplane View
    let anglev = -0.78;    //
    let angleh = -0.36;    //
    let observation = 0.5; // good defaults
    if (this.bpsvgs){
      anglev = this.bpsvgs[0].anglev;
      angleh = this.bpsvgs[0].angleh;
      observation = this.bpsvgs[0].observation;
    }
    this.bpsvgs = []; // clear previous 

    // let str = `${this.nameValid}_g32s_${ntiles}`;
    // let parent = document.getElementById(str); // parent element to which to append svg

    // let data = rbytes.slice(i, i+32);

    this.bpsvgs.push(
      makeBitplaneSVG(
        parent, 
        "bpsvg_"+tileIndex,
        data,
        angleh,
        anglev,
        observation,
        this.palette
      )
    );
  }

  generateDownloadButton(parent, data, fileName, title, label="Download"){
    // let header = this.inner.querySelector(" .panel_header");
    setTimeout( ()=>{
        let downloadButton = document.createElement("button");
        downloadButton.className = "downloadButtons";
        downloadButton.innerHTML = label;
        downloadButton.title = title;
        downloadButton.style.height = "2em";
        this.downloadButton = this.inner.querySelector(".panel_menu").appendChild( downloadButton );

        this.downloadButton.addEventListener("click", (event) => { 

          const dataBlob = new Blob( [data], {type: "application/octet-stream"});
          let urlObject = URL.createObjectURL( dataBlob );

          let a = document.createElement("a");
          a.download = fileName;
          
          a.href = urlObject;
          a.click();
          setTimeout( () => URL.revokeObjectURL( urlObject ) );
        });
      }, 
      2100
    );
  

  }

  generateTilesetHTML(input = null){
    let tilesetContent = this.panelContent.querySelector(".tileset_content");
    tilesetContent.innerHTML = ""; //clear all content first
    tilesetContent.style.maxHeight = "15em";
    // console.log("this.inner");
    // console.log(this.inner);
    // console.log("tileset content");
    // console.log(tilesetContent);
    var count = 1;
    for (let tile of input){
      
      var wrapper = document.createElement("div");
      // canvas.id = "canvas";
      wrapper = tilesetContent.appendChild(wrapper);
      wrapper.className = "tile_wrapper";
      let title = `Tile ${count}\n(Click to view bitplanes)`;
      wrapper.title = title;
      if (count==1){
        console.log(title);
        console.log(wrapper);
      }
      wrapper.setAttribute("data-tile-index", count);

      // add event listener
      wrapper.addEventListener("click", (event) => { 

        let clickedTile = event.target;
        console.log(clickedTile);
        let parent = clickedTile.parentNode;
        console.log(parent);

        // update the bitplane viewer if it's available
        //HACK: assumes index 0 is the bitplane viewer
        if (this.links[0].source){
          // this.nexts[0].generateHexHTML( this.nexts[0].source.data);
          // A wrapper that prevents jumping to 1st tile
          // last argument, override, will ensure the svg is updated.
          
          console.log(`this.links[0]: `);
          console.log(this.links[0]);
          // updateBitplaneSeek(this.links[0].inner, this.links[0], 0, 
          //   parent.getAttribute("data-tile-index")*1 )
          this.selectedTile = parent.getAttribute("data-tile-index")*1;
          this.links[0].scrollToTile( this.selectedTile );
          
        }
        // this is where we could run a little css wobble animation to 
        // highlight this tile's presence within metatiles...?
        // if (this.nexts[0].source){
          
        // }
        
      });

      display( [tile],  wrapper, this.palette, 1 ) ;
      count++;
    }
  }

  generateMetatilesetHTML(input = null){
    let tilesetContent = this.panelContent.querySelector(".tileset_content");


    for (let mt of input){

      let metatileWrapper = tilesetContent.appendChild( document.createElement("div"));
      metatileWrapper.className = "metatile_wrapper";

      for (let st of mt) {
        let pidx = st.paletteIndex*16;
        display( [st.colorIndices],  metatileWrapper, this.palette.slice(pidx,pidx+16), 1 );
      }
    }
  }

  generateLevelMapHTML(input = null){
    console.log("Generating level map (${input.length} metatiles)...");
    let tilesetContent = this.panelContent.querySelector(".levelMap_content");
    
    let cutoff = 16*16;
    let count = 0;
    for (let lt of input){
      let mt = lt.metatile;
      let vf = lt.vflip;
      let hf = lt.hflip;
      let metatileWrapper = tilesetContent.appendChild( document.createElement("div") );
      metatileWrapper.className = "metatile_wrapper";

      for (let st of mt) {
        let pidx = st.paletteIndex*16;
        display( [st.colorIndices],  metatileWrapper, this.palette.slice(pidx,pidx+16), 1 );
      }
      let cssflip = `${hf?'scaleX(-1) ':''}${vf?'scaleY(-1) ':''}`;
      metatileWrapper.style.transform = cssflip;
      // if (vf || hf) console.log(`Level metatile ${count} should be flipped ${cssflip}.`)
      count++;
      if (count >= cutoff) break;
    }
    
  }

  generatePaletteHTML(input = null){
    let paletteContent = this.panelContent.querySelector(".palette_content");

    for (let i=0; i<input.length; i++){
      let colorItem = document.createElement("div");
      colorItem.className = "color_item";
      colorItem.classList.add(`subPalette_${Math.floor(i/16)}`);
      colorItem.style.backgroundColor = `rgba(${input[i].join(", ")}, 1)`;
      colorItem.title = `Index 0x${hex(i,2)}\nSNES 15-bit RGB (${binart(rgb2snes(input[i]),15,5)})\n24-bit RGB (${input[i].join(", ")})`;
      // colorItem.style.color = `rgba(${input[i].map(d => (127+d)%255).join(", ")}, 1)`;
      let c = paletteContent.appendChild( colorItem);

      // let a = document.createElement("a");
      // a.innerHTML = hex(i,2);
      // a.className = "color_label";
      // c.appendChild(a);


      // Handle the selection of palettes:

      c.addEventListener("click", (event) => { 
        let ClickedColorItem = event.target;
        // console.log(ClickedColorItem);
        let parent = ClickedColorItem.parentNode;
        // console.log(parent);
        let subPaletteClass = "subPalette_0"; // placeholder...
        // find the classname containing info about sub-palette:

        for (let className of event.target.classList){
          if ( className.includes("subPalette") ){
            subPaletteClass = className;
            break;
          }
        }
        if ( subPaletteClass == this.selectedSubPalette ){
          // clicking again will remove the palette, go back to grayscale.
          this.selectedSubPalette = "none";
          // Now that we know the current palette, go through and clear others and add to this one.
          for (let colorItem of parent.querySelectorAll(".color_item")){
            if ( colorItem.classList.contains( subPaletteClass ) ) colorItem.classList.remove( "color_item_selected" );
          }
          this.palette = pal;

        } else {
          // otherwise, switch to other subpalete
          this.selectedSubPalette = subPaletteClass;


          // Now that we know the current palette, go through and clear others and add to this one.
          for (let colorItem of parent.querySelectorAll(".color_item")){
            if ( colorItem.classList.contains( subPaletteClass ) ){
              // console.log("adding class: selected");
              colorItem.classList.add( "color_item_selected" );
            } else{
              colorItem.classList.remove( "color_item_selected" );
            }
          }
          
          // assign the palette values to this panel, so other things can reference it.
          // ( by default, this.palette is the global pal constant )
          let subPaletteIndex = subPaletteClass.split("_")[1]*1;
          // console.log("assigning palette "+subPaletteIndex);
          this.palette = input.slice( subPaletteIndex*16, (subPaletteIndex+1)*16 );
        }

        // update dependent panels' palettes:
        this.nexts.forEach( d => d.palette = this.palette);
        
        // update the bitplane viewer if it's available
        //HACK: assumes index 0 is the bitplane viewer
        if (this.nexts[0].source){
          // this.nexts[0].generateHexHTML( this.nexts[0].source.data);
          // A wrapper that prevents jumping to 1st tile
          // last argument, override, will ensure the svg is updated.
          updateBitplaneSeek(this.nexts[0].inner, this.nexts[0], 0, true )
        }
        if (this.nexts[1].source){
          this.nexts[1].generateTilesetHTML( this.nexts[1].source.data);
          // A wrapper that prevents jumping to 1st tile
          // last argument, override, will ensure the svg is updated.
          // updateBitplaneSeek(this.nexts[0].inner, this.nexts[0], 0, true )
        }
        
      });

    }

  }

  scrollToTile( tileIndex ){

    console.log("scrolling to tile "+tileIndex);
    let hc = this.panelContent.querySelector(".hex_content");
    let newTile = hc.querySelector("#tile_index_"+tileIndex);
    let oldTile = hc.querySelector("#tile_index_"+this.selectedTile);
    let oldIndex = (1*oldTile.getAttribute("data-tile-index"));

    // update this panel's currently selected tile
    this.selectedTile = tileIndex;

    
    // perform scrollnewTileng
    console.log(newTile);
    setTimeout(
      ()=>hc.scrollTo({top: newTile.offsetTop-(newTile.offsetHeight), behavior: 'smooth'}),
      0.1
    );

    // replace destination tile data 
    // this.generateHexHTML(this.source.data,(tileIndex-1)*32, null, 32, [newTile]);

    // replace old one:
    // this.generateHexHTML(this.source.data, (oldIndex-1)*32, "plain", 32, [oldTile]);
  }

  animate16to1(overrideMode=null,tile=null){

    if (!this.tic) this.tic = 1.5; // in s

    var hexContent = this.panelContent.querySelector(".hex_content");
    
    if (tile==null){
      // var g32tile = hexContent.querySelector(".g32");
      var g32tile = hexContent.querySelector("#tile_index_"+this.selectedTile);
      // console.log(g32tile);
    }
    else{
      var g32tile = tile;
    }
    var tileIndex = g32tile.getAttribute("data-tile-index")*1;

    var oldMode = this.panelContent.getAttribute("data-mode");
    var newMode = "";
    if (overrideMode){
      newMode = overrideMode;
    }
    else{
      newMode = oldMode=="byte16"?"byte1":"byte16"; // simplified: toggle
    }

    var ani = {
      duration: 1,
      elapsed: 0,   // set to final element's delay for "backwards" order
      direction: 1, // set -1 for "backwards" order
      series: true, // set to false before running parallel animations    
      timingFunction: 'ease',  
      tic: function (duration, delay){
        if (!duration) duration = this.duration;
        if (!delay) delay = this.elapsed;
        this.elapsed+= ( duration * this.direction )
      },
      mate: function (elements, toggleClasses, duration, timingFunction, delay){
        if (!duration) duration = this.duration;
        if (!timingFunction) timingFunction = this.timingFunction;
        if (!delay) delay = this.elapsed; // usually won't specify anyway
        
        let trans = `${duration}s ${timingFunction} ${delay}s`;
        // console.log(toggleClasses[0]+":   "+trans);

        for (let element of elements){

          // // Directly assign a transition
          // element.style.transition = trans;
          // // Assign a timeout for the transition to be removed
          // setTimeout( () => {
          //   element.style.transition = ``;
          //   // console.log((delay+duration)+"s:  "+toggleClasses[0]+"");
          // }, ((delay+duration)*1000)-5 );
          // // toggle the classes
          // toggleClasses.forEach( (d)=> element.classList.toggle(d) );

          
          // Assign a timeout for the transition to be removed
          setTimeout( () => {
            // Directly assign a transition
            element.style.transition = trans;
            // toggle the classes
            toggleClasses.forEach( (d)=> element.classList.toggle(d) );

            setTimeout( () => element.style.transition = ``, ((delay+duration)*1000)-5 );
          
          }, ((delay)*1000) );
          

        }
        // increase the elapsed count
        if (this.series) this.tic(duration, delay);
      }
    };  

    // // animation "steps" labeled according to order when going byte16 -> byte1
    
    // replace default "plain" with more detailed g32:
    this.generateHexHTML( this.source.data, (tileIndex-1)*32, oldMode, 32, [g32tile]);
    console.log("replacing with old mode "+oldMode+" to start with...");

    switch(newMode){
      case "byte16": 
      
        // animation order settings ("backwards" order)
        var numTics = 5;
        ani.duration = this.tic;
        ani.elapsed = (numTics-1) * ani.duration;
        ani.elapsed = 6;
        ani.direction = -1;
        break;

      case "byte1":
        // "forwards" order
        ani.duration = this.tic;
        ani.elapsed = 0;
        ani.direction = 1;

        // if we are going to 1-bit-wide mode, update the html first
        

        // create the svg
        var tileIndex0Based = (1*g32tile.getAttribute("data-tile-index")) - 1;
        var offset = tileIndex0Based*32;
        this.generateBitplaneView( 
          g32tile.querySelector(".g32s"), 
          this.source.data.slice(offset, offset+32), 
          tileIndex0Based);
        break;
    }

    

    // animation "steps" labeled according to order when going byte16 -> byte1
    ani.series = false;

    // already has a 1s grid temp rows transition permanently assigned.
    let before = tileIndex>1? `repeat(${tileIndex-1}, calc(100%/8)) ` : ``;
    let after = tileIndex<this.numberOfTiles? ` repeat(${this.numberOfTiles-tileIndex}, calc(100%/8))` : ``;
    hexContent.style.gridTemplateRows = before + '100%' + after;
    

    // instantly switch the data from taking up all remaining columns of g32 to only taking up one column
    ani.mate( g32tile.querySelectorAll(".g32r"), ["g32r_b16","g32r_b1"], 0.0 ); 

    // 0  expand/collapse height of this tile (g32l, g32rr, and g32s)  
    console.log("Now, will toggle from g32 classes "+Array.from(g32tile.classList).join(", "));
    ani.mate( [g32tile], ["g32_b16","g32_b1"], 0.5 ); 
    ani.tic(0.5);
    
    // parallel animations 
    // (some require custom parsing for each, so we turn of ani.series)
    

    // 1  hide/show offset labels 0-F
    ani.mate(  this.panelContent.querySelectorAll(".hex_header > div > .hex_header_offset_label"), ["hex_header_offset_label_b16","hex_header_offset_label_b1"], 2.5 ); 
    // 1  reposition the g32_items
    g32tile.querySelectorAll("div > .g32_item").forEach( d => ani.mate( [d], ["g32_item_b16","g32_item_b1",...["_b16","_b1"].map(e=>d.getAttribute(`data-gridclass`)+e)], 2.5)  );

    // 2  fade in/out the extra offsets
    ani.mate( g32tile.querySelectorAll(".g32l > .g32l_offset_sometimes"), ["g32l_offset_sometimes_b16", "g32l_offset_sometimes_b1"], 2.5);

    // 3  base labels, "hex" and "binary"   [ parallel w/ above ]
    ani.mate( 
    this.panelContent.querySelectorAll(".hex_header > div > .hex_header_base_label"), ["hex_header_base_label_b16","hex_header_base_label_b1"], 2.5 );
    ani.tic(2.5);

    

    // // 3  expand/collapse the g32b (binary representation) column  [ parallel w/ below ]
    // ani.mate( [this.panelContent], ["panel_content_b16","panel_content_intermediate"], 2 ); 
    // ani.tic(2); 


    // 5  expand/collapse the g32s (svg) column
    // ani.mate( [this.panelContent], ["panel_content_intermediate","panel_content_b1"], 1 ); 
    ani.mate( [this.panelContent], ["panel_content_b16","panel_content_b1"], 1.5 ); 
    ani.tic(1.5); 

    // 4  change the coloring of the byte
    // foreground
    g32tile.querySelectorAll("div > .g32_item").forEach(d => ani.mate( [d], [`fg_bp${d.getAttribute('data-bitplane')}`], 1.5 )  ); 
    // background
    ani.mate( g32tile.querySelectorAll(".g32bg"), ["g32bg_b16","g32bg_b1"], 1.5 );
    ani.tic(1.5); 

    // show/hide the svg
    ani.mate( g32tile.querySelectorAll(".g32s"), ["g32s_b16","g32s_b1"], 1.5 );
    ani.tic(1.5); 

    this.panelContent.setAttribute("data-mode", newMode);


  }
  // generateBitplaneView(parent, data, tileIndex)
  // animate1to16(){

  // }

  propagateSource(){
    // this propagates the update of a source (or addition) out to dependent panels
    console.log(`propagateSource on panel ${this.index}: ${this.name} ( ${this.kind} )`);
    switch (this.kind){
      case "fileIn":
        0;
        break;

      case "hexViewer":
        // decompress
        // if we have source compressed graphics (ignore for calls from others )
        if (this.links[0].source){
          this.source = {
              name: "Decompressed from "+this.links[0].source.file.name,
              kind: "bytes",
              data: dkc1decompress( this.links[0].source.data ),
              panel: this,
              from: this.links[0]
          };
          // updateBitplaneSeek(this.inner, this, 0 );
          // this.generateHexHTML( this.source.data, 0, "plain", this.source.data.length);
          // Truncated version for performance
          this.generateHexHTML( this.source.data.slice(0,32*20), 0, "plain", 32*20);

          // download setup
          if (!this.downloadButton){
            let downloadFileName = this.links[0].source.file.name.replace(".bin","_Decompressed.bin");
            this.generateDownloadButton( 
              this.panelContent.querySelector(".bitplane_header"), 
              this.source.data, downloadFileName, 
              "Download Decompressed Graphics File (.bin)");
          }
        }

        break;

      case "bitplaneViewer":
        // decompress
        // if we have source compressed graphics (ignore for calls from others )
        if (this.links[0].source){
          this.source = {
              name: this.links[0].source.name,
              kind: "bytes",
              data: this.links[0].source.data,
              panel: this,
              from: this.links[0]
          };
          // updateBitplaneSeek(this.inner, this, 0 );
          this.generateHexHTML( this.source.data.slice(0,32), 0, "byte1", 32);

          // download setup
          if (!this.downloadButton){
            let downloadFileName = this.name.replace(".bin","_Decompressed.bin");
            this.generateDownloadButton( 
              this.panelContent.querySelector(".bitplane_header"), 
              this.source.data, downloadFileName, 
              "Download Decompressed Graphics File (.bin)");
          }
        }

        break;

      case "paletteViewer":
        this.source = {
            name: "Decompressed from "+this.links[0].source.file.name,
            kind: "bytes",
            data: palette2rgb( this.links[0].source.data ),
            panel: this,
            from: this.links[0]
        };
        this.generatePaletteHTML( this.source.data);        
        break;

      case "tilesetViewer":
        // de-intertwine the bitplanes, show tilesets
        // (only if we have actual data (this.links[0]), not just palette (this.links[1]) )
        //TODO: better way to source filename
        if (this.links[0].source){
          this.source = {
              name: "De-intertwined from "+this.links[0].source.from.source.file.name,
              kind: "tiles",
              data: unbitplane( this.links[0].source.data ),
              panel: this,
              from: this.links[0]
          };
          // Don't actually use the imported big palette, bc we don't know which subset goes to each 8x8 tile
          // if (this.links[1].source){
          //   this.palette =  this.links[1].source.data ;
          // }
          this.generateTilesetHTML( this.source.data);
        }
        break;

      case "metatilesViewer":
        // create the 32x32 pixel meta tiles, composed of 4x4 tiles of 8x8 pixels, from tileset
        // (only if we palette (this.links[0]), tile data (this.links[1]), AND metatile32 map (this.links[2]) )
        //TODO: better way to source filename
        //TODO: have a default 8x16 palette in case we don't have a source
        if  (this.links[0].source && this.links[1].source && this.links[2].source ){
          console.log(`Building metatiles...`);
          this.source = {
              name: "Metatiles built from "+this.links[2].source.file.name,
              kind: "metatiles",
              data: metatile( this.links[1].source.data, this.links[2].source.data ), /* tiles, tilemap32  */
              panel: this,
              from: this.links[1]
          };
          // get palette from the palette viewer, which has converted SNES format to RGB
          if (this.links[0].source){
            this.palette =  this.links[0].source.data; 
          }
          this.generateMetatilesetHTML( this.source.data);
        }
        break;

      case "levelMapViewer":
        // place the 32x32 pixel meta tiles, from metatileset
        // (only if we palette (this.links[0]), metatile data (this.links[1]), AND level map (this.links[2]) )
        //TODO: better way to source filename
        //TODO: have a default 8x16 palette in case we don't have a source
        if  (this.links[0].source && this.links[1].source && this.links[2].source ){
          console.log(`Building metatiles...`);
          this.source = {
              name: "Levels built from "+this.links[2].source.file.name,
              kind: "metatiles",
              data: levelMap( this.links[1].source.data, this.links[2].source.data ), /* metatiles, level map  */
              panel: this,
              from: this.links[1]
          };
          // get palette from the palette viewer, which has converted SNES format to RGB
          if (this.links[0].source){
            this.palette =  this.links[0].source.data; 
          }
          this.generateLevelMapHTML( this.source.data);
        }
        break;

    }
    // now do the next one, if it exists:
    // if (this.nexts[0] && (this.kind != "paletteViewer") ) { this.nexts[0].propagateSource(); }
    // if (this.nexts[0] ) { this.nexts[0].propagateSource(); }
    this.nexts.forEach( d => d.propagateSource());
  }

}

function fileInput(e, ui, panel){

    // console.log("onchanged");
    // console.log(e);

    var file = e.target.files[0];

    // the hex viewer div
    //HACK: assumes there is only one hexViewercontent per panel...
    let hexContent = panel.panelContent.querySelector(" .hex_content");
    // console.log(panel.name+" hexContent");
    // console.log(hexContent);

    var fReader = new FileReader();
    fReader.readAsArrayBuffer(file);

    console.log("this/e/ui");
    console.log(this);
    console.log(e);
    console.log(ui);

    fReader.addEventListener('load', function (e) {

        panel.source = {
            name: "Raw data from "+file.name,
            kind: "bytes",
            data: new Uint8Array( e.target.result),
            panel: panel,
            file: file
        };

        // panel.generateHexHTML( panel.source.data );  // comment out for speed
       

        // Automatically do the next steps...
        // console.log(panel);
        panel.nexts[0].propagateSource();

    });

}

function changeByteWidth(panel, overrideMode=null){
  // var panel = e.target.parentNode.parentNode;

  var oldMode = panel.getAttribute("data-mode");
  var newMode = "";
  if (overrideMode){
    newMode = overrideMode;
  }
  else{
    newMode = oldMode=="byte16"?"byte1":"byte16"; // simplified: toggle
  }
  

  // console.log(panel);

  // panel.style.gridTemplateColumns = newMode=="byte1"?"2fr 4fr 14fr":"2fr 16fr 0fr";

  var hexOffsetHeaderLabels = panel.querySelector(".hex_header > .hex_offset_labels");
  var hexBaseLabels = panel.querySelector(".hex_header > .hex_base_labels");
  // hof.style.gridTemplateColumns = newMode=="byte1"?"2fr repeat(16, 0.25fr)":"2fr repeat(16, 1fr)";
  var hexContent = panel.querySelectorAll(".hex_content")[0];
  var g32l = hexContent.querySelectorAll(".g32l");
  // hc.style.gridTemplateColumns = newMode=="byte1"?"4fr 14fr":"18fr 0fr";

// hc.style.gridTemplateRows = newMode=="byte1"?`repeat(${g32.length},100%)`:`repeat(${g32.length},1fr)`;


  switch (newMode){
    case "byte16":
      panel.style.gridTemplateColumns = "2fr 16fr 0fr";
      // hexContent.style.gridTemplateRows = `repeat(${g32l.length},5ch)`;
      hexOffsetHeaderLabels.style.opacity = 1;
      hexBaseLabels.style.opacity = 0;
      break;
    case "byte1":
      panel.style.gridTemplateColumns = "2fr 4fr 25fr";
      // hexContent.style.gridTemplateRows = `repeat(${g32l.length},100%)`;
      hexOffsetHeaderLabels.style.opacity = 0;
      hexBaseLabels.style.opacity = 1;
      break;
    }

  // console.log(g32);
  // hc.height = "100%";

  // for grid elements, get the custom grid-template-rows and columns
  var g32rrs = hexContent.querySelectorAll(".g32rr");
  for (var g32rr of g32rrs){
    for (var gr32r of g32rr.querySelectorAll(".g32r")){

      let gcr = gr32r.getAttribute(`data-mode-${newMode}`).split(";");

      gr32r.style.gridTemplateColumns = gcr[0];
      gr32r.style.gridTemplateRows = gcr[1];
      let gr32rByte = gr32r.querySelector(".byte");
      let bp = gr32rByte.getAttribute('data-bitplane');
      let binSpan = gr32rByte.querySelector(".byteBin");
      let prefix = gr32rByte.querySelector(".byteOffsetPrefix");
      // console.log(gr32rByte);
      // console.log(bp);
      // gr.querySelectorAll(".byte")[0].style.justifyContent = newMode=="byte1"?"flex-end":"center";
      if (newMode == "byte16"){
        gr32rByte.classList.remove(`byte_bp${bp}`);
        binSpan.classList.remove(`byteBinOneByteWide`);
        // binSpan.style.width = "0%";
        // binSpan.style.opacity = 0;
        prefix.style.opacity = 0;
        // gr32rByte.style.gridTemplateColumns = "0fr 1fr"; //NOTE: backwards because rtl
      }
      else if (newMode == "byte1"){
        gr32rByte.classList.add(`byte_bp${bp}`);
        binSpan.classList.add(`byteBinOneByteWide`);
        // binSpan.style.width = "100%";
        // binSpan.style.opacity = 1;
        prefix.style.opacity = 1;
        // gr32rByte.style.gridTemplateColumns = "4fr 2fr";
      }
    }
    // console.log(g32);
  }


  panel.setAttribute("data-mode", newMode);

}

function updateBitplaneSeek(panelNode, panel, change, override=false ){
  let texts = panelNode.querySelectorAll(".panel_content > .bitplane_header > .seekButtons > a");
  // first update the total number

  
  // console.log( texts );

  // console.log(panelNode);
  // console.log(panel);
  // console.log(change);
  console.log("seek btn:");
  [panelNode, panel, change, override].forEach( d=> console.log(d));

  if (panel.source){
    let totalNumber = Math.ceil(panel.source.data.length/32);
    console.log(`within updatebitplaneseek if panel.source`);
    texts[3].innerHTML = totalNumber;
    //
    let oldVal = (1*texts[1].innerHTML);

    let newVal =  (typeof(override)=='number' ) ? override : (oldVal+change);

    // min max/ clamp the range:
    if (newVal>totalNumber) newVal = totalNumber;
    if (newVal<1) newVal = 1;


    // if we have a valid change:
    if ( (newVal != oldVal) || (override!=false) ){
      texts[1].innerHTML = newVal;
      console.log(`Valid seek change: updating bitplane seek to ${newVal}`)
      // let offset = 

      panel.generateHexHTML(panel.source.data, (newVal-1)*32 );
    
    } else{
      console.log("invalid seek change");
    }
  }
}


class UImodel {
  constructor(grid, panelsParams, name=null, cell=null) {
    this.grid = grid;
    this.panels = [];
    for (let i = 0; i<panelsParams.length; i++){
        //HACK: surely a better way to do this but whatever
        this.panels.push( new Panel(this,
            panelsParams[i][0], panelsParams[i][1], panelsParams[i][2],
            panelsParams[i][3], panelsParams[i][4], panelsParams[i][5],
            panelsParams[i][6] )
        );
    }

    this.name = name;
    this.sources = []; // will contain source data from files
    if (cell == null){
        let cell = document.createElement("div");
        cell.style.gridRow = 1;
        cell.style.gridColumn = 1;
        cell.style.background = "none";
        cell.style.zIndex = -10;
        this.grid.append(cell);
        this.cell = cell;
        console.log("assigning cell to ui");
    }
    else{
        this.cell = cell; // a reference cell within the grid
    }
    console.log("Appending to main grid...");
    // this.panels.forEach(p => this.grid.append(p.outer));
    // now that they're in the document, add event listeners

    // this.panels.forEach(
    //     p => p.eventListeners.forEach(
    //         // (el) => el[0].addEventListener(el[1], el[2] )
    //         (el) => el.tagName=="INPUT" ? el.onchange = fileInput : 0
    //     )
    // );
    //HACK: this is a weird way to assign the event listener, but it wasn't working otherwise...
    for (let panel of this.panels){

        // console.log(panel);
        //TODO: find a better way to find ALL inputs within a panel, instead
        // of searching through everything in the panelHeader ...?
        // for (let el of panel.panelHeader.children){

        //     if (el.tagName=="INPUT"){
        //         // where "this" will be the UImodel object.
        //         el.onchange = (e) => fileInput(e, this, panel);
        //         ;
        //         console.log("found input");
        //         console.log(el);
        //         console.log(el.onchange);
        //         console.log( [ this, panel ] );

        //     }
        // }

        // if (panel.byteWidthButton){
        //   // panel.inner.querySelectorAll(".panel_header > .byteWidthButton")[0].addEventListener("click",
        //   //     (event) => {changeByteWidth(event.target.parentNode.parentNode)});
        //   console.log("ADDED EVENT LISTENER");
        //   panel.inner.querySelector(".panel_content > .bitplane_header > .byteWidthButton").addEventListener("click",
        //       (event) => {
        //         console.log(event);
        //         // changeByteWidth(event.target.parentNode.parentNode);
        //         panel.animate16to1();
        //       });
        // }
        // if (panel.seekTileUpButton){
        //   // panel.inner.querySelector(".panel_header > div > .seekTileUpButton").addEventListener("click",
        //   //   (event) => { 
        //   //     updateBitplaneSeek(event.target.parentNode.parentNode.parentNode, panel, +1)
        //   //   }
        //   // );
        //   console.log("ADDED EVENT LISTENER");
        //   panel.inner.querySelector(".panel_content > .bitplane_header > .seekButtons > .seekTileUpButton").addEventListener("click",
        //     (event) => { 
        //       console.log(event);
        //       updateBitplaneSeek(event.target.parentNode.parentNode.parentNode, panel, +1)
        //     }
        //   );
        // }
        // if (panel.seekTileDownButton){
        //   // panel.inner.querySelector(".panel_header > div > .seekTileDownButton").addEventListener("click",
        //   //   (event) => { 
        //   //     updateBitplaneSeek(event.target.parentNode.parentNode.parentNode, panel, -1)
        //   //   }
        //   // );
        //   console.log("ADDED EVENT LISTENER");
        //   panel.inner.querySelector(".panel_content > .bitplane_header > .seekButtons > .seekTileDownButton").addEventListener("click",
        //     (event) => { 
        //       console.log(event);
        //       updateBitplaneSeek(event.target.parentNode.parentNode.parentNode, panel, -1)
        //     }
        //   );
        // }


        if (panel.fileInputs[0]){
          panel.inner.querySelectorAll(".panel_content > .fileInput")[0].onchange = (e) => fileInput(e, this, panel);
        }

        // also see if we need to link any panels:
        for (let link of panel.links){
            console.log(`Pushing link: [${link.name}] --> [${panel.name}]`);
            link.nexts.push(panel);
        }
    }
    //HACK
    // document.getElementById("ii").onchange = (e) => fileInput(e, this, this.panels[0]);
    // document.getElementById("btn").addEventListener("click",
    //   (event) => {changeByteWidth(event.target.parentNode.parentNode)});

    

    // changeByteWidth(this.panels[0].inner,"byte16");

    // window.addEventListener('resize', (e) => this.reflow(e), true);
    this.bpsvgs = [];
    let i = 0;

    // for (var g32s of document.getElementsByClassName("g32s")){
    //   this.bpsvgs.push(makeBitplaneSVG(g32s,"bpsvg_"+i));
    //   console.log(i);
    //   i++;
    // }

    // this.reflow(); // initial reflow

  }
  reflow(){
    
    // tries to automatically fit panels. Not used after adding more complicates setup.
    // console.log(this);

    let cellWidth = this.cell.getBoundingClientRect().width;
    let dl = 0; // running tracker of previous panels' width changes
    let dt = 0; // not fully implemented; top deltas

    for (let i=0; i<this.panels.length; i++){
        let panel = this.panels[i];
        // // Get the first child element to be of panel_inner class:
        // var inner;
        // for (let item of panel.element.children ){
        //     if (item.classList.contains("panel_inner")){
        //         inner = item;
        //         break;
        //     }
        // }
        let inner = panel.inner;
        let outer = panel.outer;
        let dw = 0, dh = 0;
        // console.log([inner.getBoundingClientRect().width , outer.getBoundingClientRect().width]);
        if (inner.getBoundingClientRect().width > outer.getBoundingClientRect().width){
            dw = 1;
            // console.log("largen");
        }
        else if (inner.getBoundingClientRect().width  + (1*cellWidth) < outer.getBoundingClientRect().width  ){
            dw = -1;
            // console.log("smallen");
        }
        panel.updateBox(dt, dt+dh, dl, dl+dw);
        // dl += i>0 ? dw : 0;
        dl += dw;
        dt += dh;

    }
  }
}


//
//   Create the ui and panels
//

// let c0 = 2, c1 = 11, c2 = 20, c3=29;
let c0 = 2, c1 = 12, c2 = 22, c3=33;
let d0 = c1-1, d1 = c2-1, d2=c3-1, d3=42;
//              _, kind,                  rows        cols     name=null, link
var inputPanel = ["fileIn",               13, 15,    c0, d0,  "Input - Compressed Data"];
var paletteInputPanel = ["fileIn",        16, 18,    c0, d0,  "Input - Palette"];  //  1
var paletteViewer = ["paletteViewer",      2,  6,    c3, d3,  "Palette", [1]]; // 2
var decompHexPanel = ["hexViewer",         2, 28,    c1, d1,  "Hex Viewer - Decompressed Data", [0, 2]]; // 3
var tilesetViewer = ["tilesetViewer",      7, 12,    c3, d3,  "Tiles", [3, 2]]; //  4
var metatilemapInputPanel = ["fileIn",    19, 21,    c0, d0,  "Input - Tilemap32 (Metatiles)"]; //  5
var metatilesViewer = ["metatilesViewer", 13, 18,    c3, d3,  "Tilemap32 (Metatiles)", [2,4,5]]; // 6 pal viewer, tileset vwr, metatile input 
var levelMapInputPanel = ["fileIn",       22, 24,    c0, d0,  "Input - Level Map"]; //  7
var levelMapViewer = ["levelMapViewer",   19, 27,    c3, d3,  "Level Map", [2,6,7]]; // 8 paletteViewer, metatilesViewer, fileIn
var description = ["textDescription",      2, 12,    c0, d0,  "About"];
var bitplanePanel = ["bitplaneViewer",     2, 28,    c2, d2,  "Bitplane Viewer - Decompressed Data", [3, 2]]; // 10

const ui = new UImodel(
        document.getElementById("panelgrid"),
        [ inputPanel, paletteInputPanel, paletteViewer, decompHexPanel, tilesetViewer, 
        metatilemapInputPanel, metatilesViewer,
        levelMapInputPanel, levelMapViewer,
        description, bitplanePanel ],
        "main"
    );

// ui.panels[0].toOneByteWide(); //HACK
// window.addEventListener('resize', ui.reflow, true);

let pg = document.getElementById("panelgrid");

//debug:
// ui.panels[1].generateHexHTML();

//checkerboard (sort of debug)
// for (let i=1; i<=28; i++){
//     for (let j=1; j<=32;j++){
//         let chkr = document.createElement("div");
//         chkr.className = "checker";
//         chkr.id = "checker_"+i+"_"+j;
//         chkr.style.gridRow = ""+i+"";
//         chkr.style.gridColumn = ""+j+"";
//         if ( (i%2) == (j%2) ){
//             chkr.style.backgroundColor = "black";
//         }
//         pg.append(chkr);


//     }
// }


//-----------------------------------------------------------------------------------------------
//
//  these are more like Utilities
//  (more in <head> as well...)
//-----------------------------------------------------------------------------------------------


// a lot of variations on __Hex, some unused now

// plain text version...
function appendHex(inp,el){
    var str = [];
    inp.forEach( (x, i) => {
        // console.log(x);
        str.push(hex(x));
    });
    // hexView.innerHTML = bin.map( (x) => hex(x)).join(" ");

    el.innerHTML += str.join(" ");

}

// special html div version...
function appendHexHTML(inp,el){
    // gets uint8 data bytes from inp,
    // then appends specially-formatted HTML representations to element el
    var str = [];
    inp.forEach( (x, i) => {
        let byte = document.createElement('div');
        byte.className = "hexAndBinByte";
        byte.innerHTML = (
                `<div class="hexByte">${hex(x)}</div>
                <div class="binByte">${binar(x)}</div>`
            ).trim();
        el.appendChild(byte);
    });
}
// offset html div version...
function appendHexOffsetHTML(inp,el){
    // gets uint8 data bytes from inp,
    // then appends specially-formatted HTML representations to element el
    var str = [];
    inp.forEach( (x, i) => {
        let byte = document.createElement('div');
        byte.className = "offset";
        byte.innerHTML = hex(x,6);
        el.appendChild(byte);
    });
}
// 1-wide special version...
function appendOneWideByteHTML(inp,el){
    // gets uint8 data bytes from inp,
    // then appends specially-formatted HTML representations to element el
    var str = [];
    inp.forEach( (x, i) => {
        let byte = document.createElement('div');
        byte.className = "oneWideByte";
        byte.innerHTML = (
                `${hex(x)} ${binar(x)}`
            ).trim();
        el.appendChild(byte);
    });
}


function dkc1decompress(inp, offset=0){
    // the decompression function.
    // After a block of data dedicates to a look up table,
    // the compressed data consists of spans of data, each starting with a
    // command / control byte. There are 4 types of commands modes.
    let input = inp.slice(offset);
    const modeNames = ["Copy", "RLE", "History", "LUT"];

    var index = 128; // index of byte within data;
    // start after the LUT of 64 16-bit words (64*2=128).
    var output = [];
    while(index < input.length){
        var control = input[index]; // or "command"
        var mode = control >> 6; // same as extracting leftmost 2 bits
        var detail = control & 0b00111111; // extracts rightmost 6 bits
        // console.log(modeNames[mode]+": "+detail);
        switch(mode){
            // COPY
            case 0:
                // here, the detail refers to number of subsequent bytes to copy
                for (let i = 1; i <= detail; i++){
                    output.push(input[index + i]);
                }
                // output.push(input.slice(index + 1, index + 1 + detail));
                index += 1 + detail;
                break;
            // Run-length Encoding ("RLE")
            case 1:
                // here, the detail refers to number of times to copy the subsequent byte
                for (let i = detail; i > 0; i--){
                    output.push(input[index+1]);
                }
                index += 2;
                break;
            // HISTORY
            case 2:
                // Get the next 2 bytes, swap them, treat this as a word.
                // This word is the starting address within the existing OUTPUT data
                // from which to extract <detail> number of bytes
                let addr = input[index+1] | (input[index+2] << 8);
                output.push(...output.slice(addr, addr + detail));
                index += 3;
                break;
            // Lookup Table ("LUT")
            case 3:
                // Take the detail and << 1. This value is our lookup table address.
                // take the 2 bytes of data starting at this address within the input.
                var lutAddress = detail << 1; // Multiplies by 2, ensures evenness
                output.push( input[lutAddress] );
                output.push( input[lutAddress+1] );
                index += 1;

                break;

        }
    }
    console.log(`Decompressed ${input.length} bytes to ${output.length} bytes.`);
    return new Uint8Array(output);
}


function unbitplane(input){
    // Takes SNES 4 bit-per-pixel (4bpp) data and rearranges into image data.
    // Usage:
    // opim=unbitplane(op4);
    //NOTE: for the opposite process, probably want to use .flatmap()
    // returns 

    var output = [];
    // 32 bytes in a tile
    for (var tileIndex = 0; tileIndex<(input.length); tileIndex+=32){
        // console.log("Tile index "+tileIndex);
        let tile = [];
        for (var rowIndex = 0; rowIndex < 8; rowIndex++){
            // console.log("Row index "+rowIndex);
            let row = [
                input[tileIndex + (rowIndex*2) ],
                input[tileIndex + (rowIndex*2) + 1],
                input[tileIndex + (rowIndex*2) + 16],
                input[tileIndex + (rowIndex*2) + 17]
            ];
            let rowOut = [];
            // This uses a lot of bit masking and stuff.
            // Essentially, we go through each column, masking the nth bit of each bitplane,
            // or'ing them together into the appropriate significant bits, then shift back.
            for (columnIndex = 0; columnIndex < 8; columnIndex++){
                let columnValue = 0;
                for (bitplaneIndex = 0; bitplaneIndex < 4; bitplaneIndex++){ // previously was < 8, error?
                    columnValue |= ( row[bitplaneIndex] & (0b10000000 >> columnIndex) ) << bitplaneIndex;
                }
                rowOut.push( columnValue >> ( 7 - columnIndex) );
            }
            tile.push(rowOut);
            // ------------debug
            // console.log();
            var str = [];
            rowOut.forEach( (x, i) => {
                // console.log(x);
                str.push(hex(x));
            });
            // console.log(str.join(" "));
            // -------------------------
        }
        output.push(tile);
    }
    return output;
}




function snes2rgb(color){
  // converts the SNES two-byte RGB (5bits per color channel, plus extra bit)
  // into typical RGB.
  // SNES two-byte format is 0bbb bbgg gggr rrrr
  // so, for each color channel, we shift the number to the right by the appropriate
  // amount to get that channel aligned on the right (red is already aligned),
  // then AND it with 0b11111 to get only those 5 bits, then shift that back by 3 (*2 *2 *2 = *8).
  // then we add the floor division of this by 32.
  
  // ( uses ~~(a/b), not Math.floor() floor division, for efficiency:
  // behaves differently for negative numbers; not of concern here)
  return [
    (color & 0b11111) << 3,
    ( (color >> 5) & 0b11111) << 3,
    ( (color >> 10) & 0b11111) << 3
  ].map(d => d + ~~(d/32));

}

function rgb2snes(rgb){
  // return ((rgb[0]>>3) & 0xFF) + (((rgb[1]>>3) & 0xFF) << 5) + (((rgb[2]>>3) & 0xFF) << 10)
  return rgb.reduce( 
    (sum,val,i) => sum + (( (val>>3) & 0xFF) << (i*5)) ,0
  );
}
//(val,i) => (( (val>>3) & 0xFF) << (i*5)) 

function palette2rgb(inp, offset=0){
  let input = inp.slice(offset);
  
  var output = [];
  for (let i=0; i<input.length; i+=2){
    output.push( snes2rgb( 
      // (input[i] << 8) + input[i+1] /* not swapped */
      (input[i+1] << 8) + input[i]  /* swapped */
      
    ) );
    console.log(`Color ${snes2rgb( (input[i] << 8) + input[i+1] ) }` );
  }
  return output;
}


function display(dat, parent, palette, sc=1){
    // use canvas to display image. Maybe try integrer scaling, and pixel-rendering CSS stuff for better look.
    // console.log(dat);
    // sc is pexel scale
    // const sc = 4; // integer scale for canvas

    var canvas = document.createElement("canvas");
    // canvas.id = "canvas";
    canvas = parent.appendChild(canvas);
    var w = dat[0].length;
    var h = dat[0][0].length;
    canvas.className = "tile_item";
    canvas.width = sc * w;
    canvas.height = dat.length*sc * h;
    var ctx = canvas.getContext("2d");
    // var pixels = new Uint8ClampedArray(8*8*4);
    for (var tileIndex = 0; tileIndex<(dat.length); tileIndex++){ 
      //TODO: can remove this outermost loop through tiles; this func is only ever called for 1, wrpped in an array???
        // let rowstr = "";
        for (let rowIndex = 0; rowIndex < dat[tileIndex].length; rowIndex++){

            for (let columnIndex = 0; columnIndex < dat[tileIndex][rowIndex].length; columnIndex++){

                let px = palette[ dat[tileIndex][rowIndex][columnIndex] ];
                // console.log(dat[tileIndex][rowIndex][columnIndex]);
                // console.log(px);
                // let fill = "#"+pal[ dat[tileIndex][rowIndex][columnIndex] ].map(d => hex(d)).join("")+"ff";
                let fill = `rgba(${px[0]}, ${px[1]}, ${px[2]}, 255)`;
                ctx.fillStyle = fill;
                ctx.fillRect(columnIndex*sc, (tileIndex*h*sc) + (rowIndex*sc), sc, sc);

                // rowstr+="R_"+rowIndex+";C_"+columnIndex+":_"+fill;
                // console.log([rowIndex*sc, tileIndex*8*sc + rowIndex*sc, sc, sc]);
            }
        }
        // console.log(rowstr);
    }

    // .putImageData(value, x, y);

    // let df = dat.flat();
    // let cvim = ctx.getImageData(0, 0, canvas.width, canvas.height);
    // console.log(cvim);
    // for (i=0; i<cvim.length/4;i++){
    //     let px = pal[df[i]];
    //     let ii = 4*i;
    //     cvim[ii] = px[0];
    //     cvim[ii+1] = px[1];
    //     cvim[ii+2] = px[2];
    //     cvim[ii+3] = 255;
    // }
    // console.log(cvim);
    // ctx.putImageData(cvim,0,0);
    return canvas;

}

// 
function metatile(tiles, tilemap32){
  
  console.log(`Indexing metatiles...`);
  var tl = 8; // good placeholder for future...?

  var word = 0;
  var vflip = 0;
  var hflip = 0;
  var strow, stcof, rof, cof;
  var metatiles = [];  //TODO: modify so we initialize as one X x m x n array of zeros?
  var metatilesObj = [];
  var metatile;
  var overflows = [];
  let mtstr = [ ["","","",""],["","","",""],["","","",""],["","","",""]]; //HACK: not very clean
  let mtidx = 0;
  let metatileObj = [];
  let stobj = {paletteIndex: 0, colorIndices: zeros(8,8)};
  let stobjs = [];

  for ( let idx = 0; idx < tilemap32.length; idx+=2 ){

    mtidx = idx>>5; // same as floor dividing by 32
    // if starting the next metatile:
    if ( (((idx/2)) % 16 == 0) )  {
      // console.log(`Metatile ${idx/32}`);
      metatile = zeros(32, 32); // initially filled with zeros
      stobjs = [];
    }

    // Get the next 2 bytes, treat this as a word.
    // This word is the starting address within the existing OUTPUT data
    // from which to extract <detail> number of bytes
    // word = tilemap32[idx+1] | (tilemap32[idx] << 8); // not swapped
    word = tilemap32[idx] | (tilemap32[idx+1] << 8); // swapped
    // vh?t tttt tttt tttt // nope
    // vhPp pptt tttt tttt // yep
    vflip = (0x8000 & word) >> 15; // leftmost bit of the word (bit 0)
    hflip = (0x4000 & word) >> 14; // second leftmost bit (bit 1)
    prior = (0x2000 & word) >> 13; // bit 2
    palet = (0x1c00 & word) >> 10; // bit 3-5
    tilex = (0x03ff & word); // 10 rightmost bits (bits 6-15)
    
    
    // Get the row offset and column offset associated with
    // this submatrix/block within the metatile.
    // divide by 2 because each tile is represented by 2 bytes
    // floor divide by 4 (aka >> 2) and mod 4

    // get the 8x8 "subtile" indices
    strof = (( ((idx/2)%16)>>2 ));
    stcof = ((idx/2) %4);
    strof = Math.floor( ((idx/2)%16)/4 );
    mtstr[strof][stcof] = `${vflip},${hflip},${palet}`;

    // stcof = ((idx/2) %4)
    // now multiply that by the number of pixels in a subtile (usually 8)
    rof = tl*strof;
    cof = tl*stcof;

    // [["1","2"],["3","4"]].reduce((sum,d) => sum+="\n"+d.join(" "),"")
    // [["1","2"],["3","4"]].map((d) => d.join(" ")).join("\n")

    // console.log(`\nidx ${idx} (${strof},${stcof}): ${hex(word,4)} / ${binar(word,16)}\t  ${tileIndex}\t  /2=${tileIndex/2}`);
    // console.log(`(tile index ${(tiles[tileIndex])})`);

    // for ( let row = vflip ? 7 : 0; vflip ?( row > -1) : (row < 8); vflip ? row-- : row++){
    var tilestr = ``;
    var rowstr;

    stobjs.push( {paletteIndex: palet, colorIndices: zeros(8,8)} );

    for ( let row = 0; row < tl;  row++){
      rowstr = ``;
      for ( let col = 0; col < tl;  col++){
        0;
        // rowstr += `${hex(tileIndex,4).slice(1)} `;
        // rowstr += ( `${rof + row},${cof + col}|${vflip?7-row:row},${hflip?7-col:col}  `);

        // index backwards from the end, if vflip and/or hflip:
        // console.log([hex(word,4), binar(word,16), binar(tileIndex,16), vflip?7-row:row, hflip?7-col:col]);
        if (tiles[tilex]){
          // console.log(`Tile inde xis ok. rof + row: ${rof + row}; cof + col ${cof + col}`);
          
          metatile[rof + row][cof + col] = tiles[tilex][vflip?7-row:row][hflip?7-col:col];
          stobjs[stobjs.length-1].colorIndices[row][col] = tiles[tilex][vflip?7-row:row][hflip?7-col:col];
          
        }

        else{
          0;
          overflows.push(tilex)
          // console.log(`Tile index too big!! rof + row: ${rof + row}; cof + col ${cof + col}`);
        };
      }
      tilestr+=`${rowstr}\n`;
    }
    
    // console.log(tilestr);
    // console.log(metatile);

    // push this if we're on the last of the 16 tiles.
    if ( (((idx/2)+1) % 16 == 0) )  {
      // metatiles.push( metatile ); old method, didn't include palette indices
      metatilesObj.push(stobjs);
      // console.log(mtstr);
      // console.log(`Metatile ${mtidx}:\n${mtstr.map((d) => d.join(" ")).join("\n")}`);
    }

  }

  // console.log(`Metatile: overflows from available tiles (${overflows.length} total).`);
  // console.log(overflows);
    
  // return metatiles;
  return metatilesObj;


}


function levelMap(metatiles, levelmetatiles){
  
  console.log(`Indexing level map...`);
  var tl = 8; // good placeholder for future...?

  var word = 0;
  var vflip = 0;
  var hflip = 0;
  
  let overflows = [];
  let levelobjs = [];
  

  for ( let idx = 0; idx < levelmetatiles.length; idx+=2 ){

    // Get the next 2 bytes, treat this as a word.
    // word = levelmetatiles[idx+1] | (levelmetatiles[idx] << 8); // not swapped
    word = levelmetatiles[idx] | (levelmetatiles[idx+1] << 8); // swapped
    // vh?t tttt tttt tttt // nope
    // vhPp pptt tttt tttt // yep
    vflip = (0x8000 & word) >> 15; // leftmost bit of the word (bit 0)
    hflip = (0x4000 & word) >> 14; // second leftmost bit (bit 1)
    prior = (0x2000 & word) >> 13; // bit 2 ...?
    tilex = (0x1fff & word); // 13 rightmost bits (bits 4-15)

    if (metatiles[tilex]){
      //TODO: would this cause an issue because we're sort of passing by reference...?
      levelobjs.push( { metatile: metatiles[tilex], vflip: vflip, hflip: hflip} );
    }
    else{
      overflows.push(tilex);
    }

  }

  // console.log(`Level Metatiles: overflows from available tiles (${overflows.length} total):`);
  // console.log(overflows);
    
  // return metatiles;
  return levelobjs;

}

// WIP...
function dkc1compress(input){
    var output = new Uint8Array();
    return output;
}



</script>

</body>

</html>

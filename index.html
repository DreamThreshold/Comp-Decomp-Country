<!DOCTYPE html>
    <html>
<!-- Created 2024-10-23 / Release 0.1 2024-11-21 -->
<head>
  <meta charset="UTF-8">
  <title>Comp/Decomp Country</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="icon" href="data:image/svg+xml;base64,PHN2ZwogICB3aWR0aD0iNjkuMzg5NTcybW0iCiAgIGhlaWdodD0iODcuNDI1MTg2bW0iCiAgIHZpZXdCb3g9IjAgMCA2OS4zODk1NzIgODcuNDI1MTg2IgogICB2ZXJzaW9uPSIxLjEiCiAgIGlkPSJzdmcxIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxkZWZzCiAgICAgaWQ9ImRlZnMxIiAvPgogIDxnCiAgICAgaWQ9ImxheWVyMSIKICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTIuMjU5NDUxLC0zLjcwMjU1MzUpIj4KICAgIDxwYXRoCiAgICAgICBpZD0icGF0aDEiCiAgICAgICBzdHlsZT0iZmlsbDojYjNiMzAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDowLjM2Njk7c3Ryb2tlLW9wYWNpdHk6MC42OSIKICAgICAgIGQ9Im0gNTkuNDA2NDQzLDMuNzAyNTUzNSAtMi4yNjczMDUsMC42NTI0MTQgLTIuNDI0OTE1LDEuOTIyMzY1IDMuOTI4Nyw3LjY1OTczNzUgYyAwLDAgLTAuMDI1NTcsMjQuMTMzMTExIC02LjY0NDI5NywzNC4wNDA1NjEgLTEwLjAyOTEsMTYuNjM0NDk3IC0zNS43MjU1MywyNi4yOTgwNjIgLTM3Ljk0OTg4LDM3LjUzMzg4MiBsIC0xLjc4OTI5NSwyLjYwMDYxOCAwLjkyMjQyMiwyLjM3NTgyNSAyLjc0NDAyLC0wLjIwNTQyNSBjIDAsMCAxMy4zNjQyMSw0LjcyNzU5NyAzMy4zOTMzMSwtOC4xNzkwODggQyA3MC44NzE1MjgsNjguMjE1MTk4IDgyLjg0OTc3MSw1NS42MTEyNzEgODEuNTUzNjcxLDM0LjI4MzM2NiA4MC40NjQyMjgsMTYuMzU1OTkgNjYuNDgyMjM4LDExLjgyMzQ5NSA2Ni40ODIyMzgsMTEuODIzNDk1IFoiIC8+CiAgPC9nPgo8L3N2Zz4K" />

</head>
<style>

*{
  margin: 0;
  padding: 0;
  box-sizing: border-box;

}
:root {
  /* --bitplaneViewerTransition: 3s cubic-bezier( 0.33, 0, 0.31, 1 ) 0s;
  --bitplaneViewerTransition2: 2s cubic-bezier( 0.33, 0, 0.31, 1 ) 3s; */
  --bitplaneViewerTransition: 3s cubic-bezier( 0.31, 0, 0, 1 );
  --bitplaneViewerTransition2: 3s cubic-bezier( 0.99, 0, 0.34, 1 );
  --bp0bg: 0;
  --bp0fg: 255;
  --textColor: rgba(248, 248, 248, 1);
  --textColorTransparent: rgba(248, 248, 248, 0);

  /* more accurate... */
  /* --superPurple: rgb(123,91,174);
  --superBlue: rgb(194,189,235);
  --superLightGray: rgb(200,200,200);
  --superGray: rgb(165,165,165);
  --superDarkGray: rgb(86,86,86); */


  /* --superPurple: rgb(33, 24, 46); */
  --superPurple: rgb(36, 27, 51);
  --superBlue: rgb(194,189,235);
  --superLightGray: rgb(200,200,200);
  --superGray: rgb(125, 125, 125);
  --superDarkGray: rgb(21, 21, 21);
}

body{

  /* background: rgb(35, 35, 35); */
  background: var(--superDarkGray);
  /*background: linear-gradient(#aaaa11, #aa11aa); */

  /* background: linear-gradient(yellow, magenta); */
  /* color: rgb(59, 172, 98); */
  color: var(--superBlue);
  font-family: monospace;
  overflow: hidden;
  position: relative;
}

h3{
  margin:1ch;

  font-size: 1.2em;;
}

h4{
  margin:0.5ch;
  /* font-size: 1.2em;; */
}


a{text-align: center;}
g{overflow: visible}
button{
  /* margin: 1ch;
  padding: 3px; */
  /*
  background-color: rgb(50,50,50); */

  background-color: var(--superDarkGray);

  color: var(--superBlue);
  border:none;
  border-radius: 5px;
}

#main{
  position:absolute;
    display: flex;
    flex-grow: 1;
    justify-items: stretch;
    flex-direction: column;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
}
#animationBottom{
  position: relative;
  width: 100vw;
  height:100vh;
}
#animationTop{
  pointer-events: none;
  position: relative;
  width: 100vw;
  height:100vh;
  perspective: 100vw;
  perspective-origin:50% 200%;
  z-index: 100;
}

#navbar{
    height: 2em;
    width: 100%;
    background-color: black;
    display: flex;
    flex-shrink: 0;
    overflow: hidden;
}

#panelgrid{
    position: relative;
    display: grid;
    width: 100%;
    height: 100%;
    grid-template-columns: repeat(32, 1fr);
    grid-template-rows: repeat(28, 1fr);
    grid-auto-flow: row;
    overflow: hidden;

}

.checker{
    background-color: rgb(66, 12, 12);
    z-index: -7;
}

/* grid version... */
/* .panel_outer{
    display: flex;
    grid-row-start: 1;
    grid-row-end: 14;
    background: none;
    border-radius: 7px;
    overflow: hidden;
    overflow-x: visible;
    overflow: visible;
    justify-content: center;

} */
/* draggable version... */
.panel_outer{
    --edge: 10px;
    position: absolute;
    display: grid;
    /* grid-template-columns: 0.5em auto 0.5em;
    grid-template-rows: 0.5em auto 0.5em; */
    grid-template-columns: var(--edge) auto var(--edge);
    grid-template-rows: var(--edge) auto var(--edge);
    background: none;
    /* border: 1px solid blue; */
    border-radius: 7px;
    overflow: hidden;
    overflow-x: visible;
    overflow: visible;
    justify-content: center;
    /* overflow-y: scroll; */
    /* max-height: 20em; */
}

.panel_edge{
  /* background-color: rgba(255,0,0,0.5); */
}

/* Global classes used by all panels */

.panel_inner{

    /* background-color: rgba(7, 7, 80, 0.5); */
    border: 2px solid var(--superDarkGray);
    /* background-color:rgb(17, 11, 15); */
    background-color: var(--superPurple);
    border-radius: 7px;
    justify-self: center;
    overflow: hidden;
    grid-column: 1 / -1;
    grid-row: 1 / -1;

    /* display: grid;
    align-items: stretch;
    grid-template-rows: 3em 1.5em 1fr;
    grid-template-rows: 3em 1fr; */

    /* grid-template-columns: 2fr 16fr 0fr;
    transition:  var(--bitplaneViewerTransition); */
    /* box-shadow: 1em 1em black; */
    transition: grid-template-rows 2s ease;
    /* height: minmax(max-content, 20em); */
    /* max-height: 800px; */
    height: max-content;

    display: grid;
    grid-template-columns: 1fr;
}
/* .panel_inner::after{
  background-color: yellow;
  margin-left: 20px;
  width: 500px;
  height: 300px;
  display: block;
} */


.collapser{
  cursor:pointer;
  text-align: center;
}
.collapser_collapsed{
  transform: rotateX(180deg);
  transition: transform 1s ease 0s;;
}

.panel_menu{
  /* display: grid; */
  grid-row: 2;
  grid-column: 1;
  z-index: 1;
  /* background-color: rgba(12, 12, 59, 0.8); */

  background-color: var(--superGray);
  display: flex;
  /* margin and padding cause weird overflow issues...? */
  /* margin-top: 2em;
  margin-bottom: 2em; */
  overflow-y: auto;
  font-family: Arial, Helvetica, sans-serif;
  display: flex;
  flex-direction: column;


  /* initial, unopened */
  z-index: -1;
  opacity: 0;
  height: 0;
  pointer-events: none;
}

.panel_menu_opened{
  z-index: 10;
  opacity: 1;
  height: max-content;
  pointer-events: all;
}

.panel_menu_button{
  cursor:pointer;
  text-align: center;

}
.panel_menu_button_opened{
  /* border-left: 2px solid white;
  border-top: 2px solid white; */
  border-radius: 6px 6px 0px 0px;
  /* background-color: rgba(12, 12, 59, 0.8);
   */
  background-color: var(--superGray);
}

.panel_header{
    /* height: 2em; */
    /* background-color: rgb(5, 20, 5); */
    display: grid;
    grid-template-columns: auto 3ch 3ch;
    /* flex-direction: row; */
    /* justify-content: space-between; */
    align-items: center;
    grid-area: 1 / 1 / 2 / -1;
    overflow: hidden;
    cursor: move;
    /* transition:  var(--bitplaneViewerTransition); */
}
.panel_header > div{

  height: 100%;
  align-content: center;
}

.panel_content{

  display: grid;
  /* grid-template-columns: 2fr repeat(16, 1fr);
  grid-area: 2 / 1 / 3 / -1; */
  grid-column: 1 / -1;
  grid-row: 2 / 3;
  overflow-y: auto; /* allows scrolling */
  overflow-x: hidden;
}
/* for when the menu is open */
.panel_content_disabled{
  /* pointer-events: none; */
  filter:blur(1px);
}
.panel_header_title{

  margin:1ch;
  margin-right: 2ch;
  font-size: 1em;;
  font-family:Arial, Helvetica, sans-serif;
  /* note: using nowrap and overflow:hidden so the title doesn't
    wrap and increase the height of the header,
    which causes issues with maximizing panels. */
  text-wrap-mode: nowrap;
  overflow: hidden;
}


/* panel type -specific classes */


.bitplane_header{
    /* height: 2em; */
    /* background-color: rgb(20, 40, 20); */
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    grid-area: 1 / 1 / 2 / -1;
    transition:  var(--bitplaneViewerTransition);
}

.panel_inner_bitplane{
  /* grid-template-columns: 2fr 16fr 0fr; */
}



.panel_inner_tileset{

  grid-template-rows: 3em 1fr;
  grid-template-columns: 1fr;
  /* overflow: hidden; */
}

.tileset_content{
  display: flex;
  /* display: grid;
  place-content: stretch; */
  flex-direction: row;
  flex-wrap: wrap;
  width: 100%;;
  /* overflow-y: scroll; */
  /* align-content: stretch; */
  scroll-snap-type: both proximity;
}
.levelMap_content{
  display: grid;
  /* display: grid;
  place-content: stretch; */
  grid-auto-flow: column;
  grid-template-rows: repeat(16, 1fr);
  flex-wrap: wrap;
  height: 100%;;
  overflow-x: scroll;
  /* align-content: stretch; */
  scroll-snap-type: both proximity;
}
/* for wrapper of <canvas> element */
.tile_wrapper{
  flex-grow: 1;
  flex-shrink: 0;
  aspect-ratio: 1 / 1;
  display: grid;
  grid-template-columns: 1fr;
  grid-template-rows: 1fr;
  width: 6.25%; /* works ok */
  width: 25%;
}
/* for actual <canvas> element */
.tile_item{
  max-width: 100%;
  min-height: 100%;
  aspect-ratio: 1 / 1;
  image-rendering: pixelated;
  border: 1px solid rgba(255,0,0,0.25);
}

.tile_item_selected{
  border: 2px solid rgba(0, 0, 255, 0.75);
}

.metatile_wrapper{

  flex-grow: 1;
  aspect-ratio: 1 / 1;
  width: 10ch;
  /* height: 10ch;  */
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  grid-template-rows: repeat(4, 1fr);
  place-items: stretch;
  grid-gap: 0;
  aspect-ratio: 1 / 1;
  image-rendering: pixelated;
  border: 1px solid rgba(0,255,0,0.5);


}
.metatile_wrapper_viewer{
  width: 25%; /* works ok */
}

.panel_inner_palette{
  grid-template-rows: 3em 1fr;
  grid-template-columns: 1fr;

}
.palette_content{
  /* display: flex; */
  display: grid;
  grid-template-columns: repeat(16, 1fr);
  flex-direction: row;
  flex-wrap: wrap;
  width: 100%;
  /* width: 20em; */
  /* overflow-y: scroll; */
  align-content: stretch;
  place-content: stretch;
  scroll-snap-type: both proximity;
}
.color_item{
  flex-grow: 1;
  aspect-ratio: 1 / 1;
  /* width: 5ch; */
  background-color: rgba(0,0,0,0);

  box-sizing: border-box;
  /* width: 2ch; */
}
/* when we select this palette */
.color_item_selected{
  box-sizing: border-box;
  border-top: dashed 3px rgba(255, 255, 0, 0.75);
  border-bottom: dashed 3px rgba(255, 255, 0, 0.75);
}

.color_label{
  text-shadow: 1px 1px 0px black, -1px -1px 0px black;
  color: rgba(255, 255, 255, 0.75);;
  pointer-events: none;
}


.fileButton{}
.byteWidthButton{}

.seekButtons{
  background-color: rgba(0,0,0,0.5);
}
.seekTileUpButton{}
.seekTileDownButton{}

.hex_header{
    /* background-color: rgb(20, 40, 20); */
    display: grid;
    /* grid-template-columns: 2fr repeat(16, 1fr);
    grid-area: 2 / 1 / 3 / -1; */
    grid-column: 1 / -1;
    /* grid-row: 2 / 3; */
    grid-template-columns: subgrid;

    place-items: center;
    transition: var(--bitplaneViewerTransition);

    /* this adds padding so it lines up with hex_content,
    because windows adds the weird scrollbar */
    overflow:auto;
    scrollbar-gutter: stable;
    place-items: center;

    /* for 1-byte-wide: */
    /* grid-template-columns: 2fr 16fr; */
}
/* labels across the top header:  */
.hex_header_offset{
  display: grid;
  place-items: stretch;
  grid-row: 1 / 2;

}

.hex_content{

    /* background-color: rgba(23, 23, 23, 1); */
    display: grid;
    /* grid-area: 3 / 1 / 4 / 5;

    grid-auto-flow: row;
    grid-template-columns: 18fr 0fr; */
    grid-column: 1 / -1;
    /* grid-row: 3 / 4; */
    grid-template-columns: subgrid;
    /* grid-template-rows: 100%; /*HACK: assumes viewing only 32 bytes */
    /* grid-template-rows: 1fr; */
    /* grid-template-columns: subgrid; */
    scrollbar-gutter: stable;

    /* transition: var(--bitplaneViewerTransition); */

    /* scroll-snap-type: mandatory; */
    scroll-snap-points-y: repeat(100%);
    scroll-snap-type: both proximity;

    overflow-y: auto;
    overflow-x: hidden;

    /* transition: grid-template-rows 1s ease; */
}


.g32_plain{
  display:grid;
  grid-template-columns: 2fr repeat(16, 1fr) 0fr 0fr;
  grid-template-rows: 2em 2em;
  height: 4em;
}

.g32l{
    scroll-snap-align: start;
    /* display: grid; */
    grid-column: 1 / 2;
    grid-row: 1;
    /* grid-template-columns: subgrid;
    grid-auto-flow: row;
    align-items: start;
    justify-items: center; */
  min-width:fit-content;
    position: relative;
}

.g32r{
    scroll-snap-align: start;
    /* display: grid; */
    grid-column: 2 / 3;
    grid-row: 1;
    /* grid-template-columns: subgrid; */
    /* grid-auto-flow: row; */
    /* align-items: start; */
    /* justify-items: center; */
  min-width:fit-content;
    position: relative;
}
.g32_item{
  position:absolute;
  transform-origin: center;
  transform: translate(-50%,-50%);
}
.g32l_offset_sometimes{}
.g32l_offset_sometimes_b16{opacity:0;}
.g32l_offset_sometimes_b1{opacity:1;}

.g32b{
    scroll-snap-align: start;
    /* display: grid; */
    grid-column: 3 / 4;
    grid-row: 1;
    /* grid-template-columns: subgrid; */
    /* grid-auto-flow: row; */
    /* align-items: start; */
    /* justify-items: center; */
    overflow: hidden;
    position: relative;
}

.g32bg{
  display: grid;
  grid-column: 1 / 4;
  grid-row: 1;
  grid-template-columns: 1fr;
  grid-template-rows: repeat(32, 1fr);
  grid-auto-flow: row;
}
.g32bg_row{
  width: 100%;
  height:100%;
}
.g32bg_b16{
  opacity:0;
}
.g32bg_b1{
  opacity:1;
}

/* .g32b{
  display: grid;
  grid-column: 3 / 4;
  grid-template-rows: repeat(32, 1fr);
  grid-template-columns: 1fr;
  grid-template-columns: subgrid;
  overflow: hidden;
  min-height: 0;
  align-items: center;
} */

.g32s{
    grid-column: -1;
    grid-template-columns: subgrid;
    overflow: hidden;
    /* overflow: visible; */
    /* keep this; somehow prevents weird unnecessary scrollbar: */
    /* content-visibility: auto;  */
    /* margin-left: -1ch; */
}
.g32s_b16{
  opacity:0;
}
.g32s_b1{
  opacity:1;
}




.bpsvg{
  height:100%;
  /* width: 100%; */
  overflow: visible;
  /* width: 0; */
}



.byteHex{
  direction: ltr;
  align-items: center;
  text-align: center;
  background-color: rgba(0, 0, 0, 0.25);
  width: 100%;
  height: 100%;
  /* transition: var(--bitplaneViewerTransition2); */
}



.hex_header_labels_left{
  display: grid;
  /* place-items: stretch; */
  grid-row: 1 / 2;
  grid-column: 2 / 3;
  grid-template-columns: repeat(16, 1fr);
  grid-template-rows: 1fr;
  /* place-self: stretch; */
  opacity: 1;
  /* transition: var(--bitplaneViewerTransition2) */
}


.hex_header_labels_right{
  display: grid;
  /* place-items: stretch; */
  grid-row: 1 / 2;
  grid-column: 3 / 4;
  grid-template-columns: 1fr;
  grid-template-rows: 1fr;
  /* place-self: stretch; */
  min-width: 0;
  overflow: hidden;

}
/* .hex_header_labels_right_b16{

  width: 0%;
  opacity: 0;
}
.hex_header_labels_right_b1{

  width: 100%;
  opacity: 1;
} */
/*
.hex_base_labels{
  display: grid;
  place-items: stretch;
  grid-row: 1 / 2;
  grid-column: 2 / 3;
  grid-template-columns:2fr 4fr;
  place-self: stretch;

  opacity: 0;

}
.hex_header_base_label_b16{

  width: 0%;
  opacity: 0;
}
.hex_header_base_label_b1{

  width: 100%;
  opacity: 1;
}
*/
/*

.byteBin{
  direction: ltr;
  opacity: 0;
  align-items: center;
  text-align: right;
  width: 0%;
  overflow: hidden;
}
.byteBin_b16{
  width: 0%;
  opacity: 0;
}
.byteBin_b1{
  width: 100%;
  opacity: 1;
}

*/

/*

classes for bitplane animation
(in order of expanding from 16-wide to 1-wide)

*/

/* 0 */
.g32{
  display: grid;
  grid-column: 1 / -1;
  grid-template-rows: 1fr;

}
.g32_b16{
  grid-template-columns: subgrid;
  /* height: 4em; */
}
.g32_b1{
  grid-template-columns: subgrid;
  height: 100%;
}


/* 1 */
.hex_header_offset_label{
  /* width:0; */
  overflow: hidden;
}
.hex_header_offset_label_b16{
  opacity: 1;
}
.hex_header_offset_label_b1{
  opacity: 0;
}


/* 2 */
.g32r_b16{
  grid-column: 2 / -1;
}
.g32r_b1{
  grid-column: 2 / 3;
}

/* 3 */
.byteOffsetPrefix{
  direction: rtl; /* doing weird stuff so it overflows to the left */
  color: white;
  opacity: 0;
  width: 0;
  /* transition: var(--bitplaneViewerTransition2); */
}
.byteOffsetPrefix_b16{
  opacity: 0;
}
.byteOffsetPrefix_b1{
  opacity: 1;
}


/* 4    and   6  */
/* panel_content goes here */
.panel_content_b16{
  grid-template-rows: 1.5em 1fr; /* this attr is the only one custom to bitplane viewer */
  grid-template-columns: 7ch 16fr 0fr 0fr;
}
.panel_content_intermediate{
  grid-template-rows: 3em 1.5em 1fr; /* this attr is the only one custom to bitplane viewer */
  grid-template-columns: 3fr 1fr 3fr 0fr;
}
.panel_content_b1{
  grid-template-rows: 2em 1fr; /* this attr is the only one custom to bitplane viewer */
  grid-template-columns: 8ch 4ch 11ch 1fr;
}
/* also 4 */
.hex_header_base_label_b16{
  /* width: 0%; */
  opacity: 0;
}
.hex_header_base_label_b1{
  /* width: 100%; */
  opacity: 1;
}
/* also 4 */
.byteBin{
  /* direction: ltr;
  opacity: 0;
  align-items: center;
  text-align: right;
  width: 0%;
  overflow: hidden; */
  min-width: 0;
  min-height: 0;
}
.byteBin_b16{
  opacity: 0;
  width: 0%;
  /* width: 0;
  height: 0;
  overflow: hidden; */
}
.byteBin_b1{
  width: 100%;
  opacity: 1;
}

/* 5 */
.byte{
  grid-area: 2 / 2 / 3 / 3;
  display: grid;


}
.byte_b16{

}
.byte_b1{

}
.byte_by16RowEven{
  background-color: rgba(86, 86, 86, 0.35);
}
.byte_by16RowOdd{
  background-color: rgba(0,0,0,0.35);
}
/* here we would have all 64 .byte_valueXX classes...? */
.fg_bp0{
  --bg: 0;
  --fg: 255;
  /* background-color: rgb(  var(--bg), var(--bg), var(--bg)  ); */
  color: rgb(  var(--fg), var(--fg), var(--fg) );
}
.fg_bp1{
  --bg: 85;
  --fg: 255;
  /* background-color: rgb(  var(--bg), var(--bg), var(--bg)  ); */
  color: rgb(  var(--fg), var(--fg), var(--fg) );
}
.fg_bp2{
  --bg: 170;
  --fg: 0;
  /* background-color: rgb(  var(--bg), var(--bg), var(--bg)  ); */
  color: rgb(  var(--fg), var(--fg), var(--fg) );
}
.fg_bp3{
  --bg: 255;
  --fg: 0;
  /* background-color: rgb(  var(--bg), var(--bg), var(--bg)  ); */
  color: rgb(  var(--fg), var(--fg), var(--fg) );
}
.bg_bp0{
  --bg: 0;
  --fg: 255;
  background-color: rgb(  var(--bg), var(--bg), var(--bg)  );
  color: rgb(  var(--fg), var(--fg), var(--fg) );
}
.bg_bp1{
  --bg: 85;
  --fg: 255;
  background-color: rgb(  var(--bg), var(--bg), var(--bg)  );
  color: rgb(  var(--fg), var(--fg), var(--fg) );
}
.bg_bp2{
  --bg: 170;
  --fg: 0;
  background-color: rgb(  var(--bg), var(--bg), var(--bg)  );
  color: rgb(  var(--fg), var(--fg), var(--fg) );
}
.bg_bp3{
  --bg: 255;
  --fg: 0;
  background-color: rgb(  var(--bg), var(--bg), var(--bg)  );
  color: rgb(  var(--fg), var(--fg), var(--fg) );
}


/*
end of animation classes
 */




.panel_inner_text{
  grid-template-rows: 3em 1fr;
  grid-template-columns: 1fr;
  max-height: 100px;
}
.text_content{
  width: 100%;
  height: 100%;
  /* max-height: 15em; */
  /* height: 20em;  */
  /* overflow-y:scroll; */
  font-family:Arial, Helvetica, sans-serif;
  line-height: 1.5em;
  padding: 1ch;

}
p{
  text-indent: 4ch;
}
ul{
  margin-left: 4ch;
}



/*
Generated ...
*/
.g32rb_item_0_b16{top:25%;left:3.125%;}
.g32rb_item_0_b1{top:1.5625%;left:50%;}
.g32l_item_0_b16{top:25%;left:50%;}
.g32l_item_0_b1{top:1.5625%;left:50%;}
.g32rb_item_1_b16{top:25%;left:9.375%;}
.g32rb_item_1_b1{top:4.6875%;left:50%;}
.g32l_item_1_b16{top:25%;left:50%;}
.g32l_item_1_b1{top:4.6875%;left:50%;}
.g32rb_item_2_b16{top:25%;left:15.625%;}
.g32rb_item_2_b1{top:7.8125%;left:50%;}
.g32l_item_2_b16{top:25%;left:50%;}
.g32l_item_2_b1{top:7.8125%;left:50%;}
.g32rb_item_3_b16{top:25%;left:21.875%;}
.g32rb_item_3_b1{top:10.9375%;left:50%;}
.g32l_item_3_b16{top:25%;left:50%;}
.g32l_item_3_b1{top:10.9375%;left:50%;}
.g32rb_item_4_b16{top:25%;left:28.125%;}
.g32rb_item_4_b1{top:14.0625%;left:50%;}
.g32l_item_4_b16{top:25%;left:50%;}
.g32l_item_4_b1{top:14.0625%;left:50%;}
.g32rb_item_5_b16{top:25%;left:34.375%;}
.g32rb_item_5_b1{top:17.1875%;left:50%;}
.g32l_item_5_b16{top:25%;left:50%;}
.g32l_item_5_b1{top:17.1875%;left:50%;}
.g32rb_item_6_b16{top:25%;left:40.625%;}
.g32rb_item_6_b1{top:20.3125%;left:50%;}
.g32l_item_6_b16{top:25%;left:50%;}
.g32l_item_6_b1{top:20.3125%;left:50%;}
.g32rb_item_7_b16{top:25%;left:46.875%;}
.g32rb_item_7_b1{top:23.4375%;left:50%;}
.g32l_item_7_b16{top:25%;left:50%;}
.g32l_item_7_b1{top:23.4375%;left:50%;}
.g32rb_item_8_b16{top:25%;left:53.125%;}
.g32rb_item_8_b1{top:26.5625%;left:50%;}
.g32l_item_8_b16{top:25%;left:50%;}
.g32l_item_8_b1{top:26.5625%;left:50%;}
.g32rb_item_9_b16{top:25%;left:59.375%;}
.g32rb_item_9_b1{top:29.6875%;left:50%;}
.g32l_item_9_b16{top:25%;left:50%;}
.g32l_item_9_b1{top:29.6875%;left:50%;}
.g32rb_item_10_b16{top:25%;left:65.625%;}
.g32rb_item_10_b1{top:32.8125%;left:50%;}
.g32l_item_10_b16{top:25%;left:50%;}
.g32l_item_10_b1{top:32.8125%;left:50%;}
.g32rb_item_11_b16{top:25%;left:71.875%;}
.g32rb_item_11_b1{top:35.9375%;left:50%;}
.g32l_item_11_b16{top:25%;left:50%;}
.g32l_item_11_b1{top:35.9375%;left:50%;}
.g32rb_item_12_b16{top:25%;left:78.125%;}
.g32rb_item_12_b1{top:39.0625%;left:50%;}
.g32l_item_12_b16{top:25%;left:50%;}
.g32l_item_12_b1{top:39.0625%;left:50%;}
.g32rb_item_13_b16{top:25%;left:84.375%;}
.g32rb_item_13_b1{top:42.1875%;left:50%;}
.g32l_item_13_b16{top:25%;left:50%;}
.g32l_item_13_b1{top:42.1875%;left:50%;}
.g32rb_item_14_b16{top:25%;left:90.625%;}
.g32rb_item_14_b1{top:45.3125%;left:50%;}
.g32l_item_14_b16{top:25%;left:50%;}
.g32l_item_14_b1{top:45.3125%;left:50%;}
.g32rb_item_15_b16{top:25%;left:96.875%;}
.g32rb_item_15_b1{top:48.4375%;left:50%;}
.g32l_item_15_b16{top:25%;left:50%;}
.g32l_item_15_b1{top:48.4375%;left:50%;}
.g32rb_item_16_b16{top:75%;left:3.125%;}
.g32rb_item_16_b1{top:51.5625%;left:50%;}
.g32l_item_16_b16{top:75%;left:50%;}
.g32l_item_16_b1{top:51.5625%;left:50%;}
.g32rb_item_17_b16{top:75%;left:9.375%;}
.g32rb_item_17_b1{top:54.6875%;left:50%;}
.g32l_item_17_b16{top:75%;left:50%;}
.g32l_item_17_b1{top:54.6875%;left:50%;}
.g32rb_item_18_b16{top:75%;left:15.625%;}
.g32rb_item_18_b1{top:57.8125%;left:50%;}
.g32l_item_18_b16{top:75%;left:50%;}
.g32l_item_18_b1{top:57.8125%;left:50%;}
.g32rb_item_19_b16{top:75%;left:21.875%;}
.g32rb_item_19_b1{top:60.9375%;left:50%;}
.g32l_item_19_b16{top:75%;left:50%;}
.g32l_item_19_b1{top:60.9375%;left:50%;}
.g32rb_item_20_b16{top:75%;left:28.125%;}
.g32rb_item_20_b1{top:64.0625%;left:50%;}
.g32l_item_20_b16{top:75%;left:50%;}
.g32l_item_20_b1{top:64.0625%;left:50%;}
.g32rb_item_21_b16{top:75%;left:34.375%;}
.g32rb_item_21_b1{top:67.1875%;left:50%;}
.g32l_item_21_b16{top:75%;left:50%;}
.g32l_item_21_b1{top:67.1875%;left:50%;}
.g32rb_item_22_b16{top:75%;left:40.625%;}
.g32rb_item_22_b1{top:70.3125%;left:50%;}
.g32l_item_22_b16{top:75%;left:50%;}
.g32l_item_22_b1{top:70.3125%;left:50%;}
.g32rb_item_23_b16{top:75%;left:46.875%;}
.g32rb_item_23_b1{top:73.4375%;left:50%;}
.g32l_item_23_b16{top:75%;left:50%;}
.g32l_item_23_b1{top:73.4375%;left:50%;}
.g32rb_item_24_b16{top:75%;left:53.125%;}
.g32rb_item_24_b1{top:76.5625%;left:50%;}
.g32l_item_24_b16{top:75%;left:50%;}
.g32l_item_24_b1{top:76.5625%;left:50%;}
.g32rb_item_25_b16{top:75%;left:59.375%;}
.g32rb_item_25_b1{top:79.6875%;left:50%;}
.g32l_item_25_b16{top:75%;left:50%;}
.g32l_item_25_b1{top:79.6875%;left:50%;}
.g32rb_item_26_b16{top:75%;left:65.625%;}
.g32rb_item_26_b1{top:82.8125%;left:50%;}
.g32l_item_26_b16{top:75%;left:50%;}
.g32l_item_26_b1{top:82.8125%;left:50%;}
.g32rb_item_27_b16{top:75%;left:71.875%;}
.g32rb_item_27_b1{top:85.9375%;left:50%;}
.g32l_item_27_b16{top:75%;left:50%;}
.g32l_item_27_b1{top:85.9375%;left:50%;}
.g32rb_item_28_b16{top:75%;left:78.125%;}
.g32rb_item_28_b1{top:89.0625%;left:50%;}
.g32l_item_28_b16{top:75%;left:50%;}
.g32l_item_28_b1{top:89.0625%;left:50%;}
.g32rb_item_29_b16{top:75%;left:84.375%;}
.g32rb_item_29_b1{top:92.1875%;left:50%;}
.g32l_item_29_b16{top:75%;left:50%;}
.g32l_item_29_b1{top:92.1875%;left:50%;}
.g32rb_item_30_b16{top:75%;left:90.625%;}
.g32rb_item_30_b1{top:95.3125%;left:50%;}
.g32l_item_30_b16{top:75%;left:50%;}
.g32l_item_30_b1{top:95.3125%;left:50%;}
.g32rb_item_31_b16{top:75%;left:96.875%;}
.g32rb_item_31_b1{top:98.4375%;left:50%;}
.g32l_item_31_b16{top:75%;left:50%;}
.g32l_item_31_b1{top:98.4375%;left:50%;}


/* NEW simplified hex viewer classes */
.hex_panel_content{
  grid-template-rows: 1.5em 1fr;
  grid-template-columns: 2fr repeat(16, 1fr) 0fr;
}
.hex_panel_content_32wide{
  grid-template-columns: 2fr repeat(16, 1fr) 0fr repeat(16, 1fr) 0fr;
}
.hex_header_new{
  display: grid;
  grid-template-columns: subgrid;
  /* grid-template-rows: subgrid;   */
  grid-column: 1 / -1;
  font-weight: 900;

}
.hex_new_top_labels{
  display: grid;
  grid-template-columns: subgrid;
  grid-template-rows: subgrid;
  grid-template-rows: 100%;
  grid-column: 2 / -2;
  overflow: hidden;
  user-select: none;

}
.hex_g4096{
  display: grid;
  grid-template-columns: subgrid;
  grid-column: 1 / -1;
  height: max-content;
}
.hex_g256{
  display: grid;
  grid-template-columns: subgrid;
  grid-column: 1 / -1;
  height: 512em;
  /* This doesn't work very well, makes columns weird */
  /* content-visibility: auto; */

  height: max-content;
}
.hex_g32{
  display: grid;
  grid-template-columns: subgrid;
  grid-column: 1 / -1;

  height: max-content;
}
.hex_g32l{
  display: grid;
  grid-template-columns: 1fr;
  grid-column: 1;
}
.hex_g32lr{
  display: grid;
  grid-template-columns: subgrid;
  grid-column: 1 / -2;
}

.hex_g32r{
  display: grid;
  grid-template-columns: subgrid;
  grid-column: 2 / -2;
}
.hex_cell{
  /* place-self: center;   */
  /* height: 2em; */
  align-content: center;
  text-align: center;

}
.hex_byte{
  /* place-self: center;
  height: 2em;
  align-content: center; */
}
.new_offset{
  min-width: 0;
  user-select: none;
}
.new_offet_middle{
  width: 100%;
  overflow: hidden;
}


.decomp_animation_details{
  display: grid;
  grid-template-rows: 1fr;
  position: absolute;
  place-items:center;
  place-content: center;
  border-radius: 2ch;
  transform-origin: right;
  right: 100%;
  z-index: 100;
  white-space: nowrap;
  /* border: 2px solid white; */
}

.decomp_animation_details_item{
  /* min-width: 0;
  min-height: 0; */
  overflow: hidden;
  height: 100%;
  width: 100%;
  text-align: center;
  align-content: center;
  /* box-sizing: border-box; */
  /* font-family: Arial, serif; */
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  /* justify-content: stretch; */
}
.notBubble{
  /* padding-left:1ch;
  padding-right:1ch; */
  text-align: center;
  height: 100%;
  align-content: center;
}
.bubbleCell{
  border-radius: 2ch;
  border: 2px solid;
  /* padding-left:1ch;
  padding-right:1ch; */
  text-align: center;
  height: 100%;
  align-content: center;
  box-sizing: border-box;
}
.bubbleCellOne{
  border-radius: 2ch;
  border: 2px solid;
  width: 100%;
  height: 100%;
  text-align: center;
  align-content: center;
  box-sizing: border-box;
}
@keyframes bulge{
  0%{
    font-size: 100%;
  }
  25%{
    font-size: 240%;
  }
  66%{
    font-size: 90%;

  }
  100%{
    font-size:100%;
  }
}

</style>
<script>

/*
*/

//------------------------------------------------------------------------------
//
//      "3D" SVG stuff (mostly from another project)
//
// Has some features that aren't used much...


// Shorthand
let cos = Math.cos, sin = Math.sin, round = Math.round;


//HACK probably a better method
function hex(integer, chars=2){
    var s = Number(integer).toString(16);
    let caps = {
        'a':'A',
        'b':'B',
        'c':'C',
        'd':'D',
        'e':'E',
        'f':'F'
    }
    while (s.length < chars){
        s = "0"+s;
    }
    return s.replace(/[abcdef]/g, m => caps[m]);
}
//binar(0x8fff,16)
function binar(integer,bit=8,sp=0){
    // assumes 8-bits
    // if space is specified, will add a narrow non-breaking space
    // every sp characters, and a space before and after the string.
    let str = "";
    let b1 = bit-1;
    let mask = 1 << b1;
    for (let i=0; i<bit; i++){
        str+= `${ (integer  & (mask >> i)) >> (b1-i)}`;
        if (sp) if ( (i+1)%sp==0) str+= "&#8239;";
        // if (sp) if ( (i+1)%sp==0) str+= " ";
    }
    return `${sp!=0?"&#8239;":""}${str}`;
    // return `${sp!=0?" ":""}${str}`;
}
// version specifically for html titles, and other non-html character sets (?)
function binart(integer,bit=8,sp=0){
    // assumes 8-bits
    // if space is specified, will add a narrow non-breaking space
    // every sp characters, and a space before and after the string.
    let str = "";
    let b1 = bit-1;
    let mask = 1 << b1;
    for (let i=0; i<bit; i++){
        str+= `${ (integer  & (mask >> i)) >> (b1-i)}`;
        // if (sp) if ( (i+1)%sp==0) str+= "&#8239;";
        if (sp) if ( (i+1)%sp==0) str+= " ";
    }
    // return `${sp!=0?"&#8239;":""}${str}`;
    return `${sp!=0?" ":""}${str}`;
}
// This generates a 2D array pre-filled with zeros. Much like np.zeros() in python.
// Probably pretty efficient...?
function zeros(m,n){
  return [...Array(m)].map( d => Array(n).fill(0));
}


//
class State {

  constructor(details,kind) {


    Object.assign(this, details);

    if (kind == null){
      kind = 'pixels';
    }
    this.kind = kind;
    //HACK: must be a better way of doing this, with .assign?
    switch (kind){
      case 'pixels':
        this.pixels = details; // y, x, channel; 3D array of pixel values
        this.xStartCentered = -sqs*this.pixels[0].length/2;
        this.yStartCentered = -sqs*this.pixels.length/2;
        this.width = sqs*this.pixels[0].length;
        this.height = sqs*this.pixels.length;
        break;
      case 'path':
        this.pathPoints = details.pathPoints;
        this.fill = details.fill;
        this.stroke = details.stroke;
        break;
      case 'pathCurve':
        this.pathPoints = details.pathPoints;
        this.pathPointsExtra = details.pathPointsExtra;
        this.fixedPoints = details.fixedPoints;
        this.fill = details.fill;
        this.stroke = details.stroke;
        break;

    }


  }
}

class Sprite {
  constructor(states, x, y, width, height, untethered, animation) {
    if (untethered==null){
      this.untethered = false;
    } else {
      this.untethered = untethered;
    }
    if (animation==null){
      this.animation = false;
    } else {
      this.animation = animation;
    }
  	this.states = states;
    this.kind = states[0].kind;
    this.x = x;
    this.y = y;
    this.height = height;
    this.width = width;
    this.state = states[0];
  }

}


function moveToendOfSVG(el){
  let parent = el.ownerSVGElement; //without this, weird DOM issues??
  parent.appendChild( el );
}


// View object
class View {
  constructor({name, parent, /*name to append to svg id; parent html node*/
    angleh, anglev, anglehs, anglevs, observation, distance,/*render settings*/
    squaresize, scale,/*sizing settings*/
    sprites, viewBox, className /* sprites, each containing states, containing a pixel array*/}) {
      // console.log(sprites);
  	Object.assign(this, {name, parent, /*name to append to svg id; parent html node*/
      angleh, anglev, anglehs, anglevs, observation, distance,/*render settings*/
      squaresize, scale,/*sizing settings*/
      sprites, viewBox, className /* sprites, each containing states, containing a pixel array*/});


    if (!parent){
      console.log("Error: View() constructor received a null parent node.");

    }
    // to be populaed and used later:
    this.elemsObj = []; // objects for each element to be remdered
    this.elemsSVG = []; // the SVG string for each
    this.groups = {};
    this.oldOrder = '';
    this.newOrder = '';

    this.width = null;
    this.height = null;
    this.index = null;
    this.point = null;
    this.rgba = {};

    // center x and y
    // x is slightly offset
    this.x3dfactor = 0.6;
    this.y3dfactor = 0.6;

    this.x3d = this.viewBox[2] * this.x3dfactor;
    this.y3d = this.viewBox[3] * this.y3dfactor;

    // which wawy the scene is facing
    this.up = false;
    this.right = false;

    // generate the points based on each sprite's initial state,
    // and assign all the things that will be attributes of the svg element, to .state
    //NOTE: a bit confusing: there is at least 1 state for each "sprite". There is also a
    // "state" used by each element that reflects the current state to be rendered.
    for (var spri = 0; spri < this.sprites.length; spri+=1){
      let sp = this.sprites[spri];
      // console.log(sp.state.pathPoints);
      // console.log(sp.state.dmake(sp.state.pathPoints));
      this.groups[sp.state.group] = {
        name: sp.state.group,
        tags:[`<g id="elements_${this.name}_group_${sp.state.group}" index="${sp.state.group[sp.state.group.length-1]}">`,`</g>`],
        elems: [],
        dist: 0,
        index: 0
      };

    	this.elemsObj.push({
          ...sp.state,
          r: 1,
          untethered: this.sprites[spri].untethered,
          animation: this.sprites[spri].animation,
          kind: sp.kind,
          state: {
            fill: sp.state.fill=="none"?"none":`rgb(${sp.state.fill.join(", ")})`,
            'fill-opacity': sp.state['fill-opacity']=="none"?"none":sp.state['fill-opacity'],
            stroke: sp.state.stroke=="none"?"none":`rgb(${sp.state.stroke.join(", ")})`,
            'stroke-opacity': sp.state['stroke-opacity']=="none"?"none":sp.state['stroke-opacity'],
            d: sp.state.dmake(sp.state.pathPoints),
            'stroke-width': sp.state['stroke-width']?sp.state['stroke-width']:1,
          },
        });

    }

    // Assign the actual SVG:
    parent.innerHTML = `<svg id="svg_${this.name}"
                          class="${this.className}"
                            viewBox="${this.viewBox.join(" ")}"
                            preserveAspectRatio="none" >
                            <g id="elements_${this.name}"></g>
                          </svg>`;
    this.svg = document.getElementById(`svg_${this.name}`);
    console.log(`elements_${this.name}`);
    this.svgGroup = document.getElementById(`elements_${this.name}`);

    // Now make SVG strings for each element:
    this.elemsSVG = this.elemsObj.map( (d,i) => `\
      <${d.kind} class="${(d.untethered?'untethered':'tethered')} ${d.classes?d.classes.join(" "):""}"
        stroke-linecap="round"
        stroke-linejoin="round"
        ></${d.kind}>`);
        // index="${this.elemsSVG.length+i}" ></${d.kind}>`);

    // assign to groups
    this.elemsSVG.forEach((d,i) => this.groups[this.elemsObj[i].group].elems.push( d ) );

    // now join all groups together:
    this.svgGroup.innerHTML = ``;
    for (let prop in this.groups) {
      this.svgGroup.innerHTML+=`${this.groups[prop].tags.join(
        this.groups[prop].elems.join('')
      )}`;
    }
    // this.svgGroup.innerHTML = this.elemsSVG.join('');


    this.allNodes = this.svgGroup.querySelectorAll('g > path, g > rect, g > text');

    // store start time, for animation
    this.startTime = Date.now();


    // Setup and event listeners
    //
    // wrapper
    let eventwrap = (t, f) => this.svg.addEventListener(t, e => this.renderRects( f(e) ));

    // User actions
    // for clicking and dragging to rotate:
    eventwrap('click', evt => {
      evt.preventDefault();
      evt.stopPropagation();
      this.index = this.elemsObj[evt.target.getAttribute('index')]
    });
    // clear the point that was clicked on mousup
    eventwrap('mouseup', evt => this.point = null);
    // Get the point clicked
    eventwrap('mousedown', evt => this.point = { x: evt.x,
                                              y: evt.y,
                                              angleh: this.angleh,
                                              anglev: this.anglev});
    // if not null, move to new vertical and horizontal anlges while simultaneously
    // updating the stored horizontal and vertical angle values
    eventwrap('mousemove', evt => {
      evt.preventDefault();
      evt.stopPropagation();
      this.point && (this.angleh = this.point.angleh+(evt.x - this.point.x)/this.anglehs) + (this.anglev = this.point.anglev-(evt.y - this.point.y)/this.anglevs);
      // console.log("svg View mouse move");
    });

    // for scrolling to zoom:
    eventwrap('wheel', evt => {
      if (evt.ctrlKey) {
        // let hexContent = this.svg.parentNode.parentNode;
        // hexContent.style.overflow = "hidden";
        evt.preventDefault();
        evt.stopPropagation();
        this.observation *= 1-Math.sign(evt.deltaY)*0.015;

        // hexContent.style.overflow = "scroll";
      }
    });

    // resizing the parent element.
    //TODO: make more performant. There's currently a sort of debounce,
    // but there should just be an alternative to this.renderREcts()
    //  that just moves the current positions instead of re-rendering 3d
    this.debounceResize = false;
    this.resizeObs = new ResizeObserver(
      evt => {
        if (!this.debounceResize){
          this.renderRects();
          // console.log("svg View parentNode resized: just rendered.");
          this.debounceResize = true;
          setTimeout( () => {this.debounceResize = false;}, 200)
        }
      }
    ).observe(this.svg.parentNode);



    // Also set a timeout, so we can have animatinos play:
    // (not used here yet)
    // this.timeout = setInterval(() => this.renderRects(), 1000/30);

    // initial render
    this.renderRects();

  }

  project(el){
    // console.log('Here is where we would project a path');
    let pp = [];
    let rrr = Infinity; //
    let zd = 0;
    let count = 0;
    let distSum = 0;
    // console.log("el.pathPoints:");
    // console.log(el.pathPoints);
    for (let i=0; i < el.pathPoints.length; i++){

      let pt = el.pathPoints[i];
      // console.log( el.pathPoints[i]);
      // Indexing past the array length, as in for extras, should still work:
      if (!el.fixedPoints[i]){
        // console.log("not fixed");
        // console.log(pt);
        // Note the x, y, and z are set up such that z is up,
        // because we assume paths are expected to be more conventional 3D
        let ptx = pt[0];
        let pty = -pt[2];
        let ptz = pt[1];
        let x = ptx*cos(-this.angleh) + ptz*sin(-this.angleh);
        let z = ptz*cos(-this.angleh) - ptx*sin(-this.angleh);
        let y = pty*cos(this.anglev) + z*sin(this.anglev);
        let dist = z*cos(this.anglev) - pty*sin(this.anglev) + this.distance;
        distSum+=dist;
        // let x = pt[0]*cos(this.angleh) + pt[2]*sin(this.angleh);
        // let z = pt[1]*cos(this.angleh) + pt[0]*sin(this.angleh);
        // let y = -pt[2]*cos(this.anglev) + z*sin(this.anglev);
        // let dist = z*cos(this.anglev) + pt[2]*sin(this.anglev) + this.distance;
        // console.log(`(this.observation/dist)*x + this.width: ${[this.observation,dist,x,this.width]}`);
        // pp.push( [(this.observation/dist)*x + this.width/2,
        //                   (this.observation/dist)*y + this.height/2] );
        // pp.push( [(this.observation/dist)*x + this.viewBox[2]/2,
        //                   (this.observation/dist)*y + this.viewBox[3]/2]  );
        // pp.push( [ (this.observation/dist)*x + this.x3d,
        //            (this.observation/dist)*y + this.y3d ]  ); // perspective
        pp.push( [ (this.observation*x) + this.x3d,
                   (this.observation*y) + this.y3d ]  ); // ortho/no perspective

        // Here's where we'd resize the rect element based on z-distance,
        // or radius if using circles
        rrr = Math.min(rrr, this.distance/dist*el.r);
        count++;
      }
      else{
        // console.log("fixed");
        pp.push( [pt[0], pt[1]] ); // or should it be pt[2]. ..?
      }
    }
    // console.log(`rr:4${rr}`);

    // Form the path string from the coordinates we just updated
    // console.log('path pts in project:');
    // console.log(pathPts);

    // can move this to a function/method of this object/elements?
    // console.log(pp);
    el.state.d = el.dmake(pp, this.right, this.up );
    el.state.r = rrr;
    this.groups[el.group].dist+= distSum/count;

    // console.log(px);
    // console.log(`px.state.x, px.state.y, px.state.z,dist,r: ${[px.state.x,px.state.y,px.state.z,dist,px.state.r]}`);

  }

  renderRects(){

    // this.pixels.forEach( (d) => this.project(d));
    // this.pixels.sort( (a,b) => a.state.r - b.state.r );
    // // unpack attributes
    // this.pixels.forEach( (d, i) => Object.entries(d.state)
    //   .forEach(e => this.rectNodes[i].setAttribute(...e)));

    // to help center:

    const bbox = this.svg.getBoundingClientRect();
    //HACK: exit the render if there is a null parent node
    if (!this.svg.parentNode) return 1;
    const pbox = this.svg.parentNode.getBoundingClientRect();
    // const xsc = bbox.height/(bbox.width);
    // console.log(this.svg.parentNode);
    // console.log(pbox);
    // console.log(this.svg);
    // console.log(bbox);
    if (pbox.width > 0){
      this.x3d = this.svg.viewBox.animVal.width *this.x3dfactor * pbox.width/bbox.width;
    }

    // Determine which way the 3d scene is facing based on rotation:
    // this.up = Math.floor( (this.anglev+Math.PI) / Math.PI ) % 2
    // works for positive but not negative:
    // this.up = Math.floor( Math.abs( (this.anglev+Math.PI)/Math.PI))%2;
    // this.right = Math.floor( Math.abs( (this.angleh+Math.PI)/Math.PI))%2;

    // probably a more efficient way...
    let au = (this.anglev+Math.PI)%(Math.PI*2);
    this.up = ( au < 0 ? au+(Math.PI*2) : au ) >= Math.PI;
    let ar = (this.angleh+Math.PI)%(Math.PI*2);
    this.right = ( ar < 0 ? ar+(Math.PI*2) : ar ) >= Math.PI;


    // console.log( `up ${this.up}   right ${this.right}     h ${this.angleh} rad, v ${this.anglev} rad` );



    // console.log(this.x3d);

    // let hyphenate = {
    //   fillOpacity: "fill-opacity",
    //   strokeOpacity: "stroke-opacity"
    // }
    // this.allElements



    for (let g in this.groups) this.groups[g].dist = 0; // Clear the values in group's distance

    // project
    // this.elemsObj.forEach( (d) => this.project(d));

    // average groups' new dist values
    // for (let g in this.groups){
    //   this.groups[g].dist/= this.groups[g].elems.length;
    // }


    this.elemsObj.forEach( (d) => this.project(d));

    for (let g in this.groups) this.groups[g].dist/= this.groups[g].elems.length; // average group's new dist values



    // Sort the groups (descending, because further back will be higher, we "paint" that first)
    // this.elemsObj.sort( (a,b) => a.state.r - b.state.r );
    //TODO: maybe only sort if we enter a new octant, based on this.up and this.right changing?
    this.groupsArray = Object.entries( this.groups ).sort( (entryA,entryB) => entryA[1].dist - entryB[1].dist ).reverse().map( d => d[1] );


    // this.newOrder = this.groupsArray.map( d => `${d.name}[${Math.round(d.dist)}]`).join(' -> ');
    this.newOrder = this.groupsArray.map( d => `${d.name}`).join(' -> ');
    let orderChange = this.newOrder+'' != this.oldOrder+'';
    if (orderChange) console.log( this.newOrder );
    this.oldOrder = this.newOrder+'';
    // console.log(this.groupsArray);



    // this.elemsObj.sort( (a,b) => a.state.r - b.state.r );

    // unpack attributes
    //HACK: uses dictionary to replace certain keys with a hyphenated version,
    // probably a more efficient method to do this...
    // this.elemsObj.forEach( (d, i) => Object.entries(d.state)
    //   .forEach(e => this.allNodes[i].setAttribute(
    //     hyphenate[e[0]] ? hyphenate[e[0]] : e[0], e[1] )
    //   )
    // );
    if (orderChange) {
      for (let i=0; i < this.groupsArray.length; i++){
        let key = this.groupsArray[i].name;

        this.elemsObj.forEach(
          (d, i) => {
            if (d.group==key) {
              moveToendOfSVG(this.allNodes[i]);
              Object.entries(d.state).forEach( e => this.allNodes[i].setAttribute( e[0], e[1] ) );
            }
          }
        );
      }
    }
    else{
      this.elemsObj.forEach(
          (d, i) => Object.entries(d.state).forEach( e => this.allNodes[i].setAttribute( e[0], e[1] ) )
        );
    }


  }

  newFrame(){
    // This will move to the next frame (pixels of the next state for a sprite)
    return 0
  }

}


function makeBitplaneSVG(parent, name, dat, angleh=0, anglev=0, observation=1, palette=null){

  //NOTE: this uses format "bitplane 0" as first bp index... not bp 1.

  if (!parent) {
    // console.log("Error: parent element passed to makeBitplaneSVG() is null.");
    return null;
  }

  let curvs = [];
  // console.log(dat);
  // console.log(parent);
  if (!dat){
    dat = Array.from(Array(32)).map(d=> Math.round(Math.random()*255));
  }

  // console.log("received palette...");
  // console.log(palette);

  // console.log("Generating svg with palette...");
  // console.log(pal);
  // A lot of variables... maybe too much, but should simplify later...
  // byte column / 2d svg fixed coordinates

  // let bprgbfg = [
  //   [127,127,127],
  //   [255,255,255],
  //   [127,127,127],
  //   [0,0,0]
  // ]; // colors for stroke of each bitplane
  // let bprgbbg = [
  //   [0,0,0],
  //   [127,127,127],
  //   [255,255,255],
  //   [127,127,127]
  // ]; // background

  // let bprgbfg = [
  //   [127,127,127],
  //   [212,212,212],
  //   [42,42,42],
  //   [127,127,127]
  // ]; // colors for stroke of each bitplane
  let bprgbfg = [
    [255,255,255],
    [255,255,255],
    [0,0,0],
    [0,0,0]
  ]; // colors for stroke of each bitplane
  let bprgbbg = [
    [0,0,0],
    [85,85,85],
    [170,170,170],
    [255,255,255]
  ]; // background

  // (also used by indices square):
  var textDefaults = {
    fill: "none",
    'fill-opacity': 0,
    stroke: [255, 255, 255],
    'stroke-opacity': 0.95,
    'stroke-width': 1,
  };
  var solidsDefaults = {
    'fill-opacity': 1,
    'stroke-opacity': 0.0,
    'stroke-width': 2,
  };
  // arrows:
  var outlinesDefaults = {
    fill: "none",
    'fill-opacity': "0",
    'stroke-opacity': 0.95,
    'stroke-width': 1,
  }


  let height = 1000;
  let bscx = 80;
  let bscy = height/32;


  // weird 3d coordinates:
  // let scx = 50/2;
  // let scy = 50/2;
  let scx = 25;
  let scy = 25;
  let scz = 120;
  // let bpcx = 10*scx;
  let bpcx = 0; //default 0?
  // let bpcy = 16*scy;
  let bpcy = 0;
  let bps = scy*16; // bitplane side
  let bpc = bps/8; // bitplane cell length
  let bpch = bps/16; // bitplane cell length half
  let bpcq = bps/32; // bitplane cell length quarter

  let bpl = bpcx-(bps/2); // bitplane left edge
  let bpll = bpl-(6*scx); // slightly left of bitplane left edge
  let arrowHandle = bpl - (5*bpc);
  let arrowHead = bpl - (0.45*bpc);
  let arrowTip = bpl - (0.2*bpc);


  // let bpd = 1.5*scz; // pb 0 depth
  let bpd = 1.5*bpc*8; // pb 0 depth
  let indexplane = -1.5; // remember bp 0 will be 0, bp 1 will be 1, etc
  scz = bpc*8;
  let bpt = bpcy-(bps/2); // bitplane top edge
  let bptph = -(bpt + bpch); // top plus half a cell length

  let bpnz = bpd/100; // bit plane numbers z depth (offset from their plane)

  // text height, width, x and y offsets
  // let txthsc = 0.5;
  // let txtwsc = 0.25;
  let txthsc = 1;
  let txtwsc = 1;
  let txthu = txthsc *bpc; // not pre-scaled
  let txtwu = txtwsc *bpc;
  let txth = txthsc *bpc/8; // pre-scaled by 8 so it can be multiplied by numsvg
  let txtw = txtwsc *bpc/8;
  let txty = ( bpc - (bpc * txthsc) )/2;
  let txtx = ( bpc - (bpc * txtwsc) )/2;


  let bpr = [0,0,0,0]; // bitplane rows completed


  // setup for data
  var numsvg = {
    "0":[ [3,1],  [5,1],  [6,2],  [6,6],  [5,7],  [3,7],  [2,6], [2,2], [3,1]  ],
    "1":[ [3,2],  [4,1],  [4,7],  [5,7],  [3,7] ],
    "2":[ [2,2], [3,1], [5,1], [6,2], [2,7], [6,7] ],
    "3":[ [2,2], [3,1], [5,1], [6,2], [6,3], [5,4], [3,4], [5,4], [6,5], [6,6], [5,7], [3,7], [2,6] ],
    "4":[ [6,5], [2,5], [5,1], [5,7]],
    "5":[ [6,1], [2,1], [2,4], [3,3], [5,3], [6,4], [6,6], [5,7], [3,7], [2,6] ],
    "6":[ [5,1], [3,1], [2,2], [2,6], [3,7], [5,7], [6,6], [6,4], [5,3], [3,3], [2,4] ],
    "7":[ [2,1], [6,1], [5,2], [3,7] ],
    "8": [ [5,4], [3,4], [2,3], [2,2], [3,1], [5,1], [6,2], [6,3], [5,4], [6,5], [6,6], [5,7], [3,7], [2,6], [2,5], [3,4] ],
    "9": [ [6,4], [3,4], [2,3], [2,2], [3,1], [5,1], [6,2], [6,4], [3,7] ],
    "10": [ [2,7], [2.5,5.5], [5.5,5.5], [2.5,5.5], [4,1], [6,7] ],
    // "11": [ [5,4], [2,4], [2,1], [5,1], [6,2], [6,3], [5,4], [6,5], [6,7], [2,7], [2,4] ],
    "11": [ [2,1], [5,1], [6,1.5], [6,2.5], [5,3], [2.5,3], [5,3], [6,4], [6,6], [5,7], [2,7], [2.5,7], [2.5,1] ],
    "12": [ [6,6],  [5,7],  [3,7],  [2,6], [2,2], [3,1],  [5,1],  [6,2]  ],
    "13": [ [2,1],  [5,1],  [6,2],  [6,6],  [5,7],  [2,7], [2.5,7], [2.5,1]   ],
    "14": [ [6,1], [2,1], [2,4], [5,4], [2,4], [2,7], [6,7] ],
    "15": [ [6,1], [2,1], [2,4], [5,4], [2,4], [2,7] ],

  }
  // convert values to strings:
  // data = data.map(
  //   d =>  Array.from(Array(8).keys()).reduce(
  //       (accum, val, i) => accum+= `${ (d  & (0b10000000 >> i)) >> (7-i)}`, ``)
  //   );
  var data = [];
  // console.log(dat);
  for (let i=0; i<dat.length; i++){
    data.push( binar( dat[i] ) );
    // console.log( [i, binar( dat[i] )] );
  }

  while(data.length<32) data.push( '00000000' ); // zero fill if needed
  // dat.forEach( d => data.push( binar( d ) ) );

  let tile = zeros(8,8);

  // console.log(data);

  let dataPaths = [];

  for (let i=0; i<32; i++){

    let bp = ((i>15)*2) + i%2;
    // console.log(`Y 2D coord: ${(i+0.5)*bscy}`);
    // cast from string to number, shift left the appropriate amount, or this to the value
    for (let j=0; j<8; j++) tile[bpr[bp]][j] |= (1*data[i][j]) << bp;

    // ARROWS
    //
    // Add the arrows going from left side of SVG to left side of each bitplane
    // note that y and z are swapped weirdly...
    // BG ARROW
    curvs.push(
      new Sprite([
      new State(
        {
          pathPoints: [
            [0, (i+0.5)*bscy, 0],
            [bscx, (i+0.5)*bscy, 0],
            [arrowHandle, bpd-(bp*scz), bptph-(bpr[bp]*bpc)],
            [arrowTip, bpd-(bp*scz), bptph-(bpr[bp]*bpc)],

            [arrowHead, bpd-(bp*scz), bptph-(bpr[bp]*bpc)-bpcq],
            [arrowTip, bpd-(bp*scz), bptph-(bpr[bp]*bpc)],
            [arrowHead, bpd-(bp*scz), bptph-(bpr[bp]*bpc)+bpcq]
          ],
          fixedPoints: [true, true, false, false],
          ...outlinesDefaults,
          stroke: bprgbbg[bp],
          'stroke-width': 5,
          group: `bp${bp}`,
          dmake(p){
            return `M ${p[0].join(" ")} \
                    C ${p.slice(1,4).map(e => e.join(" ")).join(", ")} \
                    L ${p.slice(4).map(e => e.join(" ") ).join(" L ")}`;
          }
        },
        'path')
      ], 0,0,0,0)
    );
    // FG ARROW
    // (removed: too busy-looking)
    // curvs.push(
    //   new Sprite([
    //   new State(
    //     {
    //       pathPoints: [
    //         [0, ((i+0.5)*bscy) - bpnz, 0],
    //         [bscx, ((i+0.5)*bscy) - bpnz, 0],
    //         [arrowHandle, bpd - (bp*scz) - bpnz, bptph-(bpr[bp]*bpc)],
    //         [arrowTip, bpd - (bp*scz) - bpnz, bptph-(bpr[bp]*bpc)],

    //         [arrowHead, bpd - (bp*scz) - bpnz, bptph-(bpr[bp]*bpc)-bpcq],
    //         [arrowTip, bpd - (bp*scz) - bpnz, bptph-(bpr[bp]*bpc)],
    //         [arrowHead, bpd - (bp*scz) - bpnz, bptph-(bpr[bp]*bpc)+bpcq]
    //       ],
    //       fixedPoints: [true, true, false, false],
    //       ...outlinesDefaults,
    //       stroke: bprgbfg[bp],
    //       'stroke-width': 2,
    //       group: `bp${bp}`,
    //       dmake(p){
    //         return `M ${p[0].join(" ")} \
    //                 C ${p.slice(1,4).map(e => e.join(" ")).join(", ")} \
    //                 L ${p.slice(4).map(e => e.join(" ") ).join(" L ")}`;
    //       }
    //     },
    //     'path')
    //   ], 0,0,0,0)
    // );

    // 1S AND 0S
    //
    // Now do the data: numeric characters
    // (working "up" from the "next" row since we already incremented bpr[bp])
    for (let j=0; j<8; j++){
      // console.log( data[i][j]);
      dataPaths.push(
      new Sprite([
        new State(
          {
            pathPoints: numsvg[data[i][j]].map(
              (d,ii) => [
                bpl + (bpc*j) + (d[0]*txtw) + txtx,
                bpd-(bp*scz)-bpnz,
                -bpt - (bpc*bpr[bp]) - (d[1]*txth) - txty
              ] ),
            fixedPoints: [],
            ...textDefaults,
            stroke: bprgbfg[bp],
            group: `bp${bp}`,
            dmake(p){
              return `M${(p.map(e => e[0]+','+e[1])).join(" L")}`;
            }
          },
          'path')
        ], 0,0,0,0)

    )
    }


    bpr[bp]++; // increment to next row


  }

  // setup for pixel bubbles/boxes
  //
  // txthu
  // txtwu
  // txty
  // txtx
  let txthscbox = txthsc * 1.5;
  let txtwscbox = txtwsc * 1.5;
  let txthbox = txthscbox *bpc; // not pre-scaled
  let txtwbox = txtwscbox *bpc;
  let txtybox = ( bpc - (bpc * txthscbox) )/2;
  let txtxbox = ( bpc - (bpc * txtwscbox) )/2;
  // var cornersFront = [ [0,0], [0,1], [1,1], [1,0] ];
  // var cornersBack = [ [1,1], [1,0], [0,0], [0,1] ];
  var cornersFront = [ [0,0], [0,0.5], [0,1], [0.5,1], [1,1], [1,0.5], [1,0], [0.5,0] ];
  var cornersBack = [ [1,1],  [1,0.5], [1,0], [0.5,0], [0,0], [0,0.5], [0,1], [0.5,1] ];

  for (let i=0; i<8; i++){

    for (let j=0; j<8; j++){


      // INDICES CHARACTERS 0-F
      //
      dataPaths.push(
      new Sprite([
        new State(
          {
            pathPoints: numsvg[tile[i][j]].map(
              (d,ii) => [
                bpl + (bpc*j) + (d[0]*txtw) + txtx,
                bpd-(indexplane*scz)-bpnz,
                -bpt - (bpc*i) - (d[1]*txth) - txty
              ] ),
            fixedPoints: [],
            ...textDefaults,
            'stroke-opacity': 1,
            group: `indices`,
            classes: [`${tile[i][j]}`],
            dmake(p){
              return `M${( p.map(e => e.join(", ") )).join(" L")}`;
            }
          },
          'path')
        ], 0,0,0,0)
      );

      // PIXEL SQUARES
      //
      if (palette != null ) dataPaths.push(
        new Sprite([
          new State(
            {
              pathPoints: [
                [ bpl + (bpc*j) ,  bpd-(indexplane*scz), -bpt - (bpc*i) ],
                [ bpl + (bpc*j) + bpc ,  bpd-(indexplane*scz), -bpt - (bpc*i) ],
                [ bpl + (bpc*j) + bpc ,  bpd-(indexplane*scz), -bpt - (bpc*i) - bpc],
                [ bpl + (bpc*j) ,  bpd-(indexplane*scz), -bpt - (bpc*i) - bpc]
              ],
              fixedPoints: [],
              fill: palette[ tile[i][j] ],
              stroke: [0,0,0],
              'stroke-opacity': 0,
              'fill-opacity': 0.9,
              group: `pixels`,
              classes: [`pixels_${tile[i][j]}`],
              dmake(p){
                return `M${( p.map(e => e.join(", ") )).join(" L")} z`;
              }
            },
            'path')
          ], 0,0,0,0)
        );

    // PIXEL BUBBLES
    //
    // dataPaths.push(
    //   new Sprite([
    //     new State(
    //       {
    //         pathPoints: [
    //           ...cornersFront.map(
    //             (d,ii) => [
    //               bpl + (bpc*j) + (d[0]*txtwbox) + txtxbox,
    //               bpd-( 3 *scz)-bpnz,
    //               -bpt - (bpc*i) - (d[1]*txthbox) - txtybox
    //             ]
    //           ),
    //           ...cornersBack.map(
    //             (d,ii) => [
    //               bpl + (bpc*j) + (d[0]*txtwbox) + txtxbox,
    //               bpd-(indexplane*scz)-bpnz,
    //               -bpt - (bpc*i) - (d[1]*txthbox) - txtybox
    //             ]
    //           )
    //         ],
    //         fixedPoints: [],
    //         ...textDefaults,
    //         group: `boxes`,
    //         classes: [`box_${tile[i][j]}`],

    //         dmake(p, right, up){
    //           //HACK: convenient but might be slow...
    //           let n = p.map( d => d.join(",") );
    //           let f = n.slice(0,8); // front
    //           let b = n.slice(8); // back
    //           // let y = (p[1][1] + p[0][1]) / 2;
    //           // let x = (p[3][0] + p[0][0]) / 2;
    //           // console.log(`y = (${p[1][1]} - ${p[0][1]}) / 2 = ${y} <-> ymid ${ymid}\nx = (${p[3][0]} - ${p[0][0]}) = ${x} <-> xmid ${xmid}`);
    //           //TODO: this could be way cleaner...      arrows front to back ( bp 3-> 2 -> 1 -> 0 -> index ) [opposite of what object is "facing", towards viewer...]
    //           // if ( !right ){
    //           //   if ( !up) return `M${p[0].join(",")} C${p[1].join(",")},${p[1].join(",")},${p[2].join(",")} L${p[4].join(",")} C${p[5].join(",")},${p[5].join(",")},${p[6].join(",")} Z`; //   
    //           //   if ( up ) return `M${p[3].join(",")} C${p[0].join(",")},${p[0].join(",")},${p[1].join(",")} L${p[7].join(",")} C${p[4].join(",")},${p[4].join(",")},${p[5].join(",")} Z`; //   
    //           // }
    //           // else if ( right ) {
    //           //   if ( !up) return `M${p[1].join(",")} C${p[2].join(",")},${p[2].join(",")},${p[3].join(",")} L${p[5].join(",")} C${p[6].join(",")},${p[6].join(",")},${p[7].join(",")} Z`; //   
    //           //   if ( up ) return `M${p[2].join(",")} C${p[3].join(",")},${p[3].join(",")},${p[0].join(",")} L${p[6].join(",")} C${p[7].join(",")},${p[7].join(",")},${p[4].join(",")} Z`; //    GOOD
    //           // }
    //           // we are sort of wrapping around the points counterclockwise depending on which direction.
    //           let o = 0;
    //           if ( !right ){
    //             if ( !up) o = 0; //   
    //             if ( up ) o = 6; //   
    //           }
    //           else if ( right ) {
    //             if ( !up) o = 2; //   
    //             if ( up ) o = 4; //   
    //           }
    //           // return `M${p[0].join(",")} C${p[1].join(",")},${p[1].join(",")},${p[2].join(",")} L${p[4].join(",")} C${p[5].join(",")},${p[5].join(",")},${p[6].join(",")} Z`;
    //           return `\
    //             M ${f[(1+o)%8]}
    //             C ${f[(2+o)%8]},${f[(2+o)%8]},${f[(3+o)%8]}
    //             C ${f[(4+o)%8]},${b[(0+o)%8]},${b[(1+o)%8]}
    //             C ${b[(2+o)%8]},${b[(2+o)%8]},${b[(3+o)%8]}
    //             C ${b[(4+o)%8]},${f[(0+o)%8]},${f[(1+o)%8]}`;
    //         }
    //       },
    //       'path')
    //     ], 0,0,0,0)
    //   );

    }
  }

  // ARROW TOWARD INDICES PLANE
  //
  // INDICES CHARACTERS 0-F
  //
  dataPaths.push(
  new Sprite([
    new State(
      {
        pathPoints: [
           [
            0,
            bpd-(indexplane*0.35*scz) ,
            0
          ],
          [
            0,
            bpd-(indexplane*0.6*scz) ,
            0
          ],
          [
            bpc,
            bpd-(indexplane*0.525*scz) ,
            0
          ],

          [
            0,
            bpd-(indexplane*0.6*scz) ,
            0
          ],
          [
            -bpc,
            bpd-(indexplane*0.525*scz) ,
            0
          ],

          [
            0,
            bpd-(indexplane*0.6*scz) ,
            0
          ],
        ],
        fixedPoints: [],
        ...textDefaults,
        group: `indicesArrow`,
        classes: [`arrowToIndicesPlane`],
        dmake(p){
          return `M${( p.map(e => e.join(", ") )).join(" L")}`;
        }
      },
      'path')
    ], 0,0,0,0)
  );

  //
  // BITPLANE SQUARES
  //
  let bprects = [];

  for (let bp=0;bp<4;bp++){

    bprects.push(
      new Sprite([
        new State(
          {
            pathPoints: [
              [bpl, bpd-(bp*scz), bpt],
              [bpl+bps, bpd-(bp*scz), bpt],
              [bpl+bps, bpd-(bp*scz), bpt+bps],
              [bpl, bpd-(bp*scz), bpt+bps]
            ],
            fixedPoints: [],
            ...solidsDefaults,
            fill: bprgbbg[bp],
            stroke: bprgbfg[bp],
            group: `bp${bp}`,
            dmake(p){
              return `M${([...p,p[0]].map(e => e[0]+','+e[1])).join(" L")}`;
            }
          },
          'path')
        ], 0,0,0,0)
    );

  }

  //
  // INDICES PLANE SQUARE
  //
  //TODO: break this into a separate function to be called for both bitplanes and indices plane?
  let bp = indexplane;
  bprects.push(
      new Sprite([
        new State(
          {
            pathPoints: [
              [bpl, bpd-(bp*scz), bpt],
              [bpl+bps, bpd-(bp*scz), bpt],
              [bpl+bps, bpd-(bp*scz), bpt+bps],
              [bpl, bpd-(bp*scz), bpt+bps]
            ],
            fixedPoints: [],
            ...textDefaults,
            'stroke-opacity':0,
            group: `indices`,
            dmake(p){
              return `M${([...p,p[0]].map(e => e[0]+','+e[1])).join(" L")}`;
            }
          },
          'path')
        ], 0,0,0,0)
    )

  // return [curvs, bprects];
  // var bpsvg = makeBitplaneSVG();

  // console.log("all paths:");
  // console.log([...curvs, ...bprects, ...dataPaths]);

  return new View({
    name: name,
    parent: parent, /* replace with document.body for safe / reliable functioning */
    angleh: angleh,
    anglev: anglev,
    anglehs: 100,
    anglevs: 100,
    observation: observation,
    distance: 1,
    squaresize: 1,
    scale: 1,
    sprites: [...curvs, ...bprects, ...dataPaths],
    viewBox: [0, 0, height*0.75, height],
    className: "bpsvg",
    // sprites: [...segments, head11],
  });



}


// var bpsvg = makeBitplaneSVG();
//
//
// var view2 = new View({
//   name: '2',
//   parent: document.body, /* replace with document.body for safe / reliable functioning */
//   angleh: 0,
//   anglev: 0,
//   anglehs: 100,
//   anglevs: 100,
//   observation: 1000,
//   distance: 1000,
//   squaresize: sqs,
//   scale: 1,
//   sprites: [...bpsvg[0], ...bpsvg[1]],
//   // sprites: [...segments, head11],
// });
//NOTES:
//
// WEIRD MODE
// set distance and observation to a small number, like 10, and
// rotate to see the pixels wrap around to the other side of the screen.
//
// ISOMETRIC-ISH MODE (already default now)
// Set distance much higher than observation. Ex: dist 100000, obser 100.
// You'll have to zoom in or scale everything appropriately, but it should look
// more isometric. Scale=1 works well, but might not matter??
//


</script>





<body>

  <svg width="100vw" height="100vh" style="position:absolute;">
    <!-- oooh banana -->
    <pattern id="bananas" x="0" y="0" width="100" height="100" patternUnits="userSpaceOnUse">

      <path d="M 31.320569 9.8309245
      L 30.413647 10.09189
      L 29.443681 10.860836
      L 31.015161 13.924731
      C 31.015161 13.924731 31.004927 23.577975 28.357442 27.540955
      C 24.345802 34.194754 14.06723 38.06018 13.17749 42.554508
      L 12.461772 43.594755
      L 12.830741 44.545085
      L 13.928349 44.462919
      C 13.928349 44.462919 19.274033 46.353958 27.285673 41.191284
      C 35.906603 35.635986 40.6979 30.594415 40.17946 22.063253
      C 39.743683 14.892303 34.150887 13.079305 34.150887 13.079305
      L 31.320569 9.8309245
      z

      M 81.320618 59.830973
      L 80.413696 60.091939
      L 79.44373 60.860885
      L 81.01521 63.92478
      C 81.01521 63.92478 81.004976 73.578023 78.357491 77.541003
      C 74.345851 84.194802 64.067279 88.060229 63.177539 92.554557
      L 62.46182 93.594804
      L 62.83079 94.545133
      L 63.928398 94.462968
      C 63.928398 94.462968 69.274082 96.354007 77.285722 91.191333
      C 85.906652 85.636035 90.697948 80.594464 90.179508 72.063302
      C 89.743731 64.892352 84.150936 63.079354 84.150936 63.079354
      L 81.320618 59.830973
      z" stroke="none" fill="rgb(30, 30, 30)" ></path>
    </pattern>

    <rect x="0" y="0" width="100vw" height="100vh" fill="url(#bananas)"></rect>

  </svg>


  <div class="main" id="main">
    <!-- <div id="animationBottom" class="animationBottom"></div> -->
    <div id="navbar"><h4><i style="padding-left:5ch;">Comp / Decomp Country</i></h4></div>
    <div id="panelgrid"></div>

  </div>


  <div id="animationTop" class="animationTop"></div>



<script>

// for animation... for each element we want to locate
// .getBoundingClientRect();
// console.log(rect.top, rect.right, rect.bottom, rect.left);
// const pal = [
//         [32,32,32],
//         [0,63,63],
//         [0,63,127],
//         [30,15,115],

//         [51,19,105],
//         [67,27,97],
//         [83,40,80],
//         [105,60,75],

//         [140,70,72],
//         [215, 83, 83],
//         [230, 100, 70],
//         [240, 140, 60],

//         [250,200, 50],
//         [255, 255, 40],
//         [255,255,0],
//         [255,255,255]
//     ];

// grayscale
// Array.from(Array(16).keys()).map(d=>[Math.round(255*d/16),Math.round(255*d/16),Math.round(255*d/16)])
const pal = [
  [ 0, 0, 0 ],       [ 16, 16, 16 ],
  [ 32, 32, 32 ],    [ 48, 48, 48 ],
  [ 64, 64, 64 ],    [ 80, 80, 80 ],
  [ 96, 96, 96 ],    [ 112, 112, 112 ],
  [ 128, 128, 128 ], [ 143, 143, 143 ],
  [ 159, 159, 159 ], [ 175, 175, 175 ],
  [ 191, 191, 191 ], [ 207, 207, 207 ],
  [ 223, 223, 223 ], [ 239, 239, 239 ]
];

class Animation {
  constructor(name="anim"+Date.now()){

  }

}

// each panel of the ui; comes in different kinds
class Panel {
  constructor(parentUI, kind, rowStart, rowEnd, columnStart, columnEnd, name=null, links=null) {
    // panel templats:
    // this.templates = {
    //     binin: {
    //         dom: {

    //         }
    //     }
    // }
    this.ui = parentUI;
    this.outer = document.createElement("div");
    this.ui.grid.append(this.outer);
    if (name != null){
        this.outer.id = name;
    }
    this.outer.className = "panel_outer";

    this.inner = document.createElement("div");
    if (name != null){
        this.inner.id = name+"_inner";
    }
    this.inner.className = "panel_inner";

    this.outer.appendChild(this.inner);


    this.settings = {};

    // set up the dragging "grid"
    for (let i=1; i<4; i++){
      for (let j=1; j<4; j++){
        var edge;
        if ( !( (i==2) && (j==2) ) ){
          edge = this.outer.appendChild( document.createElement("div") );
          edge.classList.add("panel_edge");
          edge.style.gridRow = `${i} / ${i+1}`;
          edge.style.gridColumn = `${j} / ${j+1}`;
          edge.title = `row ${i} / col ${j}`;
        }
        if ( (i==3) && (j==3) ){
          edge.style.cursor = "se-resize";
          // console.log(edge);
          this.assignResize(this, edge);
        }
      }
    }


    this.name = name;
    this.nameValid = this.name.replace(/\s/g, ""); // should make a valid html id
    this.kind = kind;
    this.source = null; // input data source
    this.links = []; // references to other panels that might have transformed a .source
    this.nexts = [];
    this.palette = pal; //TODO: re-work palette system
    this.fileInputs = []; // will be populated if there are file <input>s
    // assume it's an array
    if (links){
      links.forEach(d => this.links.push(this.ui.panels[d]) );
    }

    this.eventListeners = []; // need to add them after their on the page...?

    this.index = this.ui.panels.length;
    console.log(`panel  ${this.name} should be index ${this.index}`);

    // HEADER
    // create a header
    this.inner.appendChild(document.createElement("div") );
    this.panelHeader = this.inner.children[this.inner.children.length-1];
    this.panelHeader.id = this.name+"_header";
    this.panelHeader.className = "panel_header";

    // add the title
    this.title = document.createElement("div");
    this.title.innerHTML += this.name;
    this.title.classList.add("panel_header_title");
    this.title = this.panelHeader.appendChild(this.title);

    // add the settings/menu button
    this.menuButton = document.createElement("div");
    this.menuButton.innerHTML += "";
    this.menuButton = this.panelHeader.appendChild(this.menuButton);
    this.menuButton.classList.add("panel_menu_button");

    // add the collapse button
    this.collapse = document.createElement("div");
    this.collapse.innerHTML += "";
    this.collapse.classList.add("collapser");
    this.collapse = this.panelHeader.appendChild(this.collapse);
    var collapseTime = 2000; // only source of collapse timing, to prevent redundancy
    this.collapse.style.transition = `height ${collapseTime/1000}s ease 0s`;

    // Event listener for collapsing the panelContent
    this.collapse.addEventListener("click", (event) => {

      // only if panel is not maximixed
      if ( this.inner.getAttribute("data-maximized")=="false" ) {

        // handle the css for transition animation
        event.target.classList.toggle("collapser_collapsed");
        this.panelContent.classList.add("panel_content_collapsing_expanding");
        this.panelContent.style.transition = `height ${collapseTime/1000}s ease 0s`;
        setTimeout( () => {this.panelContent.style.transition = ``;}, collapseTime );

        let headerHeight = this.panelHeader.getBoundingClientRect().height;

        // set the actual new height
        if (this.inner.getAttribute("data-collapsed")=="true"){
          this.menu.style.height = "max-content";
          this.panelContent.style.height = (this.inner.getAttribute("data-user-height")-headerHeight)+"px";
          this.inner.setAttribute("data-collapsed", "false");
        } else {
          this.menu.style.height = "0px";
          this.panelContent.style.height = "0px";
          this.inner.setAttribute("data-collapsed", "true");
        }

      }
    });


    // CONTENT
    // create the content
    this.inner.appendChild(document.createElement("div") );
    this.panelContent = this.inner.children[this.inner.children.length-1];
    this.panelContent.id = this.name+"_content";
    this.panelContent.className = "panel_content";

    // MENU
    // create the settings menu which will normally be hidden
    this.inner.appendChild(document.createElement("div") );
    this.menu = this.inner.children[this.inner.children.length-1];
    this.menu.id = this.name+"_menu";
    this.menu.className = "panel_menu";
    this.menu.innerHTML = "<h4>Settings</h4>";

    // Event listener for opening the menu
    //HACK: using setTimeout...
    setTimeout(
      ()=> {
        this.panelHeader.querySelector(".panel_menu_button").addEventListener("click", (event) => {
            console.log("toggling menu");

            // change button appearance
            event.target.classList.toggle("panel_menu_button_opened");
            // change menu appearance (show it)
            this.inner.querySelector(".panel_menu").classList.toggle("panel_menu_opened");
            this.inner.querySelector(".panel_content").classList.toggle("panel_content_disabled");

          }
        );
        console.log("menu event listener added.");
      },
      2000);


    // create outer and inner html divs
    // let headerHeight = 0;
    var offsetsTop, m;

    switch (kind){
        case "textDescription":
          //TODO: move the below text to another file
          // this.panelContent.classList.add("panel_inner_text");
          this.panelContent.innerHTML += `\
            <div class="text_content" >
              <p>
                <b>Hello!</b> This app decompresses graphics data from DKC, and provides visualizations that can help in ROM hacking.
                <br><br>
                It provides several panels with different applications:
                <ul>
                  <li> <b>Hex Viewer</b>. View hexadecimal data from game files. If viewing a processed set of data, such as decompressed data, you can download it from the "" menu.<br>
                    <ul>
                      <li> After uploading valid compressed data, if there is a hex viewer panel for decompressed data, you can navigate to its "" menu and click "Animate Decompression Process". This will show you a visualization of the process, with data bytes given different shades to correspond to the decompression mode used. These game files used many spans of compressed data, and each span has one of several possible compression/encoding modes, and usually an operand as well.</li>
                    </ul>
                  </li>
                  <li> <b>Bitplane Viewer</b>. Visualize SNES 4 bit per pixel graphics tiles and their weird intertwined format.<br>More details...
                    <ul>
                      <li> Upload a file to "Input - Compressed Data" to get started. This expects a .bin file that you might get in a disassembly of the game, usually in the "graphics/compressed" folder. Or, copy the hex values from the relevant offset of your ROM to a new file.</li>
                      <li> After uploading valid data, the bitplane diagram should appear, showing the first tile. In the diagram, you can see how the 32 bytes of data go comprise foir bitplanes. Each pixel or "cell" of the 8x8 bitplane is stacked with those of the other bitplanes to form a color index of between 0 and 15 (0x0 to 0xF) for each pixel of the tile. For example, if the bitplanes read "1 0 1 0" from front to back for a given pixel, that pixel's index value will be "A".</li>
                      <li> The bitplane diagram is a 3d model and can rotate when dragged. ctrl+scroll to zoom in or out.</li>
                      <li> Click the "<" and ">" buttons near the top to flip through the tiles. Alternatively, if a tileset viewer panel is present, click a tile within that panel to show it in the bitplane viewer.</li>
                    </ul>
                  </li>
                  <li> <b>Palette Viewer</b>. View color palettes used in the game's levels. Select a row of colors (16-color sub-palette) to have it appear in the bitplane viewer and tileset viewer.</li>
                  <li> <b>Tileset Viewer</b>. View the 8x8 pixel tiles in their grayscale form, before they are assigned a color palette.</li>
                  <li> <b>Metatiles Viewer</b>. View 32x32 pixel metatiles. Each metatile is composed of 4x4 tiles, 16 total. Each of the metatiles is built using an associated color sub-palette, and potentially horizontal and/or vertical flip; hover to view these details. If a tileset viewer panel is present, click a tile within it to have highlight all instances of that tile within the metatiles. Requires graphics tiles, palette, and then tilemap32 to be uploaded. Make sure your tilemap32 matches your 8x8 tiles: for example, don't use a foreground/background tilemap on layer 3 tiles, or vice versa. Mainly meant for FG/BG.</li>
                  <li> <b>Level Map Viewer</b>. View level maps built from the metatiles. Currently limited to only part of the level, for app performance reaons, and currently only supports horizontal levels. Requires graphics tiles, palette, tilemap32, and then level map to be uploaded.</li>
                </ul>
                <br>
                Most features require uploading a file to the relevant file input panels on the page.
              </p>
              <br>
                Panels can be:<br>
                <ul>
                    <li> moved around the page by dragging their headers</li>
                    <li> resized by dragging the bottom right corner</li>
                    <li> collapsed by clicking "" in the header</li>
                    <li> and maximized by double clicking the header.</li>
                  </ul>
                Some panels also have settings or other features hidden in the "" menu. You can zoom out of the page (usually ctrl+scroll) to have more space to organize your panels. Depending on the initial panelset template, some panels may be hidden off-screen at first.

              <br><br>
              <p>
                The app is at an early stage, but was released to celebrate DKC's 30th anniversary. The goal is to de-mystify DKC hacking and to provide even more appreciation for what Rare developed in the 1990s. Works best in a full screen window, tested most thoroughly with firefox. You can expect more features for visualizing, documenting, and hacking the DKC series soon. Thanks!
              </p>
              <br><br>
              <p>
                Special thanks to the DKC Atlas community members and their previous work. In particular Kingizor's dkcomp program. In the future I will update this page with additional guides and resources, and their proper credits.
              </p>
              <br><br><br>
              <p>
              <b>Disclaimer</b>. This software is not official or supported by Nintendo, nor any other commercial entity. It is provided AS IS, and its use is at your own risk.
              </p>
            </div>`;
          break;

        case "fileIn":
            // Create a file input, save it to the panel object, and add to panel gui
            //TODO: clean up
            // this.panelContent.appendChild( ff() );
            this.fileInputs.push(document.createElement("input"));
            this.fileInputs[this.fileInputs.length-1].id = "ii";
            this.fileInputs[this.fileInputs.length-1].className = "fileInput";

            this.fileInputs[this.fileInputs.length-1].type = "file";
            this.fileInputs[this.fileInputs.length-1].value = null;
            // this.input = input;
            // this.fileInputs.push(this.input);
            this.panelContent.appendChild(this.fileInputs[this.fileInputs.length-1]);
            // console.log("panelHeader children");
            // console.log(this.panelHeader.children);
            // headerHeight += this.input.style.height;

            // old way had no break; flow into hexviewer
            break;

        case "bitplaneViewer":
            this.selectedTile = 1;
            // bitplane header (controls)
            //



            // `<div id="Bitplane Viewer - Decompressed Data_bitplane_header" class="bitplane_header">
            //   <button class="byteWidthButton">Change View</button>
            //   <div class="seekButtons">
            //     <button class="seekTileDownButton">&lt;</button>
            //     <a>Tile&nbsp;</a>
            //     <a>1</a>
            //     <a>&nbsp;of&nbsp;</a>
            //     <a>...</a>
            //     <button class="seekTileUpButton">&gt;</button>
            //   </div>
            // </div>`

            // header itself
            let bph = document.createElement("div")
            // bph = this.panelContent.children[this.panelContent.children.length-1];
            bph.id = this.name+"_bitplane_header";
            bph.className = "bitplane_header";

            // this.bitplaneHeader2 = this.panelContent.querySelector(".bitplane_header");
            // console.log("bitplane header query selector:");
            // console.log(this.bitplaneHeader2);


            // this.bitplaneHeader3 = this.inner.querySelector(".panel_content > .bitplane_header");
            // console.log(" inner query selector:");
            // console.log(this.bitplaneHeader3.innerHTML);




            // change view button
            // this.byteWidthButton = document.createElement("button");
            // this.byteWidthButton.innerHTML = "Change View";
            // this.byteWidthButton.className = "byteWidthButton";
            // bph.appendChild(this.byteWidthButton);

            // seek tile buttons
            // this.seekTileDownButton = document.createElement("button");
            // this.seekTileDownButton.append("<");
            // this.seekTileDownButton.className = "seekTileDownButton";
            // let seek0 = document.createElement("a");
            // seek0.innerHTML = "Tile&nbsp;";
            // let seek1 = document.createElement("a");
            // seek1.innerHTML = "1";
            // let seek2 = document.createElement("a");
            // seek2.innerHTML = "&nbsp;of&nbsp;";
            // let seek3 = document.createElement("a");
            // seek3.innerHTML = "...";
            // this.seekTileUpButton = document.createElement("button");
            // this.seekTileUpButton.append(">");
            // this.seekTileUpButton.className = "seekTileUpButton";

            // let seekButtons = document.createElement("div");
            // seekButtons.className = "seekButtons";
            // seekButtons.innerHTML = `<button class="seekTileDownButton">&lt;</button><a>Tile&nbsp;</a><a>1</a><a>&nbsp;of&nbsp;</a><a>...</a><button class="seekTileUpButton">&gt;</button>`;
            // this.seekButtons = bph.appendChild(seekButtons);

            // this.seekTileDownButton = this.seekButtons.appendChild(this.seekTileDownButton);
            // [ seek0, seek1, seek2, seek3 ].forEach(d => this.seekButtons.appendChild(d));
            // this.seekTileUpButton = this.seekButtons.appendChild(this.seekTileUpButton);


            // this.bitplaneHeader = this.panelContent.appendChild( bph );

            // console.log("bitplane header .children[last]:");
            // console.log(this.bitplaneHeader);
            this.inner.classList.add("panel_inner_bitplane");
            this.panelContent.classList.add("panel_content_b1");

            //HACK
            setTimeout(()=>{

              // this.inner.querySelector(".panel_content > .hex_header > .byteWidthButton").addEventListener("click",
              //   (event) => {
              //     console.log(event);
              //     // changeByteWidth(event.target.parentNode.parentNode);
              //     this.animate16to1();
              //   });

              this.inner.querySelector(".panel_content > .hex_header > .seekButtons > .seekTileUpButton").addEventListener("click",
                (event) => {
                  console.log(event);
                  updateBitplaneSeek(event.target.parentNode.parentNode.parentNode, this, +1)
                }
              );

              this.inner.querySelector(".panel_content > .hex_header > .seekButtons > .seekTileDownButton").addEventListener("click",
                (event) => {
                  console.log(event);
                  updateBitplaneSeek(event.target.parentNode.parentNode.parentNode, this, -1)
                }

              );
              // console.log("buttons nodes");
              // console.log(this.inner.querySelector(".panel_content > .hex_header > .byteWidthButton"));
              // console.log(this.inner.querySelector(".panel_content > .hex_header > .seekButtons > .seekTileUpButton"));
            }, 1000);

            m = "_b1";

            offsetsTop = `\
              <div class="hex_header_offset"><a>OFFSET</a></div>
              <div class="hex_header_labels_left hex_header_labels_left${m}">
                <a class="hex_header_base_label hex_header_base_label${m}" style="grid-column: 1 / -1;  grid-row: 1;">Hex</a>
              </div>
              <div class="hex_header_labels_right  hex_header_labels_right${m}">
                <a class="hex_header_base_label hex_header_base_label${m}" style="grid-column: 1 / -1;  grid-row: 1;">Binary</a>
              </div>
              <div class="seekButtons">
                <button class="seekTileDownButton">&lt;</button>&nbsp;<a>Tile</a>&nbsp;<a id="currentTile">1</a>&nbsp;<a>o</a>f&nbsp;<a id="totalTiles">...</a>&nbsp;<button class="seekTileUpButton">&gt;</button>
              </div>`;

            this.panelContent.innerHTML +=
                `<div class="hex_header">${offsetsTop}</div>
                <div class="hex_content"
                 style="grid-template-rows: 100%;"></div>`;
                 //NOTE: need this grid-template-rows: 100%;  so that bp viewer doesn't
                 // overflow/scroll for wide aspect ratios.

            this.panelContent.setAttribute("data-mode","byte1");

            break;

        case "hexViewerComp":
        case "hexViewer":
            this.selectedTile = 1;
            // style="height: calc(100% - ${headerHeight}px);"
            //TODO: this is duplicated throughout code, should make modular
            // also, should only show hex offset header if the hex file is loaded and in view?
            m = "_b16";
            // let offsets0tof = Array.from( Array(32).keys() ).map(
            //   (d,i) => `${(i==16)?'<a style="grid-column: '+(1+i)+';  grid-row: 1;"></a>':''}<a class="hex_header_offset_label hex_header_offset_label${m}" style="grid-column: ${(i>>4)+1+i};  grid-row: 1;">${hex(d,2)}</a>`
            // ).join('');


            let offsets0tof = Array.from( Array(32).keys() ).map(
              (d,i) => `${(i==16)?'<a style=""></a>':''}<a class="hex_header_offset_label hex_header_offset_label${m}" style="">${hex(d,+(i>>4))}</a>`
            ).join('');

            offsetsTop = `\
              <div class="hex_header_offset"><a>OFFSET</a></div>
              <div class="hex_new_top_labels">
              ${offsets0tof}</div>`;

            this.scrollGroup = 0; // currently-viewed g256 group
            this.scrolling = false;
            this.groupSize = 256*3;
            setTimeout(()=>{
              // add scroll tracker to hexContent
              this.inner.querySelector(".panel_content > .hex_content").addEventListener("scroll",
                (event)=>{
                  // console.log("scroll");
                  // console.log(event);
                  // console.log(this.inner.querySelector(".panel_content > .hex_content").scrollTop);

                  // scroll updating, with some debouncing.
                  if (!this.scrolling){
                    this.scrolling = true;
                    this.hexScroll();
                    setTimeout( this.hexScroll(), 500); //HACK: because "scrollend" isn't supported in safari yet.
                    setTimeout( this.scrolling = false, 100);
                  }
                });
            }, 2000);


            ////////////////

            this.panelContent.innerHTML +=
                `<div class="hex_header_new">${offsetsTop}</div>
                <div class="hex_content"
                 style=""></div>`;

            this.panelContent.setAttribute("data-mode","byte16");
                // this.inner.innerHTML +=
                // `<div class="hexViewer" >
                //     <div class="hexViewerTop"></div>

                //     <div class="hexViewerScrollWrapper">
                //         <div class="hexViewerScroll">${sbytes}</div>
                //     </div>
                // </div>`;

            this.panelContent.classList.add("hex_panel_content");

            // Add details about Line Height to settings:
            this.settings['Line Height'] = {value:2};

            // Add a byte-width change button to settings:
            this.settings['Number of Columns'] = {value:16};
            setTimeout( ()=>{
              let downloadButton = document.createElement("button");
              downloadButton.className = "downloadButtons";
              downloadButton.innerHTML = "Change Number of Columns";
              downloadButton.title = "Change Number of Columns (16/32)";
              downloadButton.style.height = "2em";
              this.byteWidthButton = this.inner.querySelector(".panel_menu").appendChild( downloadButton );
              this.settings['Number of Columns'].html = [this.byteWidthButton];

              this.byteWidthButton.addEventListener("click", (event) => {
                this.panelContent.classList.toggle("hex_panel_content_32wide");
                // toggle within settings for refering to elsewhere
                this.settings['Number of Columns'].value = this.settings['Number of Columns'].value==16?32:16;
                // Update line/group/row heights:
                this.updateLines();

              });
              console.log("byte width button added...");
            },
            2100
          );

          //TODO: settings for adjusting "line-spacing":
          // use:
          // let newLineHeight = "4em";
          // Array.from(document.getElementsByClassName("hex_byte")).forEach(d=>d.style.height=newLineHeight);

          break;

        case "paletteViewer":
          this.inner.classList.add("panel_inner_palette");
          this.panelContent.innerHTML +=
                `<div class="palette_content" ></div>`;
          break;

        case "tilesetViewer":
          this.inner.classList.add("panel_inner_tileset");
          this.panelContent.innerHTML += `<div class="tileset_content"></div>`;

          break;

        case "metatilesViewer":
          this.inner.classList.add("panel_inner_tileset");
          this.panelContent.innerHTML += `<div class="tileset_content"></div>`;

          break;

        case "levelMapViewer":
          this.inner.classList.add("panel_inner_tileset");
          this.panelContent.innerHTML += `<div class="levelMap_content"></div>`;

          break;
    }



    this.rowStart = rowStart;
    this.rowEnd = rowEnd;
    this.columnStart = columnStart;
    this.columnEnd = columnEnd;

    this.fileData = null;
    this.fileBin = null;

    // Set the CSS:
    // old method, for grid
    // this.updateCSS();

    // new method, absolute/draggable

    // position the outer
    let pageWidth = document.body.querySelector(".main").clientWidth;
    let left = ((columnStart-1)*pageWidth/32) ;
    this.outer.setAttribute("data-user-left", left);
    this.outer.style.left = left+"px";

    let pageHeight = document.body.querySelector(".main").clientHeight;
    let top = ((rowStart-1)*pageHeight/28);
    this.outer.setAttribute("data-user-top", top);
    this.outer.style.top = top+"px";

    // set widths and height
    let startWidth = (columnEnd-columnStart)*pageWidth/32 ;
    this.inner.setAttribute("data-user-width", startWidth);
    this.inner.style.width = startWidth+"px";
    let bbox = this.inner.getBoundingClientRect();


    // this.inner.style.minHeight = `max-content`;

    // if (bbox.height > (rowEnd-rowStart)*height/28) this.inner.style.height = `${ (rowEnd-rowStart)*height/28 }px`;
    let headerHeight = this.panelHeader.getBoundingClientRect().height;

    // Calculate the height of this panel such that it does not exceed page height,
    // but tries to fit everything to the tallest of
    // its allocated "grid" space, OR its content
    let startHeightGrid = (rowEnd-rowStart)*pageHeight/28 ;
    let startHeightFitAllContent = this.panelContent.getBoundingClientRect().height + headerHeight;
    var startHeight;
    // But if there's a panel with a lot of content to start with, we'll assume it's meant to scroll
    // (text, for example)
    if (startHeightFitAllContent > pageHeight) startHeight = startHeightGrid;
    else startHeight = Math.min( Math.max(startHeightGrid, startHeightFitAllContent), pageHeight*0.9 );

    // save this for later, so we can collapse to 0,
    // but later expand back to the previous height
    this.inner.setAttribute("data-user-height", startHeight);
    // this.inner.setAttribute("data-collapsed", false);
    // now actually assign the calculated height to the panelContent
    // (the inner and outer should resize to accomodate, bc of max-content)
    let contentHeightCalculated = startHeight - headerHeight;
    this.panelContent.style.height = `${contentHeightCalculated}px`;

    // console.log(`${this.name}\npageHeight: ${pageHeight}; startHeightGrid: ${startHeightGrid}; startHeightFitAllContent: ${startHeightFitAllContent}; startHeight: ${startHeight}; `);
    // console.log(`${contentHeightCalculated}px`);

    this.outer.style.zIndex = this.index;

    this.assignDrag(this);


    this.inner.setAttribute("data-maximized", "false");
    this.outer.setAttribute('data-draggable', "true");
    this.assignMaximize(this);

  }

  sortZ(){

    var panelsZ = this.ui.panels.sort(
      (a,b) => a.outer.style.zIndex - b.outer.style.zIndex
    );
    var count = 1;
    // Assumes all Panel.index values are unique...
    panelsZ.forEach(
      (d,i) => {
        if ( d.index != this.index ){
          d.outer.style.zIndex = count;
          count++;
        }
      }
    );
    this.outer.style.zIndex = count; // put this at the end / on top

  }

  assignDrag(panel){
    // Drag the panel around by grabbing its header
    var element = panel.outer;
    var deltaX = 0, deltaY = 0, startX = 0, startY = 0, left, top;

    this.panelHeader.addEventListener("mousedown", (event) => {
      event = event || window.event;
      event.preventDefault();
      startX = event.clientX;
      startY = event.clientY;
      document.onmouseup = dragClose;
      document.onmousemove = dragMove;

      panel.sortZ();
    });

    function dragMove(event){
      event = event || window.event;
      event.preventDefault();

      if (element.getAttribute('data-draggable')=="false") return 0;

        deltaX = startX - event.clientX;
      deltaY = startY - event.clientY;
      startX = event.clientX;
      startY = event.clientY;

      left = element.offsetLeft - deltaX;
      element.style.left = `${left}px`;
      element.setAttribute('data-user-left', left);

      top = Math.max(element.offsetTop - deltaY, 0);
      element.style.top = `${top}px`;
      element.setAttribute('data-user-top', top);

    }

    function dragClose(event){
      document.onmouseup = null;
      document.onmousemove = null;
    }

  }

  assignMaximize(panel){

    let outer = panel.outer, inner = panel.inner;

    this.panelHeader.addEventListener("dblclick", (event) => {

      event = event || window.event;
      event.preventDefault();
      let content = inner.querySelector(".panel_content");
      console.log("content:");
      console.log(content);

      let headerHeight = inner.querySelector(".panel_header").getBoundingClientRect().height;
      let totalHeight = outer.parentNode.getBoundingClientRect().height;

      //
      switch(inner.getAttribute("data-maximized")){
        case "false":
          // move outer to the top left corner
          outer.style.top = "0px";
          outer.style.left = "0px";
          // expand inner's width and height to full screen
          inner.style.width = "100vw";
          console.log(`headerHeight: ${headerHeight}; panelUserHeight: ${inner.getAttribute("data-user-height")}`);
          // content.style.height = `calc(100vh - ${headerHeight}px)`;
          // content.style.height = "100vh";
          content.style.height = (totalHeight - headerHeight) + "px";
          //
          inner.setAttribute("data-maximized", "true");
          outer.setAttribute('data-draggable', "false");

          break;

        case "true":
          // return to previous size and position:
          [
            [outer,"data-user-top"],
            [outer,"data-user-left"],
            [inner,"data-user-width"],
            [inner,"data-user-height"]
          ].forEach(d => console.log(`${d[1]}: ${d[0].getAttribute(d[1])}` ));

          outer.style.top = outer.getAttribute("data-user-top")+"px";
          outer.style.left = outer.getAttribute("data-user-left")+"px";
          inner.style.width = inner.getAttribute("data-user-width")+"px";
          content.style.height = (inner.getAttribute("data-user-height")-headerHeight)+"px";
          inner.setAttribute("data-maximized", "false");
          outer.setAttribute('data-draggable', "true");
          break;

        default:
          inner.setAttribute("data-maximized", "false");
          break;

      }

      panel.sortZ();
    });

  }

  assignResize(panel, edge){
    // currently just the bottom right ("southeast") corner.
    var element = panel.inner;

    var startWidth, startHeight, startX, startY, bbox, cbox;
    var content, header, headerHeight, collapsed;

    edge.addEventListener("mousedown", (event) => {
      event = event || window.event;
      event.preventDefault();

      startX = event.clientX;
      startY = event.clientY;

      bbox = element.getBoundingClientRect();
      // cbox = element.querySelector(".panel_content").getBoundingClientRect();

      header = element.querySelector(".panel_header");
      content = element.querySelector(".panel_content");
      headerHeight = header.getBoundingClientRect().height;
      collapsed = this.inner.getAttribute("data-collapsed")=="true";

      startWidth = bbox.width;
      // startHeight = cbox.height;
      startHeight = bbox.height;

      document.onmouseup = resizeClose;
      document.onmousemove = resizeMove;

      panel.sortZ();

    });

    function resizeMove(event){
      event = event || window.event;
      event.preventDefault();

      let w = Math.max(startWidth + event.clientX - startX, 20) ;
      element.style.width = w+"px";
      element.setAttribute("data-user-width", w);
      // element.style.maxHeight = Math.max(h, element.style.maxHeight.split("px")[0]*1)+"px";

      // element.style.height = h;
      if (!collapsed) {
        let h = Math.max(startHeight + event.clientY - startY, headerHeight) ;
        element.setAttribute("data-user-height", h);
        content.style.height = `${h - headerHeight}px`;
      }
      // console.log( content.style.height );

      // console.log(w+" "+h);

    }


    function resizeClose(event){
      document.onmouseup = null;
      document.onmousemove = null;
      console.log("Resize ended.");
      console.log(element.querySelector(".panel_content"));
      console.log(element.querySelector(".panel_header").style.height);
      console.log(headerHeight);
    }




  }

  updateBox(rowStartDelta, rowEndDelta, columnStartDelta, columnEndDelta, widthDelta=0, heightDelta=0){
    this.rowStart += rowStartDelta;
    this.rowEnd += rowEndDelta;
    this.columnStart += columnStartDelta;
    this.columnEnd += columnEndDelta;
    // Set the CSS:
    this.updateCSS();
  }
  updateCSS(){
    this.outer.style.gridRowStart = this.rowStart;
    this.outer.style.gridRowEnd = this.rowEnd;
    this.outer.style.gridColumnStart = this.columnStart;
    this.outer.style.gridColumnEnd = this.columnEnd;

  }

  toOneByteWide(){
    // NOTE: needs fine-tuning; can't get the animations to synchronize for some weird reason.
    let ps = document.getElementsByClassName("panel_inner");
    for (let p of ps){
        p.style.width="20em";
    }
    let bs = document.getElementsByClassName("byte");
    for (let b of bs){
        b.style.width="100%";
        b.style.height = "calc(100%/32)";
    }
  }

  generateHexHTML( input = null, offset=null, length=256){

    //NOTE: currentl must pass in entire data and offsets to get accurate osset-based class names/ids.
    // Get indices of our bytes, and if we have an offset,
    // grab only those bytes and indices at the offset
    var data, offsets;
    offsets = Array.from( Array(input.length).keys()); //TODO: make this work for offsets...?
    if (offset!=null){
      data = input.slice(offset, Math.min(offset+length, input.length));
      offsets = offsets.slice(offset, Math.min(offset+length, offsets.length));
    } else{
      data = input;
      offset = 0;
    }



    // generate hexadecimal and binary strings for each byte
    let bytesHex = [];
    let bytesBin = [];
    for (let i=0; i<data.length;i++){
      bytesHex.push(hex(data[i],2));
      bytesBin.push(binar(data[i],8,4));
    }

    // parent div for following g32 elements
    var hexContent = this.inner.querySelector(" .panel_content > .hex_content");

    var count = 0;
    var html = ``;

    // for (let g4096=0; g4096 < Math.ceil(data.length/4096); g4096++){
    //   html+=`<div id="g4096_${g4096}" class="hex_g4096" style="grid-row:${1+(offsets[count]/4096)};">`;

    // for (let j=0; j < data.length; j++){
      // html+=`<div id="g4096_${g4096}" class="hex_g4096" style="grid-row:${1+(offsets[count]/4096)};">`;

    let groupSize = this.groupSize;
    var tileIndex;
    for (let group = Math.floor(offsets[0]/groupSize); ; group++){
      html+=`<div id="group_${group}" class="hex_g256" style="grid-row:${1+group};">`;
        //NOTE: not necessarily groups of 256.
      // console.log(`within generateHexHTML, creating group ${group} ( ${offsets[0]} // ${groupSize})`);
      for (let g32=0; g32 < groupSize/32; g32++){

        // separate g321 and g32r version:
        //
        // html+=`<div id="g0x${hex(offsets[count],6)}" class="hex_g32">`;
        // // Create g32 left (offsets) column, adding secon row if needed
        // html+= `<div class="hex_g32l"><div class="new_offset">${hex(Math.floor(offsets[count]),6)}</div>`;
        // if ( count+16 < data.length ) html+=`<div class="new_offset">${hex(Math.floor(offsets[count+16]),6)}</div>`;
        // html+= `</div>`;
        // // begin g32 right (data) column
        // html+= `<div class="hex_g32r">`;

        // for (let i=0; i < 32; i++){
        //   html+=`<div id="byte_${hex(offsets[count],6)}" class="hex_byte">${bytesHex[count]}</div>`;
        //   count++;
        //   if ( count >= data.length ) break;
        // }
        // html+=`</div></div>`;


        // un-separated g32 l and r version:
        //
        tileIndex = Math.floor(offsets[count]/32)+1;
        html+=`<div id="g0x${hex(offsets[count],6)}" class="hex_g32" data-tile-index="${tileIndex}" title="32-Byte Group No. ${tileIndex}">`;
        html+=`<div class="hex_g32lr">`;

        for (let i=0; i < 32; i++){
          if ( i==0 ) html+= `<div class="new_offset hex_cell">${hex(Math.floor(offsets[count]),6)}</div>`;
          if ( i==16 ) html+= `<div class="new_offset new_offet_middle hex_cell">${hex(Math.floor(offsets[count]),6)}</div>`;
          html+=`<div id="byte_${hex(offsets[count],6)}" class="hex_byte hex_cell">${bytesHex[count]}</div>`;
          count++;
          if ( count >= data.length ) break;
        }
        html+=`</div>`;
        html+=`</div>`;

        if ( count >= data.length ) break;
      }
      html+=`</div>`;
      if ( count >= data.length ) break;
    }
      // html+=`</div>`;
    // }

    // console.log(html);
    hexContent.innerHTML += html;



  }



  generateBitplaneHTML(input = null, offset=0, mode=null, length=32, replace=[]){
    // does main work for generating hex editor-style view and bp viewer ui
    // console.log(input);
    var mode16;

    console.log("generateHexHTML");
    [input,
offset,
mode,
length,
replace].forEach(d=>console.log(d));
    var rbytes = [];
    if (input){
      // if we have an input, use it
      rbytes = input;
    }
    else{
      // if we don't  have an input, generate random data (mainly for debug)
      let nbytes = 128;
      // let rbytes = Array.from(Array(nbytes).keys()).map(d => Math.round(Math.random()*255) );
      rbytes = Array.from(Array(nbytes).keys());
    }

    // Get indices of our bytes, and if we have an offset,
    // grab only those bytes and indices at the offset
    let indices = Array.from( Array(rbytes.length).keys());
    if (offset!=null){
      // we will look only at these 32 bytes.
      rbytes = rbytes.slice(offset, Math.min(offset+length, rbytes.length));
      indices = indices.slice(offset, Math.min(offset+length, indices.length));
    }

    // parse the data mode to generate
    if ( mode=="plain") {
      mode16 = true;
    } else if (mode==null){
      mode16 = this.panelContent.getAttribute("data-mode")=='byte16';
    } else{
      mode16 = mode=='byte16';
    }
    var m = mode16?"_b16":"_b1"; // shorthand to be used later
    var notm = !mode16?"_b16":"_b1";

    console.log(`${this.name}: Generating hex html for data with ${rbytes.length} bytes...`);

    // generate hexadecimal and binary strings for each byte
    let rbytesHex = [];
    let rbytesBin = [];
    for (let i=0; i<rbytes.length;i++){
      rbytesHex.push(hex(rbytes[i],2));
      rbytesBin.push(binar(rbytes[i],8,4));
    }

    let sbytes = ``;
    let g32l = ``; //
    let g32r = ``; //
    let g32b = ``; // running strings
    let bw = 16; // byte width...
    let tw = 32; // total byte width possible...
    let th = 32; // total height (usually just 32 anyway )
    let rows = 1 + (bw<tw); // for normal width
    let tileCount = 0; // will track how many (unnecessary?)
    var g32elem;
    var g32selem;
    var classGen = ``;

    // parent div for following g32 elements
    var hexContent = this.inner.querySelector(" .panel_content > .hex_content");
    var replacing = replace.length!=0;
    if (!replacing){
      hexContent.innerHTML = ''; // clear it all first
      this.numberOfTiles = Math.ceil(rbytes.length/32);
    }

    // hexContent.style.gridTemplateRows = `repeat(${Math.ceil(rbytes.length/32)}, auto)`;

    // loop through all bytes.
    // note that each "tile", or 32 bytes, is contained in a class "g32" div,
    // made up of three columns:
    //
    //  g32l                  g32rr                 g32b       g32s
    //  (left-side offsets)   (actual bytes data)   (binary)   (svg bitplane)
    //                                               \  initially hidden   /
    // if ( !(mode=="plain")){
    for (let i=0; i< rbytes.length; i++){
        let ii = i%32;

        let j = i%th;
        // Mode 16: normal, 16-byte width:
        let row = 1*(j>=bw); // 0 or 1
        let col = j%bw; // 0 to bw
        let gtcn = `${col}fr 1fr ${bw-col-1}fr`;
        let gtrn = `${row}fr 1fr ${rows-(row+1)}fr`;
        let left =

        //TODO: mode 32...

        row = 1*(j>=tw); // 0 or 1
        col = j%tw; // 0 to bw
        let gtcnn = `${col}fr 1fr ${tw-col-1}fr`;
        let gtrnn = `${row}fr 1fr ${rows-(row+1)}fr`;

        // Mode 1: 1-byte-wide:
        let gtc1 = `0fr 1fr 0fr`;
        let gtr1 = `${j}fr 1fr ${th-j-1}fr`;

        //TODO: better method? Find bitplane
        let bp = (((i>>4)%2)*2)+(i%2);
        let row16Odd = (i>>4)%2;

        // // //
        let left16 = 100*((0.5+ii)%16)/16;
        let left1 = 50;
        let top16 = 25+(50*Math.floor(ii/16));
        let top1 = 100*(0.5+ii)/32;
        let classGens = [
          `.g32rb_item_${ii}_b16{top:${top16}%;left:${left16}%;}`,
          `.g32rb_item_${ii}_b1{top:${top1}%;left:${left1}%;}`,
          `.g32l_item_${ii}_b16{top:${top16}%;left:50%;}`,
          `.g32l_item_${ii}_b1{top:${top1}%;left:50%;}\n`
        ] ;
        classGen+=classGens.join(`\n`);

        let offsetType = ((i%16)==0)?'always':'sometimes';
        let fgType = mode16?'':('fg_bp'+bp);

        g32l+=`<div
          data-bitplane="${bp}"
        data-gridclass="g32l_item_${ii}"
        class="g32_item g32_item${m} ${fgType} g32l_offset_${offsetType} g32l_offset_${offsetType}${m} g32l_item_${ii}${m}"
          >${hex(indices[i],6)}</div>`;

        g32r += `\
        <div
          data-bitplane="${bp}"
        data-gridclass="g32rb_item_${ii}"
        class="g32_item g32_item${m} ${fgType} g32rb_item_${ii}${m}"
          >${rbytesHex[i]}</div>
        `;

        if ( !(mode=="plain")){
          g32b += `\
          <div
          data-bitplane="${bp}"
          data-gridclass="g32rb_item_${ii}"
          class="g32_item g32_item${m} ${fgType} g32rb_item_${ii}${m}"
          >${rbytesBin[i]}</div>
          `;
          console.log(`Adding binary HTML for ${1+Math.floor( (offset+i)/32 )}`);
        }

        // if we're 1 before the end of the 32-batch, or at the overall end, close up this group:
        if (  ((i+1)%32 == 0) || (i == (rbytes.length-1)) ){

            // wrapper g32
            if (replace[tileCount]){ // if we're replacing content in a pre-existing g32
              g32elem = replace[tileCount];
              g32elem.innerHTML = ''; // delete contents
              g32elem.classList.add("g32"+m);
              g32elem.classList.remove("g32"+notm);
              console.log(`within generateHexHTML, received mode ${mode}, parsed to mode16 ${mode16}, made a g32 with classes ${Array.from(g32elem.classList).join(", ")}`);

            } else { // creating a new g32
              g32elem = document.createElement('div');
              g32elem.className = "g32";
              g32elem.id = "tile_index_"+(1+Math.floor( (offset+i)/32 ) );
              g32elem.classList.add("g32"+m);
              // assign the tile index (1-based, not 0-based)
              g32elem.setAttribute("data-tile-index", 1+Math.floor( (offset+i)/32 ) );
              hexContent.appendChild(g32elem);
            }

            if ( !(mode=="plain")){
              // g32bg (background)
              let g32bgelem = document.createElement('div');
              g32bgelem.className = "g32bg";
              g32bgelem.classList.add("g32bg"+m);

              g32bgelem.innerHTML = Array.from(Array(32).keys()).map(
                (ii)=>`<div class="g32bg_row bg_${Math.floor(ii/16)?(ii%2?"bp3":"bp2"):(ii%2?"bp1":"bp0")}"></div>`
              ).join("");
              g32elem.appendChild(g32bgelem);
            }


            // g32l
            let g32lelem = document.createElement('div');
            g32lelem.className = "g32l";
            g32lelem.innerHTML = `${g32l}`;
            g32elem.appendChild(g32lelem);

            // g32r
            let g32relem = document.createElement('div');
            g32relem.className = "g32r";
            g32relem.classList.add("g32r"+m);
            g32relem.innerHTML = `${g32r}`;
            g32elem.appendChild(g32relem);

            if ( !(mode=="plain")){
              // g32b
              let g32belem = document.createElement('div');
              g32belem.className = "g32b";
              g32belem.innerHTML = `${g32b}`;
              g32elem.appendChild(g32belem);

              // create the g32s, currently empty but will later contain an svg, if bitplane
              g32selem = document.createElement('div');
              g32selem.className = "g32s";
              g32selem.classList.add("g32s"+m);
              g32selem.id=`${this.nameValid}_g32s_${tileCount}`;
              g32elem.appendChild(g32selem); // comment these out for debugging (slow af)

              if ( !(mode16)){

                var tileIndex0Based = Math.floor( (offset+i)/32 );
                var offsetbp = tileIndex0Based*32;
                console.log(`Creating bitplane with data ${offsetbp}, ${offsetbp+32}`);
                console.log(g32selem);
                this.generateBitplaneView(
                  g32selem,
                  this.source.data.slice(offsetbp, offsetbp+32),
                  tileIndex0Based);

              }
            }

            // increment and reset for next group of 32 bytes
            tileCount++;
            g32l = ``;
            g32r = ``;
        }


    }

  // if (!replacing){
  //   this.panelContent.querySelector(".hex_content").style.gridTemplateRows = `repeat(${this.numberOfTiles}, calc(100%/8))`;
  // }
  if (mode16){
    this.panelContent.querySelector(".hex_content").style.gridTemplateRows = `repeat(${this.numberOfTiles}, 4em)`;
  }

  }

  generateBitplaneView(parent, data, tileIndex){

    // get previous info, if any, to carry over to next tile's bitplane View
    let anglev = -0.78;    //
    let angleh = -0.36;    //
    let observation = 0.5; // good defaults
    if (this.bpsvgs){
      anglev = this.bpsvgs[0].anglev;
      angleh = this.bpsvgs[0].angleh;
      observation = this.bpsvgs[0].observation;
    }
    this.bpsvgs = []; // clear previous

    // let str = `${this.nameValid}_g32s_${ntiles}`;
    // let parent = document.getElementById(str); // parent element to which to append svg

    // let data = rbytes.slice(i, i+32);

    this.bpsvgs.push(
      makeBitplaneSVG(
        parent,
        "bpsvg_"+tileIndex,
        data,
        angleh,
        anglev,
        observation,
        this.palette
      )
    );
  }
  generateAnimateDecompButton( ){
    // initialize
    this.animateDecomp();

    setTimeout( ()=>{
        let animateButton = document.createElement("button");
        animateButton.className = "downloadButtons";
        animateButton.innerHTML = "Animate Decompression Process";
        animateButton.title = "This will demonstrate the 4 command modes in the compressed data.";
        animateButton.style.height = "2em";
        this.animateDecompButton = this.inner.querySelector(".panel_menu").appendChild( animateButton );

        this.animateDecompButton.addEventListener("click", (event) => {
          // begin animation
          this.animation.initDecomp( this, this.nexts[0] );
        });
        console.log("Animate Decompression button added...");
      },
      1100
    );
  }


  generateDownloadButton(data, fileName, title, label="Download"){
    // let header = this.inner.querySelector(" .panel_header");
    setTimeout( ()=>{
        let downloadButton = document.createElement("button");
        downloadButton.className = "downloadButtons";
        downloadButton.innerHTML = label;
        downloadButton.title = title;
        downloadButton.style.height = "2em";
        this.downloadButton = this.inner.querySelector(".panel_menu").appendChild( downloadButton );

        console.log("beginning download button added... "+Date.now());
        this.downloadButton.addEventListener("click", (event) => {
          console.log("download button clicked. url object:");
          const dataBlob = new Blob( [data], {type: "application/octet-stream"});
          let urlObject = URL.createObjectURL( dataBlob );

          console.log(urlObject);

          let a = document.createElement("a");
          a.download = fileName;

          a.href = urlObject;
          a.click();
          setTimeout( () => { URL.revokeObjectURL( urlObject ); console.log("Download URL removed."); } );
        });
        console.log("download button added... "+Date.now());
      },
      1100
    );


  }

  updateLines(){

    // update hexContent grid's grid-template-rows
    let hc = this.inner.querySelector(".panel_content > .hex_content");
    let numberOfGroups = Math.ceil( this.source.data.length / this.groupSize );
    let groupHeight = this.settings['Line Height'].value * this.groupSize / this.settings['Number of Columns'].value ;
    let gtr = `repeat(${numberOfGroups}, ${ groupHeight}em)`;
    hc.style.gridTemplateRows = gtr;

    // update cells' line height
    let cells = Array.from( hc.querySelectorAll("div > div > div > .hex_cell"));
    cells.forEach( d => d.style.height = this.settings['Line Height'].value +"em");
  }

  generateLineSpacingRange(){

    let id = this.nameValid+'_'+('Line Height'.replace(/\s/g, ""));

    // overall text label html:
    this.lineSpacingDescription = document.createElement("a");
    this.lineSpacingDescription.innerHTML = 'Line Height' ;
    this.lineSpacingDescription = this.inner.querySelector(".panel_menu").appendChild( this.lineSpacingDescription );

    // "range" slider html:
    this.lineSpacingInput = document.createElement("input");
    this.lineSpacingInput.id = id;
    this.lineSpacingInput.type = "range";
    this.lineSpacingInput.min = "1";
    this.lineSpacingInput.max = "4";
    this.lineSpacingInput.step = "0.25";
    this.lineSpacingInput.value = this.settings['Line Height'].value;
    this.lineSpacingInput = this.inner.querySelector(".panel_menu").appendChild( this.lineSpacingInput );

    // indicator text html:
    this.lineSpacingLabel = document.createElement("label");
    this.lineSpacingLabel.for = id;
    this.lineSpacingLabel.innerHTML = this.settings['Line Height'].value;
    this.lineSpacingLabel = this.inner.querySelector(".panel_menu").appendChild( this.lineSpacingLabel );


    this.settings['Line Height'].html = [this.lineSpacingDescription, this.lineSpacingInput, this.lineSpacingLabel]


    this.lineSpacingInput.addEventListener("input", (event) => {
      console.log(event);
      this.settings['Line Height'].value = event.target.value;
      // update indicator
      // event.target.label.innerHTML = this.settings['Line Height'].value;
      this.settings['Line Height'].html[2].innerHTML = this.settings['Line Height'].value;
      //
      this.updateLines();

    });


  }

  generateTilesetHTML(input = null){
    let tilesetContent = this.panelContent.querySelector(".tileset_content");
    tilesetContent.innerHTML = ""; //clear all content first
    tilesetContent.style.maxHeight = "15em";
    // console.log("this.inner");
    // console.log(this.inner);
    // console.log("tileset content");
    // console.log(tilesetContent);
    var count = 1;
    for (let tile of input){

      var wrapper = document.createElement("div");
      // canvas.id = "canvas";
      wrapper = tilesetContent.appendChild(wrapper);
      wrapper.className = "tile_wrapper";
      let title = `Tile ${count}\n(Click to view bitplanes)`;
      wrapper.title = title;
      if (count==1){
        console.log(title);
        console.log(wrapper);
      }
      wrapper.setAttribute("data-tile-index", count);

      // add event listener for
      // opening this tile's data in the linked bitplane viewer
      // and highlighting this tile's presence in metatiles.
      wrapper.addEventListener("click", (event) => {

        let clickedTile = event.target;
        // console.log(clickedTile);
        let parent = clickedTile.parentNode;
        // console.log(parent);
        let tileIndex = parent.getAttribute("data-tile-index")*1; // 1-based
        console.log("Selected Tile "+tileIndex+".");

        // toggle this tile's selected class:
        let alreadySelected = clickedTile.classList.contains("tile_item_selected");
        Array.from(parent.parentNode.querySelectorAll(".tile_wrapper > .tile_item_selected")).forEach(d=>d.classList.remove("tile_item_selected"));
        if (!alreadySelected) clickedTile.classList.add("tile_item_selected"); // add it back if it wasn't selected

        // update the bitplane viewer if it's available
        //HACK: assumes index 0 is the bitplane viewer
        if (this.links[0].source){
          // this.nexts[0].generateHexHTML( this.nexts[0].source.data);
          // A wrapper that prevents jumping to 1st tile
          // last argument, override, will ensure the svg is updated.

          // console.log(`this.links[2]: `);
          // console.log(this.links[2]);
          updateBitplaneSeek(this.links[2].inner, this.links[2], 0,
            tileIndex )
          this.selectedTile = tileIndex;
          // this.links[0].scrollToTile( this.selectedTile );

        }


        // highlight this tile's presence within linked metatile viewers
        var subtiles, tileClass;

        for (let panel of this.nexts){
          if ( (panel.kind == "metatilesViewer") && panel.source ){

            tileClass = "metatile_subtile_tile_index_"+tileIndex;
            subtiles = panel.inner.querySelectorAll(".panel_content > .tileset_content > .metatile_wrapper > canvas");

            // toggle selected class if this is the tile in question, else remove selected class
            for (let subtile of subtiles){
              if (subtile.classList.contains(tileClass) ) { subtile.classList.toggle("tile_item_selected"); }
              else { subtile.classList.remove("tile_item_selected"); }
            }

          }

        }



      });

      display( [tile],  wrapper, this.palette, 1 ) ;
      count++;
    }
  }

  generateMetatilesetHTML(input = null){
    let tilesetContent = this.panelContent.querySelector(".tileset_content");

    let mtCount = 1;
    for (let mt of input){

      let metatileWrapper = tilesetContent.appendChild( document.createElement("div"));
      metatileWrapper.className = "metatile_wrapper";
      metatileWrapper.classList.add("metatile_wrapper_viewer");

      for (let st of mt) {
        let pidx = st.paletteIndex*16;
        let title = `Metatile ${mtCount}\n\nTile ${st.tileIndex+1}\nVertical Flip: ${st.vflip?"yes":"no"}\nHorizontal Flip: ${st.hflip?"yes":"no"}`;
        // Note that tile index is 1-based indexing, palette is 0-based
        let classes = [`metatile_subtile_tile_index_${st.tileIndex+1}`, `metatile_subtile_palette_index_${st.paletteIndex}`];
        display( [st.colorIndices],  metatileWrapper, this.palette.slice(pidx,pidx+16), 1, title, classes );

      }
      mtCount++;
    }
  }

  generateLevelMapHTML(input = null){
    console.log("Generating level map (${input.length} metatiles)...");
    let tilesetContent = this.panelContent.querySelector(".levelMap_content");

    let cutoff = 16*16;
    let count = 0;
    for (let lt of input){
      let mt = lt.metatile;
      let vf = lt.vflip;
      let hf = lt.hflip;
      let metatileWrapper = tilesetContent.appendChild( document.createElement("div") );
      metatileWrapper.className = "metatile_wrapper";

      for (let st of mt) {
        let pidx = st.paletteIndex*16;
        display( [st.colorIndices],  metatileWrapper, this.palette.slice(pidx,pidx+16), 1 );
      }
      let cssflip = `${hf?'scaleX(-1) ':''}${vf?'scaleY(-1) ':''}`;
      metatileWrapper.style.transform = cssflip;
      // if (vf || hf) console.log(`Level metatile ${count} should be flipped ${cssflip}.`)
      count++;
      if (count >= cutoff) break;
    }

  }

  generatePaletteHTML(input = null){
    let paletteContent = this.panelContent.querySelector(".palette_content");

    for (let i=0; i<input.length; i++){
      let colorItem = document.createElement("div");
      colorItem.className = "color_item";
      colorItem.classList.add(`subPalette_${Math.floor(i/16)}`);
      colorItem.style.backgroundColor = `rgba(${input[i].join(", ")}, 1)`;
      colorItem.title = `Index 0x${hex(i,2)}\nSNES 15-bit RGB (${binart(rgb2snes(input[i]),15,5)})\n24-bit RGB (${input[i].join(", ")})`;
      // colorItem.style.color = `rgba(${input[i].map(d => (127+d)%255).join(", ")}, 1)`;
      let c = paletteContent.appendChild( colorItem);

      // let a = document.createElement("a");
      // a.innerHTML = hex(i,2);
      // a.className = "color_label";
      // c.appendChild(a);


      // Handle the selection of palettes:

      c.addEventListener("click", (event) => {
        let ClickedColorItem = event.target;
        // console.log(ClickedColorItem);
        let parent = ClickedColorItem.parentNode;
        // console.log(parent);
        let subPaletteClass = "subPalette_0"; // placeholder...
        // find the classname containing info about sub-palette:

        for (let className of event.target.classList){
          if ( className.includes("subPalette") ){
            subPaletteClass = className;
            break;
          }
        }
        if ( subPaletteClass == this.selectedSubPalette ){
          // clicking again will remove the palette, go back to grayscale.
          this.selectedSubPalette = "none";
          // Now that we know the current palette, go through and clear others and add to this one.
          for (let colorItem of parent.querySelectorAll(".color_item")){
            if ( colorItem.classList.contains( subPaletteClass ) ) colorItem.classList.remove( "color_item_selected" );
          }
          this.palette = pal;

        } else {
          // otherwise, switch to other subpalete
          this.selectedSubPalette = subPaletteClass;


          // Now that we know the current palette, go through and clear others and add to this one.
          for (let colorItem of parent.querySelectorAll(".color_item")){
            if ( colorItem.classList.contains( subPaletteClass ) ){
              // console.log("adding class: selected");
              colorItem.classList.add( "color_item_selected" );
            } else{
              colorItem.classList.remove( "color_item_selected" );
            }
          }

          // assign the palette values to this panel, so other things can reference it.
          // ( by default, this.palette is the global pal constant )
          let subPaletteIndex = subPaletteClass.split("_")[1]*1;
          // console.log("assigning palette "+subPaletteIndex);
          this.palette = input.slice( subPaletteIndex*16, (subPaletteIndex+1)*16 );
        }

        // update dependent panels' palettes:
        this.nexts.forEach( d => d.palette = this.palette);

        // update the bitplane viewer if it's available
        //HACK: assumes nexts index 1 is the bitplane viewer
        if (this.nexts[1].source){
          // this.nexts[0].generateHexHTML( this.nexts[0].source.data);
          // A wrapper that prevents jumping to 1st tile
          // last argument, override, will ensure the svg is updated.
          updateBitplaneSeek(this.nexts[1].inner, this.nexts[1], 0, true )
        }
        // update tileset view
        if (this.nexts[2].source){
          this.nexts[2].generateTilesetHTML( this.nexts[2].source.data);
          // A wrapper that prevents jumping to 1st tile
          // last argument, override, will ensure the svg is updated.
          // updateBitplaneSeek(this.nexts[0].inner, this.nexts[0], 0, true )
        }

      });

    }

  }


  scrollToTile( tileIndex ){
    // scrolls to a tile
    console.log("scrolling to tile "+tileIndex);
    let hc = this.panelContent.querySelector(".hex_content");
    // let newTile = hc.querySelector("#tile_index_"+tileIndex);
    // let oldTile = hc.querySelector("#tile_index_"+this.selectedTile);

    // let newTile = hc.querySelector("div > #g0x"+hex((tileIndex-1)*32,6));

    // if (!newTile) {
    //   // if this tile isn't already present, we'll have to calculate where it would be and scroll there:
    //   let newPosition = hc.querySelector("div > .hex_g32").getBoundingClientRect().height*(tileIndex-1);
    //   setTimeout( ()=>hc.scrollTo({top: newPosition, behavior: 'smooth'}), 0.1);

    // } else {
    //   // Just scroll directly to that tile (maybe more reliable?)
    //   setTimeout( ()=>hc.scrollTo({top: newTile.offsetTop-(newTile.offsetHeight), behavior: 'smooth'}), 0.1);
    // }

    // calculate where it would be and scroll there (seems more reliable that looking up div, if it even exists)
    let newPosition = hc.querySelector("div > .hex_g32").getBoundingClientRect().height * (tileIndex-1);
    setTimeout( ()=>hc.scrollTo({top: newPosition, behavior: 'smooth'}), 0.1);

    // update this panel's currently selected tile
    this.selectedTile = tileIndex;

  }
  /* some scroll functions may be redundant... */
  checkOffsetPosition( offset, bottomRowMargin=2, topRowMargin=0 ){
    let hc = this.panelContent.querySelector(".hex_content");
    let windowHeight = hc.getBoundingClientRect().height;
    let windowScrollTop = hc.scrollTop;
    let windowScrollBottom = windowHeight + windowScrollTop;
    // check where the offset would be:
    // (doesn't directly query, because html node might not exist yet, for performance reasons)
    let g32Height = hc.querySelector("div > .hex_g32").getBoundingClientRect().height;
    let offsetPos = (g32Height*(offset>>5)); // relative to top of its container, NOT the window
    let rowHeight = (this.settings['Number of Columns'].value==16) ? g32Height/2 : g32Height;
    // if we're in the second row, add a rowHeight
    //TODO: make more modular for arbitrary col widths?
    if ( (this.settings['Number of Columns'].value==16) && (((offset/16)%2)>=1) ) offsetPos += g32Height/2;
    //
    var outs = {
      position: offsetPos,
      topMargin: topRowMargin*rowHeight,
      windowHeight: windowHeight,
      rowHeight: rowHeight,

    };

    if ( (offsetPos < (windowScrollTop + (topRowMargin*rowHeight))) || (offsetPos > (windowScrollBottom - (bottomRowMargin*rowHeight))) ){
      // setTimeout( ()=>hc.scrollTo({top: offsetPos, behavior: 'smooth'}), 0.1);
      return { ...outs, inView: false};
    } else {
      return { ...outs, inView: true};
    }

  }
  scrollToOffset( offset ){
    // scrolls to an offset: expects offset as a number, not string
    console.log("scrolling to offset "+hex(offset,6));
    let hc = this.panelContent.querySelector(".hex_content");
    let g32Height = hc.querySelector("div > .hex_g32").getBoundingClientRect().height;
    let newPosition = (g32Height*(offset>>5));
    if ( (this.settings['Number of Columns'].value==16) && (((offset/16)%2)>=1) ) newPosition += g32Height/2;
    setTimeout( ()=>hc.scrollTo({top: newPosition, behavior: 'smooth'}), 0.1);
  }
  scrollToView( offset ){
    let hc = this.panelContent.querySelector(".hex_content");
    let windowHeight = hc.getBoundingClientRect().height;
    let windowScrollTop = hc.scrollTop;
    let windowScrollBottom = windowHeight + windowScrollTop;
    // check where the offset would be:
    let g32Height = hc.querySelector("div > .hex_g32").getBoundingClientRect().height;
    let newPosition = (g32Height*(offset>>5));
    let rowHeight = (this.settings['Number of Columns'].value==16) ? g32Height/2 : g32Height;
    if ( (this.settings['Number of Columns'].value==16) && (((offset/16)%2)>=1) ) newPosition += g32Height/2;
    //
    if ( (newPosition < (windowScrollTop + rowHeight)) || (newPosition > windowScrollBottom - (2*rowHeight)) ){
      setTimeout( ()=>hc.scrollTo({top: newPosition, behavior: 'smooth'}), 0.1);
    }

  }

  hexScroll(){
    // this is called within an event listener of the hex_content being scrolled
    let gnum = this.groupSize;
    let totalGroups = Math.ceil(this.source.data.length/gnum);
    let oldGroup = this.scrollGroup*1;

    let headersHeight = this.inner.querySelector(".panel_header").getBoundingClientRect().height + this.inner.querySelector(".hex_header_new").getBoundingClientRect().height;

    let groupElementSelector = `.panel_content > .hex_content > #group_${this.scrollGroup}`;
    // console.log(groupElementSelector);
    let groupElement = this.inner.querySelector(groupElementSelector);
    let groupHeight = groupElement.getBoundingClientRect().height;
    let groupTop = groupElement.offsetTop - headersHeight;
    // let groupTop = groupElement.getBoundingClientRect().top;
    let groupBottom = groupHeight + groupTop;
    let windowHeight = this.inner.querySelector(".panel_content > .hex_content").getBoundingClientRect().height;
    let windowScrollTop = this.inner.querySelector(".panel_content > .hex_content").scrollTop;
    let windowScroll = windowScrollTop + (windowHeight/2); // use middle

    // if we're outside the current group, find which one we're in.
    // Assumes all groups are the same height.
    if ( ( windowScrollTop > groupBottom ) || ( windowScrollTop < groupTop ) ) {

      // New group based on scroll position, limited to possible groups' range,
      // because sometimes the scroll position seems to jump impossibly past the end,
      this.scrollGroup = Math.min(Math.max(Math.floor(windowScrollTop/groupHeight),0),totalGroups-1);

      // If there was a change:
      let added = [], removed = [];

      // now that we have the new group,
      // check that all groups within a 3-tall window of it are present, if within possible range.
      for (let g=this.scrollGroup-1; g<this.scrollGroup+2; g++){
        // if it's even within range:
        if ( (g>-1) && (g<totalGroups) ){
          // if it doesn't yet exist, create it:
          var current = this.inner.querySelector(`.panel_content > .hex_content > #group_${g}`);
          if ( !current ){
            this.generateHexHTML( this.source.data, g*gnum, gnum);
            // console.log(`added group ${g} of ${totalGroups}.`);
            added.push(g);
          }
        }
      }

      // remove previous.
      for (let g = oldGroup-1; g <= oldGroup+1; g++){
        // if it's even within possible range:
        if ( ( g >= 0 ) && ( g < totalGroups ) ){
          // if it exists, and isn't within the new group's range, remove it:
          var current = this.inner.querySelector(`.panel_content > .hex_content > #group_${g}`);
          var outOfRange = (g < (this.scrollGroup-1)) || (g > (this.scrollGroup+1));
          // if (outOfRange) console.log(`group ${g} is out of range of group ${this.scrollGroup}`);
          if ( current && outOfRange){
            current.remove();
            // console.log(`...removed group ${g}.`);
            removed.push(g);
          } else{
            // console.log(`...group ${g} not removed`);
            0;
          }
        }
      }

      let existing = Array.from(this.inner.querySelectorAll(`.panel_content > .hex_content > div`));
      console.log( `scroll : top ${windowScrollTop} | Group ${oldGroup} -> ${this.scrollGroup}: ${groupTop} <-> ${groupBottom} | [ ${existing.map(d=>d.id.split("_")[1]).join(", ")} ] +[${added.join(",")}] -[${removed.join(",")}] (${totalGroups} total)` );

      this.updateLines();

    }

  }

  animate16to1(overrideMode=null,tile=null){

    if (!this.tic) this.tic = 1.5; // in s

    var hexContent = this.panelContent.querySelector(".hex_content");

    if (tile==null){
      // var g32tile = hexContent.querySelector(".g32");
      var g32tile = hexContent.querySelector("#tile_index_"+this.selectedTile);
      // console.log(g32tile);
    }
    else{
      var g32tile = tile;
    }
    var tileIndex = g32tile.getAttribute("data-tile-index")*1;

    var oldMode = this.panelContent.getAttribute("data-mode");
    var newMode = "";
    if (overrideMode){
      newMode = overrideMode;
    }
    else{
      newMode = oldMode=="byte16"?"byte1":"byte16"; // simplified: toggle
    }

    var ani = {
      duration: 1,
      elapsed: 0,   // set to final element's delay for "backwards" order
      direction: 1, // set -1 for "backwards" order
      series: true, // set to false before running parallel animations
      timingFunction: 'ease',
      tic: function (duration, delay){
        if (!duration) duration = this.duration;
        if (!delay) delay = this.elapsed;
        this.elapsed+= ( duration * this.direction )
      },
      mate: function (elements, toggleClasses, duration, timingFunction, delay){
        if (!duration) duration = this.duration;
        if (!timingFunction) timingFunction = this.timingFunction;
        if (!delay) delay = this.elapsed; // usually won't specify anyway

        let trans = `${duration}s ${timingFunction} ${delay}s`;
        // console.log(toggleClasses[0]+":   "+trans);

        for (let element of elements){

          // // Directly assign a transition
          // element.style.transition = trans;
          // // Assign a timeout for the transition to be removed
          // setTimeout( () => {
          //   element.style.transition = ``;
          //   // console.log((delay+duration)+"s:  "+toggleClasses[0]+"");
          // }, ((delay+duration)*1000)-5 );
          // // toggle the classes
          // toggleClasses.forEach( (d)=> element.classList.toggle(d) );


          // Assign a timeout for the transition to be removed
          setTimeout( () => {
            // Directly assign a transition
            element.style.transition = trans;
            // toggle the classes
            toggleClasses.forEach( (d)=> element.classList.toggle(d) );

            setTimeout( () => element.style.transition = ``, ((delay+duration)*1000)-5 );

          }, ((delay)*1000) );


        }
        // increase the elapsed count
        if (this.series) this.tic(duration, delay);
      }
    };

    // // animation "steps" labeled according to order when going byte16 -> byte1

    // replace default "plain" with more detailed g32:
    this.generateHexHTML( this.source.data, (tileIndex-1)*32, oldMode, 32, [g32tile]);
    console.log("replacing with old mode "+oldMode+" to start with...");

    switch(newMode){
      case "byte16":

        // animation order settings ("backwards" order)
        var numTics = 5;
        ani.duration = this.tic;
        ani.elapsed = (numTics-1) * ani.duration;
        ani.elapsed = 6;
        ani.direction = -1;
        break;

      case "byte1":
        // "forwards" order
        ani.duration = this.tic;
        ani.elapsed = 0;
        ani.direction = 1;

        // if we are going to 1-bit-wide mode, update the html first


        // create the svg
        var tileIndex0Based = (1*g32tile.getAttribute("data-tile-index")) - 1;
        var offset = tileIndex0Based*32;
        this.generateBitplaneView(
          g32tile.querySelector(".g32s"),
          this.source.data.slice(offset, offset+32),
          tileIndex0Based);
        break;
    }



    // animation "steps" labeled according to order when going byte16 -> byte1
    ani.series = false;

    // already has a 1s grid temp rows transition permanently assigned.
    let before = tileIndex>1? `repeat(${tileIndex-1}, calc(100%/8)) ` : ``;
    let after = tileIndex<this.numberOfTiles? ` repeat(${this.numberOfTiles-tileIndex}, calc(100%/8))` : ``;
    hexContent.style.gridTemplateRows = before + '100%' + after;


    // instantly switch the data from taking up all remaining columns of g32 to only taking up one column
    ani.mate( g32tile.querySelectorAll(".g32r"), ["g32r_b16","g32r_b1"], 0.0 );

    // 0  expand/collapse height of this tile (g32l, g32rr, and g32s)
    console.log("Now, will toggle from g32 classes "+Array.from(g32tile.classList).join(", "));
    ani.mate( [g32tile], ["g32_b16","g32_b1"], 0.5 );
    ani.tic(0.5);

    // parallel animations
    // (some require custom parsing for each, so we turn of ani.series)


    // 1  hide/show offset labels 0-F
    ani.mate(  this.panelContent.querySelectorAll(".hex_header > div > .hex_header_offset_label"), ["hex_header_offset_label_b16","hex_header_offset_label_b1"], 2.5 );
    // 1  reposition the g32_items
    g32tile.querySelectorAll("div > .g32_item").forEach( d => ani.mate( [d], ["g32_item_b16","g32_item_b1",...["_b16","_b1"].map(e=>d.getAttribute(`data-gridclass`)+e)], 2.5)  );

    // 2  fade in/out the extra offsets
    ani.mate( g32tile.querySelectorAll(".g32l > .g32l_offset_sometimes"), ["g32l_offset_sometimes_b16", "g32l_offset_sometimes_b1"], 2.5);

    // 3  base labels, "hex" and "binary"   [ parallel w/ above ]
    ani.mate(
    this.panelContent.querySelectorAll(".hex_header > div > .hex_header_base_label"), ["hex_header_base_label_b16","hex_header_base_label_b1"], 2.5 );
    ani.tic(2.5);



    // // 3  expand/collapse the g32b (binary representation) column  [ parallel w/ below ]
    // ani.mate( [this.panelContent], ["panel_content_b16","panel_content_intermediate"], 2 );
    // ani.tic(2);


    // 5  expand/collapse the g32s (svg) column
    // ani.mate( [this.panelContent], ["panel_content_intermediate","panel_content_b1"], 1 );
    ani.mate( [this.panelContent], ["panel_content_b16","panel_content_b1"], 1.5 );
    ani.tic(1.5);

    // 4  change the coloring of the byte
    // foreground
    g32tile.querySelectorAll("div > .g32_item").forEach(d => ani.mate( [d], [`fg_bp${d.getAttribute('data-bitplane')}`], 1.5 )  );
    // background
    ani.mate( g32tile.querySelectorAll(".g32bg"), ["g32bg_b16","g32bg_b1"], 1.5 );
    ani.tic(1.5);

    // show/hide the svg
    ani.mate( g32tile.querySelectorAll(".g32s"), ["g32s_b16","g32s_b1"], 1.5 );
    ani.tic(1.5);

    this.panelContent.setAttribute("data-mode", newMode);


  }
  // generateBitplaneView(parent, data, tileIndex)
  // animate1to16(){

  // }

  animateDecomp(source, destination){


    // ---------------------------------------------------------------
    // define the functions that will beused frequently for animation:



    // Reducing those to the unique actions:

    // copy div, make its units rem, make larger with transform origin at reight or left
    function clone(node){
      var mover = node.cloneNode(true);
      mover.style.position = "absolute";
      var nodeBbox = node.getBoundingClientRect();
      // mover.style.perspective = `100px`;
      // mover.style.perspectiveOrigin = `100px`;
      mover.style.width = nodeBbox.width+"px";
      mover.style.height = nodeBbox.height+"px";
      mover.style.transform = `translate3D(${nodeBbox.x }px, ${nodeBbox.y }px, 0px)`;
      mover.style.zIndex = "100";
      mover = page.appendChild(mover);
      return mover;
    }

    // convert to binary
    function convertToBinary(mover){
      var hexToDec = {'0':0, '1':1, '2':2, '3':3, '4':4, '5':5, '6':6, '7':7, '8':8, '9':9, 'A':10, 'B':11, 'C':12, 'D':13, 'E':14, 'F':15};
      mover.innerHTML = binar(Array.from(mover.innerHTML).reverse().reduce((s,d,i)=>s+=hexToDec[d]*(16**i),s=0),8);
    }

    // split into 2 MSBs and 6 LSBs

    // highlight n bytes from left to right (sometimes wrapping around)
    function highlight(node){
    }

    // decrement visible n in sync with other things

    // move across screen and resize
    function move(node){
      var nodeBbox = node.getBoundingClientRect();
      // mover.style.perspective = `100px`;
      // mover.style.perspectiveOrigin = `100px`;
      mover.style.width = nodeBbox.width+"px";
      mover.style.height = nodeBbox.height+"px";
      mover.style.transform = `translate3D(${nodeBbox.x - (left?nodeBbox.width:0)}px, ${nodeBbox.y }px, 0px)`;
    }

    // replace destination styling with mover's (just colors?)

    // fade out movers and remove

    // take a div and make a stack of n duplicates of them as movers

    // swap bytes (just movement?)


    // move to left of offsets, scroll page, move right to specific byte
    function scroll(panel){
      panel.scrollToTile(Math.floor(offset/32)+1);
    }

    // pick up a group of bytes in unison

    // bit shift left / multiply by 2

    // ---------------------------------------------------------------

    //TODO: move this into its own class
    this.animation = {
      elements: [],
      // format for each element of stack:
      // [
      //   {
      //     'keyframeName':'keyframeName1',
      //     'element':node1,
      //     'steps': [
      //       {'percent': 0,
      //        'props':{'prop': 'prop1','value':value1},
      //       }
      //       {'percent': 5,
      //        'props':{'prop': 'prop1','value':value1},
      //       }
      //     ],
      //     baseDuration: 1,
      //     duration: 1, /* this'll be the current duration */
      //     easingFunction: 'linear',
      //     progress: 0
      //   },
      //   ...
      // ]
      complete: false,
      paused: false,
      skipping: false,
      durationScale: 1,
      userDurationScale: 1,
      skippingDurationScale: 0.01,

      initElement: function(e){
        // initialize and build keyframes,
        // but do not actually assign the animation to the HTML node yet

        // parse some properties, especially ones likely to not be filled out.
        if (e.direction==undefined) e.direction = 'forwards';
        if (e.baseDuration==undefined) e.baseDuration = 1;
        if (e.duration==undefined) e.duration = e.baseDuration;
        if (e.easingFunction==undefined) e.easingFunction = "linear";
        if (e.progress==undefined) e.progress = 0;
        if (e.kind==undefined) e.kind = "keyframes"; // otherwise could be scroll
        if (e.name==undefined) e.name = "__ animation"; // 

        this.elements.push( e );

        // create the keyframe CSS (assuming we have the spes already)
        // and add it to stylesheets
        var kf = this.buildKeyframe( e );

        document.styleSheets[0].insertRule( kf );
        this.debug.keyframes += kf+'\n\n'


      },
      startElement: function(e){
        // depends on animation type
        switch (e.kind){
          default:
          case "keyframes":

            // actually assign it
            e.element.style.animation = `${e.keyframeName} ${e.duration}s ${e.easingFunction} ${e.direction}`;
            e.startTime = Date.now();
            // what to do when this finishes animating
            // (the logistics stuff.. we may do more element-specific stuff with additional event listeners, elsewhere)
            e.element.addEventListener("animationend", ()=>{

              

              // assign the current animated properties
              var computedStyles = window.getComputedStyle(e.element);
              var styleStr = ``;
              for (let [key, value] of Object.entries(e.allProps)){
                // e.element.style.setAttribute(
                //     key, computedStyles.getPropertyValue(key)
                //   );
                // or:
                // styleStr+=`${key}: ${value}; `;
                styleStr+=`${key}: ${computedStyles.getPropertyValue(key)}; `;
              }



              
              e.element.setAttribute('style', styleStr); //(?)
              // console.log(`Assigning the following to ${e.name}:\n${styleStr}`);
              // console.log(e.element);

              
              // remove animation (?)
              e.element.style.animation = ``;

              // find and delete this keyframe to clean up the stylesheet
              for (let i=0; i<document.styleSheets[0].cssRules.length; i++) {
                if ( document.styleSheets[0].cssRules[i].name === e.keyframeName ){
                  document.styleSheets[0].deleteRule(i);
                  break;
                }
              }

              // delete this element from this.elements
              // delete e;

              // delete html dom node
              if (e.deleteNodeWhenDone) e.element.remove();

            });

            break;

          case "scroll":
            // .progress
            e.startTime = Date.now(); // in msec

            function doScroll(animEl, nodeEl){
              console.log("do scroll... "+Date.now());
              // get current "percentage"
              var perc =  (Date.now() - animEl.startTime)/(animEl.duration*10); // incorporates 100 for percentage
              var current = 0;
              for (let i =0; i<animEl.steps.length; i++){
                if (animEl.steps[i].done){
                  0; // if we already did this, skip it
                } else{
                  if ( perc > animEl.steps[i].percent ){
                    nodeEl.scrollTo({top: animEl.steps[i].props['scroll'], behavior: 'instant'});
                    animEl.steps[i].done = true;
                    console.log("Scrolled to "+animEl.steps[i].props['scroll']);
                    // if it's the last one
                    if ( i == animEl.steps.length-1){ 
                      return 0;
                    } else {
                      setTimeout( doScroll( animEl, nodeEl), 200);
                    }

                  }
                }
              }
            }
            
            setTimeout( doScroll(e, e.element), 200);

          break;
        }

      },
      buildKeyframe: function(e){
        // we'll track the running props so that, if there's no change, we will use the last one
        // but if we say so, we won't assign the runningProp,
        // and css will take over and smoothly animate between.
        var runningProps = {};
        e.allProps = {}; // will be used later

        var keyframes = `@keyframes ${e.keyframeName} {\n`;

        // add percent and props for each step
        var totalSteps = e.steps.length;

        // first check if we actually go up to 100%,
        // if not, duplicate the last but with a percent of 100.
        var foundPercent =  e.steps[totalSteps-1]['percent'];
        var tol = 0.01; //tolerance
        if ( (foundPercent > 100+tol) || (foundPercent < 100-tol)){
          e.steps.push({...e.steps[totalSteps-1], 'percent':100});
          totalSteps++;
        } else {
          e.steps[totalSteps-1]['percent'] = 100; // basically round it if it's close
        }
        // repeat for 0%?



        var stepsCSS = [];
        var lastPerc;

        for (let i=0; i<totalSteps; i++){

          var stepCSS = ``;
          let d = e.steps[i];
          // initialize w percent
          let perc, percStr;
          switch (typeof(d.percent)){
            case 'object':
              perc = Math.round(d.percent[0]*100)/100;
              percStr = d.percent.map(f=>""+(Math.round(f*100)/100)+"%").join(', ');
              break;
            
            case 'number':
            default:
              perc = Math.round(d.percent*100)/100;
              // if it's just one percentage and equal to the last, add a little fudge factor
              perc = (perc==lastPerc) ? perc+ 0.01 : perc;
              lastPerc = perc*1;
              percStr = ""+perc+"%";
              break;


          }
          stepCSS += `\n  /* Step ${i+1} of ${totalSteps} `;
          stepCSS += `     ${e.duration*0.01*perc}s of ${e.duration}s */`;
          stepCSS += `\n  ${percStr} {`;

          // get properties. overwrite the running if not null.
          var fillProps = {...runningProps};
          for (let [key, value] of Object.entries(d.props)){
            if (value==null) {
              delete fillProps[key];
              delete runningProps[key];
            } else {
              fillProps[key] = value;
            }
          }

          // now update the running props
          runningProps = {...runningProps, ...fillProps};
          // now that we have it up to date, go through and apply all props
          for (let [key, value] of Object.entries(runningProps)){
            stepCSS += `\n    ${key}: ${value}; `;
            e.allProps[key] = true; //save this
          }
          // save back to steps for future reference:
          e.steps[i] = {...e.steps[i], ...runningProps};

          // close this step
          stepCSS += `\n  }`;
          // console.log(stepCSS);

          keyframes += stepCSS;
          stepsCSS.push(stepCSS);

          // save running props for use later:
          e.runningProps = {...runningProps};
        }

        // close entire thing
        keyframes += `\n}`;

        e.keyframes = keyframes;
        e.keyframeStepsCSS = stepsCSS;
        // console.log(keyframes);
        return keyframes;

      },
      pause: function(){
        this.elements.forEach( d => {
          this.pauseElement( d );
        });
      },
      resume: function(){
        this.elements.forEach( d => {
          this.resumeElement( d );
        });
      },
      assignAnimation: function(e){
        // TODO: scale e.duration: ( this.skipping ? this.skipDurationScale : this.userDurationScale ) * e.duration
        let delay = -e.progress * e.duration;
        e.animation = `${e.duration}s ${e.easingFunction} ${delay}s ${e.keframeName}`;
      },
      pauseElement: function(e){
        // TODO: scale e.duration: ( this.skipping ? this.skipDurationScale : this.userDurationScale ) * e.duration
        let remainingTime = e.duration * ( 1 - e.progress );
        e.progress = e.progress + ( (Date.now() - e.startTime) / remainingTime );
        e.element.style.animationPlayState = "paused";
      },
      resumeElement: function(e){
        e.startTime = Date.now();
        e.element.style.animationPlayState = "running";
      },
      changeDurations: function(){
        this.elements.forEach( d=>{
          // update each element's durations in their objects:
          d.duration = d.baseDuration * ( this.skipping ? this.skipDurationScale : this.userDurationScale );
          // now update in DOM too:
          this.assignAnimation(d);

        })


      },
      toggleSkip: function(){
        if (!this.paused) this.pause();
        this.skipping = !this.skipping;
        // here we would update global duration, except we already use skip duration if skpping
        this.changeDurations();
        this.resume();

      },
      changeState: function(input){
        switch (input){
          case "space":
            if (!this.skipping) {
              this.paused ? this.resume() : this.pause();
              this.paused = !this.paused;
            } else {
              this.toggleSkip();
              this.paused = false;
            }
            break;
          case ">":
            if (!this.skipping) {
              this.toggleSkip();
              this.skipping = true;
            } else {
              if (this.paused) {
                this.resume();
                this.paused = false;
              }
            }
            break;
          case "duration":
            //TODO: update this.userDurationScale here
            if ( (!this.paused) && (!this.skipping) ){
              this.pause();
              this.changeDurations();
              this.resume();
            } else{
              this.changeDurations(); // should update in the object and in DOM...
              // while skipping, the DOM part should have no effect,
              // because there won't be a change in elements' durations
              // ( all will just set to skip duration )
            }
            break
        }
      },
      animationEndWrapper: function(){
        // other stuff goes here
        // maybe start the next keyframes...?

        // this checks if we are in a skipping state and running
        if ( this.skipping && !this.paused ){
          this.pause();
          this.paused = true;
        }

      },
      initDecomp: function(comp, decomp){
        // comp and decomp arguments are the compressed and decompressed panels
        // we create compContent and decompContent from their hex_content
        this.decomp = decomp;
        this.comp = comp;
        this.decompContent = decomp.panelContent.querySelector(".hex_content");
        this.compContent = comp.panelContent.querySelector(".hex_content");
        // console.log("initDecomp()");
        // console.log(this.compContent);

        // lock the comp and decomp panels from drag, resize, or maximize

        this.compIndex = 128; // first byte after LUT
        this.decompIndex = 0;

        this.colors = [
          [255,0,0],
          [255,255,0],
          [255,0,255],
          [0,0,255]
        ];
        this.bgColors = [
          [0,0,0],
          [85,85,85],
          [170,170,170],
          [255,255,255]
        ];
        this.fgColors = [
          [255,255,255],
          [255,255,255],
          [0,0,0],
          [0,0,0]
        ];
        this.modeNames = [
          "Copy",
          "RLE",
          "HISTORY",
          "LUT"
        ];
        this.operandNames = [
          " bytes",
          " times",
          " bytes",
          "LUT index"
        ];

        this.hexToDec = {
          '0':0, '1':1, '2':2,  '3':3,  '4':4,  '5':5,  '6':6,  '7':7,
          '8':8, '9':9, 'A':10, 'B':11, 'C':12, 'D':13, 'E':14, 'F':15
        };
        this.corner = '2ch';
        this.cornerUnits = 'ch'; // might help smooth animating of borderRadius, in future...


        var rnd = this.corner;
        var shp = "0"+this.cornerUnits;
        this.bblBoth = `${rnd} ${rnd} ${rnd} ${rnd}`,
        this.bblLeft = `${rnd} ${shp} ${shp} ${rnd}`,
        this.bblRight= `${shp} ${rnd} ${rnd} ${shp}`,
        this.bblNone = `${shp} ${shp} ${shp} ${shp}`;

        this.parallelize = true;; // move all divs in parallel (faster)
        this.riseTime = 0.15;
        this.staggerTime = 0.2;
        this.moveTime = 0.3;
        this.bblTime = Math.min(this.riseTime, this.staggerTime)/2;
        // this.detailsTime = 2.5;
        this.detailsTime = 5.5;
        this.scrollTime = 1; // time to give to scroll during details div. in sec here, mult by 1000 later for ms

        this.debug = {
          keyframes: '',
          log: '',
          header: ''
        };

        // set all decomp to invisible
        Array.from(this.decompContent.querySelectorAll("div .hex_g32 div .hex_byte")).forEach(d=>d.style.color = "var(--textColorTransparent)");

        // circle the words of the LUT.
        Array.from(this.compContent.querySelectorAll("div .hex_g32 div .hex_byte")).slice(0,128).forEach((d,i)=> {
          d.style.border = '2px solid';
          if (i%2) { // right side
            d.style.borderRadius = `0 ${this.corner} ${this.corner} 0`;
            d.style.borderLeft = "none";
          } else{    // left side of bubble
            d.style.borderRadius = `${this.corner} 0 0 ${this.corner}`;
            d.style.borderRight = "none";
          }

        });

        // begin iterations
        this.decompSpanCount = 0;
        this.decompSpan();

      },
      highlight: function(countdown, total, name){

        // from cloneAndMove: ---------------
        // First, highlight the fromDiv ???

        // var highlightName = `Mode_${this.mode}_highlight_${Date.now()}`;
        // var highlightKeyframe = `@keyframes ${highlightName} {
        //   0% {
        //     background: linear-gradient(to left, rgba(0,0,0,0) 50%, rgba(${this.modeColor},0.4) 50%) right;
        //     background-size: 200% 100%;
        //     background-position: right;
        //   }
        //   100% {
        //     background: linear-gradient(to left, rgba(0,0,0,0) 50%, rgba(${this.modeColor},0.4) 50%) right;
        //     background-size: 200% 100%;
        //     background-position: left;
        //   }
        // }`;
        // // insert into stylesheet at index 0
        // document.styleSheets[0].insertRule(highlightKeyframe);

        // // assign the base color for future reference
        // // (for ex, if this is a LUT )
        // fromDiv.setAttribute("data-base-color",`rgba(${this.modeColor},0.4)`);
        // // apply the animation ("forwards" might be important?)
        // fromDiv.style.animation = `${highlightName} 1s linear forwards`;

        // fromDiv.addEventListener("animationend", ()=>{});
        // ------------------------------

        // designed for highlighting multiple cells in series across the decomp hex_content
        // get the first decomp byte for this decomp span
        let g32d = hex( 32*(this.decompIndex>>5), 6 ); // get g32 group by floor dividing by 32 (>>5)
        let offsetd = hex( this.decompIndex, 6 );
        let byt = this.decompContent.querySelector(`div > #g0x${g32d} div #byte_${offsetd}`);

        // console.log(`Decomp index ${this.decompIndex}:`);
        // console.log(byt);

        // insert into stylesheet at index 0
        // document.styleSheets[0].insertRule(highlightKeyframe);

        // apply the animation ("forwards" might be important?)
        byt.style.animation = `${name} ${2/total}s linear forwards`;
        // if (countdown == total) byt.style.borderLeft = "2px solid black";
        // if (countdown == total) byt.style.borderLeft = "2px solid black";

        byt.addEventListener("animationend", ()=>{

          // console.log("LEVEL 2 ( "+countdown+" down of "+total+" ) finished\n");


          countdown--;
          this.decompIndex++;



          if (countdown==0){
            // close up if this was the last one.

            // find and delete this keyframe to clean up the stylesheet
            // for (let i=0; i<document.styleSheets[0].cssRules.length; i++) {
            //   if ( document.styleSheets[0].cssRules[i].name === name ){
            //     document.styleSheets[0].deleteRule(i);
            //     break;
            //   }
            // }
            // // remove animation (?)
            // byt.style.animation = ``;

            // increment the indices appropriately and then run next (recursive)

            switch(this.mode){
              case 0:
                this.compIndex += 1+this.n;
                // this.decompIndex += n;
                break;
              case 1:
                this.compIndex += 2;
                // this.decompIndex += n;
                break;
              case 2:
                this.compIndex += 3;
                // this.decompIndex += n;
                break;
              case 3:
                this.compIndex += 1;
                // this.decompIndex += 2;
                break;
            }

            this.decompSpanCount++;
            console.log("this, at end of clonendMove");
            console.log(this);

            if (this.compIndex < this.comp.source.data.length) this.decompSpan();

          } else{
            // run this again for the next one.
            this.highlight(countdown, total, name);
          }

        });
      },
      cloneAndMove: function(){
        // console.log(`Starting cloneAndMove with ${this.moveBuffer.length} remaining bytes in moveBuffer`);

        // some setup
        // bubble/rounded corners shorthands
        // left means rounded on left side, right means rounded on right side
        // later we say "expand" left or right, that means going "sharp" in those directions
        var bblBoth = this.bblBoth;
        var bblLeft = this.bblLeft;
        var bblRight = this.bblRight;
        var bblNone = this.bblNone;

        var lift = "20px";
        var riseTime = this.riseTime;
        var staggerTime = this.staggerTime;
        var stagger = 0;
        var move1920 = 2;
        var moveTime = this.moveTime;
        var bblTime = this.bblTime; // should always be <= riseTime and <= staggerTime
        var scrollTime = ( (this.mode==2) && this.willScrollDecomp) ? 1 : 0;
        
        

        // get the source divs
        // It will act on this.moveBuffer, popping off each batch
        // if not a parralelized span, each batch will only conntain 1 div
        var fromDivs = this.moveBuffer.pop();

        //
        //  A  lifting all from divs
        //
        var totalFromDivs = fromDivs.length;
        this.batchSize = fromDivs.length;
        var totalStagger = ((totalFromDivs-1)*staggerTime);
        var totalTime = totalStagger + riseTime; // before move time, which we have to calculate.
        totalTime += scrollTime; // scroll time
        totalTime += totalStagger +  moveTime + riseTime + staggerTime + bblTime; // moving and dropping and bubbling
        // totalStagger + riseTime + scrollTime + stagger + moveTime + riseTime + staggerTime + bblTime
        // totalStagger + riseTime + scrollTime + totalStagger + moveTime + riseTime

        var maxMoveTime = 0;

        var positionWillScrollTo = 0;


        //
        var checkToDiv = this.decomp.checkOffsetPosition( this.decompIndex, 2, 2 );
        positionWillScrollTo = checkToDiv.position - checkToDiv.topMargin;
        ///
        var fromDiv;

        // set scroll
        if ( (this.mode==2) && this.willScrollDecomp){
          
          setTimeout( ()=>{
              console.log(`Mode 2 HISTORY: scrolling from ${this.decompContent.scrollTop} to ${positionWillScrollTo}.`);
              this.decompContent.scrollTo({top: positionWillScrollTo, behavior: 'smooth'});
            },
            (totalStagger +  riseTime )*1000
          );
        }

        var anims = [];

        for (let i=0; i<fromDivs.length; i++){ // loop A //////////////////////////////////////////////////////////////

          fromDiv = fromDivs[i];
          
          // style the from div, if necessary
          // if it's mode 0 or the first byte of mode 1
          if ( (this.mode==0) || ( (this.mode==1) && (i==0) ) ){

            let fromDivAnim = new Animation();
            fromDivAnim.name = "fromDiv animation";
            fromDivAnim.element = fromDiv;
            fromDivAnim.baseDuration = totalTime;
            fromDivAnim.easingFunction = "ease";
            fromDivAnim.keyframeName = `fromDivStyle_${i}_${Date.now()}`;
            fromDivAnim.steps = [];
            
            
            let fromDivStyle = window.getComputedStyle(fromDiv);
            let origs = {
              'color':fromDivStyle.getPropertyValue('color'),
              'background-color':fromDivStyle.getPropertyValue('background-color'),
              'border':fromDivStyle.getPropertyValue('border'),
              
            }

            // instant jump to cell style
            fromDivAnim.steps = [
              { 'percent': [0, 100*stagger/totalTime], 'props': { ...origs }  },
              // when the mover div appears, coming out of this, instantly* make it the same color: *actually 0.01%
              { 'percent': (100*stagger/totalTime)+0.01, 'props': { 
                'background-color': `rgba(${this.bgColors[this.mode]},1)`,
                'color': `rgba(${this.fgColors[this.mode]},1)`,
                'border-radius': bblBoth} },
              // quickly morph to fit previous, stopping <bblTime> after the stagger
              { 'percent': [100*(stagger+bblTime)/totalTime, 100*(stagger+staggerTime)/totalTime], 'props': {
                'border-radius': bblRight
              } },

            ];

            // if mode 0, we expand for the next cell next
            if (this.mode==0) fromDivAnim.steps.push(
              // quickly morph to fit next
              { 'percent': 100*(stagger+staggerTime+bblTime)/totalTime, 'props': {
                'border-radius': ( this.axbi==1 ) ? bblRight : bblNone
              } }
            );

            
            this.initElement( fromDivAnim );
            anims.push(fromDivAnim);
            // console.log(fromDivAnim.keyframes);
         }



          // decrement the visible n:
          // HACK: this isn't really synced with animation so can't be paused
          if (this.mode!=3){
            setTimeout( ()=>{
            try {
              let ndiv = this.details.querySelector("div > .n");
              // console.log(ndiv);
              this.ni-=1;
              let nattempt = ndiv.innerHTML.replace(/[0-9A-F]{2}/i,hex(this.ni,2));;

              ndiv.innerHTML = nattempt; // replaces hex
              } catch(err){
                console.log("error:" +err);
              }
              // one liner
              // this.details.querySelector("div > .n").innerHTML = this.details.querySelector("div > .n").innerHTML.replace(/[0-9A-F]{2}/i,hex(this.ni--,2));
            }, stagger*1000);
          }


          // Mover and its Shadow
          //
          // create elements
          let fromDivBbox = fromDiv.getBoundingClientRect();

          // cloning it at the same position
          let mover = fromDiv.cloneNode();
          let shadow = fromDiv.cloneNode();
          // let mover = document.createElement("div");
          // let shadow = document.createElement("div");
          mover.style.border = 'none';
          shadow.style.border = 'none';
          
          mover.style.opacity = "0";
          mover.innerHTML = fromDiv.innerHTML+"";
          shadow.style.opacity = "0";

          mover = document.getElementById("animationTop").appendChild( mover ); // actually add it to page
          shadow = document.getElementById("animationTop").appendChild( shadow ); // actually add it to page
          //


          // track this animation, for pausing, etc
          let moverAnim = new Animation();
          moverAnim.element = mover;
          moverAnim.baseDuration = totalTime;
          moverAnim.duration = totalTime;
          moverAnim.easingFunction = "ease";
          moverAnim.deleteNodeWhenDone = true;
          moverAnim.keyframeName = `moverMove_${i}_${Date.now()}`;

          var moverOrig = {
            'width': fromDivBbox.width+"px", 'height': fromDivBbox.height+"px", 'border-radius': bblBoth,
              'position': 'absolute', 'opacity': "0", 'z-index': "102",
              'transform': `translate3D(${fromDivBbox.x}px, ${fromDivBbox.y }px, 0px)`,
              'background-color': `rgba(${this.bgColors[this.mode]},1)`, 'color': `rgba(${this.fgColors[this.mode]},1)`
          }

          // moverAnim.steps = [
          //   { 'percent':0, 'props': {
          //     ...moverOrig}
          //   }
          // ];

          let shadowAnim = new Animation();
          shadowAnim.element = shadow;
          shadowAnim.baseDuration = totalTime;
          shadowAnim.easingFunction = "ease";
          shadowAnim.deleteNodeWhenDone = true;
          shadowAnim.keyframeName = `shadowMove_${i}_${Date.now()}`;
          // more modular but not working?
          // shadowAnim.steps = [ { ...moverAnim.steps[0], 'z-index': "101",  'background-color': `rgba(0,0,0,0.8)` } ];
          var shadowOrig = { ...moverOrig, 'z-index': "101",  'background-color': `rgba(0,0,0,0.8)` };

          // shadowAnim.steps = [
          //   { 'percent':0, 'props': {
          //     'width': fromDivBbox.width+"px", 'height': fromDivBbox.height+"px", 'border-radius': bblBoth,
          //     'position': 'absolute', 'opacity': "0", 'z-index': "101",
          //     'transform': `translate3D(${fromDivBbox.x}px, ${fromDivBbox.y }px, 0px)`,
          //     'background-color': `rgba(0,0,0,0.8)`}
          //   }
          // ];



          // getting the location of destination div
          // note that it's not in the right position when we build these,
          // if we are going to scroll, so we have to check
          // where it will be once we scroll.

          let toDiv = this.decompContent.querySelector(`div > #g0x${hex( 32*((this.decompIndex+i)>>5), 6 )} div #byte_${hex( (this.decompIndex+i), 6 )}`);
          let toDivBbox = toDiv.getBoundingClientRect();
          //
          let hcTop = this.decompContent.getBoundingClientRect().y;
          let toDivY;
          if (this.willScrollDecomp){
            checkToDiv = this.decomp.checkOffsetPosition( this.decompIndex+i, 2, 2 ); //assuming this is up to date
            toDivY = hcTop + ( checkToDiv.position - positionWillScrollTo );
          } else {
            toDivY = toDivBbox.y;
          }

          // toDivYs.push(toDivY);

          // hc.y + topMargin;
          // for each: hcTop.y + ( thisToDiv_.position_from_checkOffsetPosition - positionWillScrollTo );

          // and moving the clone to location of destinationDiv

          // first determine the distance it's moving and make a reasonable travel speed:
          // let travelDist = (((fromDivBbox.x-toDivBbox.x)**2)+((fromDivBbox.y-toDivY)**2))**0.5;
          // // based on 2sec for travel across width of a 1080/1920 screen,
          // // but clamp the time... esp if we're picking up and scrolling for mode 2
          // // let travelRatio = Math.min( travelDist/1920, 1);
          // let travelRatio = 1;
          // let travelTime = move1920*travelRatio; // +1sec; 0.5 each for raising and lowering div into place
          
          // moveTimes.push(travelTime);
          // maxMoveTime = Math.max( travelTime, maxMoveTime ); // track the highest (not necessarily the 1920 time)

          let scrollEndTime = totalStagger+riseTime+scrollTime+stagger; // includes stagger

          // new:
          // only thing differing s the lift height:
          [ [moverAnim, lift, moverOrig], [shadowAnim, "0px", shadowOrig] ].forEach(d=>{

            d[0].steps = [
              // rise //////
              // wait for stagger
              { 'percent': [0, 100*stagger/totalTime], 'props': {...d[2]} },
              // rise
              { 'percent': 0.01+(100*(stagger)/totalTime), 'props': {
                'opacity': '1',
                }
              },
              // rise up and remain until scroll break ////
              { 'percent': [100*(stagger+riseTime)/totalTime, 100*(scrollEndTime)/totalTime], 'props': {
                'transform': `translate3D(${fromDivBbox.x}px, ${fromDivBbox.y }px, ${d[1]})`}
              },
              // move, drop, bubble //////
              // begin move
              { 'percent': 100*(scrollEndTime+moveTime)/totalTime, 'props': {
                'transform': `translate3D(${toDivBbox.x}px, ${toDivY }px, ${d[1]})`,
                'width': `${toDivBbox.width}px`, 'height': `${toDivBbox.height}px` } },
              // end move/begin drop
              { 'percent': 100*(scrollEndTime+moveTime+riseTime)/totalTime, 'props': {
                'transform': `translate3D(${toDivBbox.x}px, ${toDivY }px, 0px)`, 'opacity': "1"} },
              // make invisible
              { 'percent': 0.01+(100*(scrollEndTime+moveTime+riseTime)/totalTime), 'props': {
                'opacity': "0"} },
              // end drop/begin bubble
              // { 'percent': 100, 'props': { } },

            ];
          });


          // style the toDiv

          let toDivAnim = new Animation();
          toDivAnim.name = "toDiv animation";
          toDivAnim.element = toDiv;
          toDivAnim.baseDuration = totalTime;
          toDivAnim.easingFunction = "ease";
          toDivAnim.keyframeName = `toDivStyle_${i}_${Date.now()}`;
          toDivAnim.steps = [];

          let toDivStyle = window.getComputedStyle(toDiv);
          let torigs = {
            'color':toDivStyle.getPropertyValue('color'),
            'background-color':toDivStyle.getPropertyValue('background-color'),
            'border':toDivStyle.getPropertyValue('border'),
            'opacity':'0'
          }

          let finalBbl = bblNone;
          if (( this.axbi==1 ) && ( this.axbi==this.axb )){
            finalBbl = bblBoth;
          } else {
            if ( this.axbi==1 ) finalBbl = bblRight;        // last
            if ( this.axbi==this.axb ) finalBbl = bblLeft;  // first
          }

          // instant jump to cell style
          toDivAnim.steps.push(...[
            { 'percent': [0, 100*(scrollEndTime+moveTime+riseTime)/totalTime], 'props': { 
              ...torigs} },
            // begin bubble
            // instantly change color and add full bubble
            { 'percent': 0.01+(100*(scrollEndTime+moveTime+riseTime)/totalTime), 'props': {
              'opacity':"1",
              'background-color': `rgba(${this.bgColors[this.mode]},1)`,
              'color': `rgba(${this.fgColors[this.mode]},1)`,
              'border-radius': bblBoth },
            },
            

            // quickly morph to fit previous
            { 'percent': [
                100*(scrollEndTime+moveTime+riseTime+bblTime)/totalTime,
                100*(scrollEndTime+moveTime+riseTime+staggerTime)/totalTime
              ],  'props': {
              'border-radius': ( this.axbi==this.axb ) ? bblBoth : bblRight
            } },

            // morph to fit next
            { 'percent': 100*(scrollEndTime+moveTime+riseTime+staggerTime+bblTime)/totalTime, 'props': {
              'border-radius': finalBbl
            } },


          ]);
          //TODO: if we have an output byte coming after, bubble it up to match that one:
          // (currently all just bubble up at very end)
          
          this.axbi--; // countdown
          stagger += staggerTime;
          
          // now that we have all the anims' steps
          this.initElement( moverAnim );
          this.initElement( shadowAnim );
          this.initElement( toDivAnim );
          // console.log("toDiv:");
          // console.log(toDivAnim);
          // console.log(toDivAnim.keyFrames);

          anims.push(...[ moverAnim, shadowAnim, toDivAnim]);


          // toDivs.push(toDiv);
          // movers.push(mover);
          // shadows.push(shadow);



        }; // fromDivs for  A end

        // anims.forEach( (d,i) => {
        //     console.log(d.keyframes);
        //   }
        // );

        anims.forEach( (d,i) => {
          this.startElement( d );
        });


        anims[anims.length-1].element.addEventListener("animationend", ()=>{

          // then increment this.decompIndex++;
          // this.decompIndex += forDivs.length;
          // this.decompIndex += this.axb; // number of bytes (a) x number of times (b)
          this.decompIndex += this.batchSize;
          // Replace styles of hex_bytes in hex_content with those of the clones
          // (just background and font being visible? maybe borders?)
          // toDiv.style.color = 'var(--textColor)';
          // toDiv.style.background = `rgba(${this.modeColor.map(d=>d*0.25)},1)`;

          // toDiv.style.backgroundColor = `rgba(${this.bgColors[this.mode]},1)`;
          // toDiv.style.color = `rgba(${this.fgColors[this.mode]},1)`;
          // var blefts=['0','0'], brights=' 0 0 ';
          // if (this.firstIncomplete){
          //   blefts = [crnr,crnr];
          //   this.firstIncomplete = false;
          // }
          // if (this.moveBuffer.length == 0) brights = ` ${crnr} ${crnr} `;
          // toDiv.style.borderRadius = blefts.join(brights);
          // console.log(`\n\n\n\ntodiv borderRadius:${blefts.join(brights)}\n\n\n\n`);


          // fade out/remove clone elements
          // mover.remove();
          // shadow.remove();

          // if (this.mode!=3) ndiv.style.animation = ``; // remove the bulge animation

          // if this is the end of this decomp span
          if (this.moveBuffer.length > 0){
            // console.log("this.moveBuffer.length > 0, calling this.cloneAndMove()");
            // console.log("continue this.cloneAndMove() for next byte of this span");
            // continue moving the next byte within this same span
            this.cloneAndMove();

          } else {

            // style the cmd byte if we haven't already (shouldn't have):
            // let cmd = this.compContent.querySelector(`div > #g0x${hex( 32*(this.compIndex>>5), 6 )} div #byte_${hex( this.compIndex, 6 )}`); // actual div node
            // if (cmd.style.backgroundColor != `rgba(${this.bgColors[this.mode]},1)`){
            //   cmd.style.backgroundColor = `rgba(${this.bgColors[this.mode]},1)`;
            //   cmd.style.color = `rgba(${this.fgColors[this.mode]},1)`;

            //   var cmdbleft=[crnr, crnr], cmdbright=' 0 0 ';
            //   if (this.mode == 3) cmdbright = ` ${crnr} ${crnr} `; // mode 3 has no following bytes in its span
            //   console.log(`\n\n\n\ncmd borderRadius:${cmdbleft.join(cmdbright)}\n\n\n\n`);
            //   cmd.style.borderRadius = cmdbleft.join(cmdbright);
            // }
            // console.log("length of buffer is: "+this.moveBuffer.length+"; move on to next decompSpan()");

            // increment the comp index
            // (note that we already incremented by 1 from the command byte)
            switch(this.mode){
              case 0:
                this.compIndex += this.n+1;
                // this.decompIndex += n;
                break;
              case 1:
                this.compIndex += 1+1;
                // this.decompIndex += n;
                break;
              case 2:
                this.compIndex += 2+1;
                // this.decompIndex += n;
                break;
              case 3:
                this.compIndex += 0+1;
                // this.decompIndex += 2;
                break;
            }

            // remove all previous animations:
            Array.from(document.body.querySelectorAll(".decomp_animation_details")).forEach(d=>d.remove());


            // see if we need to return the hex_content positions before the next span:
            // bc we possibly got messed up by a previous LUT mode scroll
            var cmdOffsetPos = this.comp.checkOffsetPosition( this.compIndex, 2, 2 );
            var cmdy;
            if (!cmdOffsetPos.inView) {
              cmdy = cmdOffsetPos.position-cmdOffsetPos.topMargin; // for the details div
              this.compContent.scrollTo({top: cmdy, behavior: 'smooth'});

            }

            // Do the same for decomp... although we still have the problem with decomp where it might not look clear if
            // history mode bytes are higher up than the current decompIndex
            var outOffsetPos = this.decomp.checkOffsetPosition( this.decompIndex, 2, 2 );
            if (!outOffsetPos.inView) this.decompContent.scrollTo({top: outOffsetPos.position-outOffsetPos.topMargin, behavior: 'smooth'});

            //HACK: a somewhat arbitrary time to wait for panel(s) to scroll
            setTimeout( ()=>{
              // console.log(`/*\n${this.debug.header}*/\n${this.debug.keyframes}`);
              let b78 = Array.from(Array(78).keys()).map(d=>"-").join("");
              this.debug.log += `/*${b78}\n${this.debug.header}\n${b78}*/\n${this.debug.keyframes}`;
              if (this.compIndex < this.comp.source.data.length) this.decompSpan();
            }, (!cmdOffsetPos.inView || !outOffsetPos.inView) ? this.scrollTime*1000 : 0)

            // // begin the next span
            // if (this.compIndex < this.comp.source.data.length) this.decompSpan();

          }

         
        }); // end of A end animation end

      },

      decompSpan: function(){

        // mode-specific
        switch(this.mode){
          case 0: // copy
            // highlight the following n bytes of input,
            // decrementing the visible n as we go
            // (maybe this is also copying the nodes... maybe mask a highlight appearing left-to-right?)

            // move them across the screen to decomp

            // replace decomp's equivalent bytes' style with that of these ones
            // fade these mover nodes out

            // ------------------------------------------
            // var mover = node.cloneNode(true);
            // mover.style.position = "absolute";
            // var nodeBbox = node.getBoundingClientRect();
            // // mover.style.perspective = `100px`;
            // // mover.style.perspectiveOrigin = `100px`;
            // mover.style.width = nodeBbox.width+"px";
            // mover.style.height = nodeBbox.height+"px";
            // mover.style.transform = `translate3D(${nodeBbox.x }px, ${nodeBbox.y }px, 0px)`;
            // mover.style.zIndex = "100";
            // mover = page.appendChild(mover);
            // return mover;

            break;

          case 1: // RLE
            // highlight the follwing single byte

            // make a stack of n copies of that byte?
            // move each copy into decomp
            // decrementing the visible n as we go

            // replace decomp's equivalent bytes' style with that of these ones
            // fade these mover nodes out

            break;

          case 2: // history
            // highlight the following 2 bytes

            // swap them

            // move this address mover div to just left of the <decomp> offsets, at the top (or just middle?)
            // scroll the <decomp> hex content to the position of this address/offset
            // move to the right, touching the left side of this address's byte

            // highlight along the next n bytes
            // decrementing the visible n as we go

            // pick these up as a group
            // scroll to current position of decomp

            // place them in order

            // replace decomp's equivalent bytes' style with that of these ones
            // fade these mover nodes out

            break;

          case 3: // LUT
            // keep n as binary
            // bit shift left by adding a zero and sliding it in
            // show a "x2" as well?

            // move this address mover div to just left of the <comp> offsets, at the top (or just middle?)
            // scroll the <comp> hex content to the position of this address/offset
            // move to the right, touching the left side of this address's byte

            // highlight along the next 2 bytes

            // pick these up as a group
            // scroll to current position of decomp

            // place them in order

            // replace decomp's equivalent bytes' style with that of these ones
            // fade these mover nodes out

            break;

        }

        // ---------------------------------------------------------------
        //
        // LEVEL 1
        // Intitialize and show mode details





        // set more details based on the current command byte
        //
        this.cmdVal = this.comp.source.data[this.compIndex]; // get actual data value
        this.cmdHex = hex( this.cmdVal, 2 ); // convert value to hex
        this.cmdBin = binar( this.cmdVal, 8 ); // convert to binary
        this.mode = (this.cmdVal & 0b11000000) >> 6; // 2 MSBs are command mode
        this.n = this.cmdVal & 0b00111111; // 6 LSBs are detail
        this.ni = this.n*1; // to be used for visual decrementing later
        // get address; only used for modes 2 or 3
        if (this.mode==2) this.address = this.comp.source.data[this.compIndex+1] | (this.comp.source.data[this.compIndex+2] << 8);
        if (this.mode==3) this.address = this.n << 1;
        this.numberAddedToDecomp = (this.mode==3) ? 2 : this.n; // number of bytes that will be added to decomp data (not needed?)
        this.modeColor = this.bgColors[this.mode]; // color of this mode

        
        this.debug.header = `------------\n Decomp span ${this.decompSpanCount}\n mode ${this.mode}\n n ${this.n}\ncomp index ${this.compIndex}\ndecomp index ${this.decompIndex}\n------------\n`;
        // console.log(this.debug.header);


        // console.log(this);

        // Create the Details div, a grid that will animate to show the breakdown of the command byte
        //
        // get the command byte html div so we can find its properties and line up our details html div to it
        let cmd = this.compContent.querySelector(`div > #g0x${hex( 32*(this.compIndex>>5), 6 )} div #byte_${hex( this.compIndex, 6 )}`); // actual div node

        let cmdBbox = cmd.getBoundingClientRect();
        // set up dimensions
        // y will be the new "scrolled" y position if we determined we will scroll
        // (it takes a bit to scroll so the bounding box won't immediately be up-to-date)
        let w = cmdBbox.width, h = cmdBbox.height, x = cmdBbox.x, y = cmdBbox.y;
        let ww = w*1.5;
        let wl = 5*w; // width for "labels"
        let wll = wl;

        // string versions, easier to change units and stuff:
        var wh = w/2+"px";
        // wh = "1fr";
        var wlls = wll+"px";
        wlls = "1fr";
        var ww2s = ww*2 + "px";
        ww2s = "1fr";

        // let xl = x+w-(wl+(2*ww)); // x when fully expanded left
        let xl = cmdBbox.x+w;
        // create a new div that will walk through the process for this command mode
        var details = document.createElement("div");
        // details.style.gridTemplateColumns = `0px ${wh} ${wh} 0px 0px 0px 0px`;
        // details.style.gridTemplateRows = `0px ${h}px 0px 0px 0px 0px 0px 0px 0px`;

        var runningColumns = `0px 0px 0px 0px 0px 0px 0px 0px`; // this shouldn't be necssary...
        var runningTransform = `translate3D(${ Math.round(xl) }px, ${ Math.round(y) }px, 0px)`;
        details.style.transform = runningTransform;
        details.style.height = cmdBbox.height+"px";
        // details.style.border = `2px solid rgb(${this.fgColors[this.mode]})`;
        details.style.backgroundColor = `rgba(${this.bgColors[this.mode]},1)`;
        details.style.color = `rgba(${this.fgColors[this.mode]},1)`;

        details.classList.add("decomp_animation_details");
        this.details = document.getElementById("animationTop").appendChild(details);
        // this.details = details;

        //
        var cmd1 = this.compContent.querySelector(`div > #g0x${hex( 32*((1+this.compIndex)>>5), 6 )} div #byte_${hex( (1+this.compIndex), 6 )}`);
        var cmd2 = this.compContent.querySelector(`div > #g0x${hex( 32*((2+this.compIndex)>>5), 6 )} div #byte_${hex( (2+this.compIndex), 6 )}`);

        // now fill out the details div with contents.
        // let bgc = `background-color: rgba(${this.modeColor.map(d=>d*0.25)},1); `;
        let bgc = `background-color: rgba(${this.bgColors[this.mode]},1); color: rgba(${this.fgColors[this.mode]},1); `;
        let clsnm = "decomp_animation_details_item";
        let bbl = 'div class="bubbleCell">';

        // Animation of details div
        // see how many steps the animation will go through:
        var total; // total steps
        switch(this.mode){
          case 2:
            total = 9;
            break;
          case 3:
            total = 7;
            break;
          default:
            total = 4;

        }
        // timing:
        var detailsKeyframesDuration = this.detailsTime*total/4; // 7
        var count = 1;

        // new method; rolling columns (all in one row)
        // custom object to allow the "keyframe builder" to be more modular.
        //HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH
        // a--
        this.detailsObjects = [
          // First, basically a copy of cmd cell
          {
            text: [this.cmdHex],
            width: cmdBbox.width,
            widthUnits: "px",
            class: ['bubbleCellOne'],
            transform: runningTransform+""
          },
          // binary
          {
            text: [` -to-binary-> `,` ${this.cmdBin} `],
            class: ['notBubble','bubbleCell']
          },
          // binary mode/operand
          {
            text: [` -split-bits-> `,` Mode: ${this.cmdBin.slice(0,2)} `,` Operand: ${this.cmdBin.slice(2)} `],
            class: ['notBubble','bubbleCell','bubbleCell']
          },
          // hex mode/operand
          {
            text: [` -hex-> `,` Mode: ${this.mode} (${this.modeNames[this.mode]}) `,` Operand: ${hex(this.n,2)} (${this.operandNames[this.mode]}) `],
            class: ['notBubble','bubbleCell','bubbleCell n']
          }
        ];

        // special stuff for modes 2 and 3
        if (this.mode>1){
          // setup
          var panel = (this.mode==2) ? this.decomp : this.comp;
          var panelContent = (this.mode==2) ? this.decompContent : this.compContent;
          var contentBbox = panelContent.getBoundingClientRect();
          // console.log('addressByte selector: '+`div > #g0x${hex( 32*(this.address>>5), 6 )} div #byte_${hex( this.address, 6 )}`);
          var addressByte = panelContent.querySelector(`div > #g0x${hex( 32*(this.address>>5), 6 )} div #byte_${hex( this.address, 6 )}`);
          var addrByteBbox = addressByte.getBoundingClientRect();
          var deltay = 0;


          if (this.mode==2) {
            this.detailsObjects.push(...[
              
              {
                text: [` swap next 2 bytes -> `],
                class: ['notBubble']
              },
              // filler
              // {
                
              // },
              {
                text: [``,` history address: ${hex(this.address,4)} `],
                class: ['notBubble','bubbleCell']
              },
              // {
              //   text: [` swap next 2 bytes -> `,` history address: ${hex(this.address,4)} `],
              //   class: ['notBubble','bubbleCell']
              // },

            ]);
            //TODO: style the following two bytes as bblLeft and bblRight, aynced at this time
            // var cmd1 = this.compContent.querySelector(`div > #g0x${hex( 32*((1+this.compIndex)>>5), 6 )} div #byte_${hex( (1+this.compIndex), 6 )}`);
            //   if (cmd1.style.backgroundColor != `rgba(${this.bgColors[this.mode]},1)`){
            //     cmd1.style.backgroundColor = `rgba(${this.bgColors[this.mode]},1)`;
            //     cmd1.style.color = `rgba(${this.fgColors[this.mode]},1)`;
            //     // cmd1.style.borderRadius = `${crnr} 0 0 ${crnr}`;

            //     var cmd2 = this.compContent.querySelector(`div > #g0x${hex( 32*((2+this.compIndex)>>5), 6 )} div #byte_${hex( (2+this.compIndex), 6 )}`);
            //     cmd2.style.backgroundColor = `rgba(${this.bgColors[this.mode]},1)`;
            //     cmd2.style.color = `rgba(${this.fgColors[this.mode]},1)`;
            //     cmd2.style.borderRadius = `0 ${crnr} ${crnr} 0`;
            //   }
          }
          else if (this.mode==3) {
            // ` 2 -> `
            this.detailsObjects.push(...[
              {
              text: [` <<1 -> `,` LUT byte address: ${hex(this.address,4)} `],
              class: ['notBubble','bubbleCell']
              }
            ]);



          }

          // establish scroll, if needed:
          // (will determine vertical position of details div)
          var offsetPos = panel.checkOffsetPosition( this.address);
          //
          if (offsetPos.inView){
            // go directly there if it's in view
            this.detailsObjects.push(...[
              {
                transform: `translate3D(${Math.round(addrByteBbox.x)}px, ${Math.round(addrByteBbox.y)}px, ${0}px)`,
                height: addrByteBbox.height+"px"
              },
            ]);

          } else{
            // go to top left, scroll it into view at the top, then go to right
            this.detailsObjects.push(...[
              {
                transform: `translate3D(${contentBbox.x}px, ${contentBbox.y}px, ${0}px)`
              },
              {
                transform: `translate3D(${Math.round(addrByteBbox.x)}px, ${Math.round(contentBbox.y)}px, ${0}px)`,
                height: addrByteBbox.height+"px"
              },
            ]);

            // set scrolling timeout now that we know length of detailsObjects
            var scrollStartTime = detailsKeyframesDuration*(this.detailsObjects.length-2)/this.detailsObjects.length;
            // var scrollStartTime = this.scrollTime;
            // console.log(`scrollStartTime:   ${scrollStartTime}`);
            setTimeout( ()=>{
              // try {
                console.log("1) in settimeout for scroll. panel content:");
                // console.log(panelContent);
                panelContent.scrollTo({top: offsetPos.position, behavior: 'smooth'});

              },
              scrollStartTime*1000
            );

          }

        }


        // build the html
        var texts = 0;
        var transforms = 0;
        var textsColWidths = [];


        this.details.innerHTML = ``;

        this.detailsObjects.forEach((d,i)=>{
          if (d.text) {
              let inners = d.text.reduce( (s,e,j) => s+='<div class="'+d.class[j]+'">'+d.text[j].replaceAll(" ","&nbsp;")+'</div>','');

              // console.log(inners);
              this.details.innerHTML+=`<div class="${clsnm}" style="grid-row: 1; grid-column: ${1+i};">`+inners+`</div>`;
              texts++;

            textsColWidths.push( (d.widthUnits==undefined)?"0ch":"0"+d.widthUnits);

          }
          if (d.transform) transforms++;

        });

        // track this animation, for pausing, etc
        let anim = new Animation();
        anim.element = this.details; //the actual node
        anim.keyframeName = `Mode_${this.mode}_details_${Date.now()}`;;
        anim.baseDuration = detailsKeyframesDuration;
        anim.duration = detailsKeyframesDuration;
        anim.easingFunction = 'linear';
        anim.progress = 0;
        anim.name = "Details Div, Mode "+this.mode;
        anim.steps = [];

        // this.initElement( anim ); // have to add steps first


        var textsColWidthsOG = Array.from(textsColWidths);
        var twindow = (this.mode==2) ? 3 : 2;
        // console.log(`${this.details.innerHTML}\nAfter building html, counted ${texts} texts and ${transforms} transforms`);

        // keframes:
        var textCount = 0;
        var rts = false; // returnToStart - this idea didn't work so it's being debugged-out for now...
        var returning = (this.mode>1) && rts;
        
        var lastTextTimes = [0,1]; // percent that the last text appears
        var secondToLastTextTimes = [0, 1];
        var thirdToLastTextTimes = [0, 1];
        this.detailsObjects.forEach((d,i)=>{
          // update text width info
            if (d.text) {
              textCount++;
              // roll the window (update current, remove last if present)
              textsColWidths[i] = d.width ? d.width+""+d.widthUnits : (d.text.reduce((s,d,i)=>s+=d.length+0,0)+1)+"ch";
              if (i-twindow >= 0) textsColWidths[i-twindow] = textsColWidthsOG[i-twindow];
              thirdToLastTextTimes = [...secondToLastTextTimes];
              secondToLastTextTimes = [...lastTextTimes];
              lastTextTimes = [detailsKeyframesDuration*(i+0.66)/this.detailsObjects.length, detailsKeyframesDuration*(i+1)/this.detailsObjects.length];
            }

            // new way to prepare for building keyframes, more modular... ------
            let props = {
              'background-color': this.bgColors[this.mode],
              'color': this.fgColors[this.mode],
              'height': d.height ? d.height : cmdBbox.height+"px", 
              'grid-template-columns': d.text ? (runningColumns=textsColWidths.join(" ")) : runningColumns,
              'transform': d.transform ? (runningTransform=d.transform) : runningTransform,
            };
            anim.steps.push(...[
              // the first; previous would animate up to here and stop...
              { 'percent': 100*(i)/(this.detailsObjects.length), 'props': {...props} },
              // ...then we stay here until THIS one's percent
              { 'percent': 100*(i+0.66)/(this.detailsObjects.length), 'props': {...props} }
            ]);

            // // if it's the last and we want to close it off:
            // if ((i+1==this.detailsObjects.length) && !returning) anim.steps.push(
            //   {'percent': 100, 'props': {...props} }
            // );
            // ------

            // old way: --------------
            // add the next keyframe.
            // If it's the last, and we didnt move details (mode 0 and 1 stay in place), close it with "100%"

            // keyframes+=`/* ${i+1} of ${this.detailsObjects.length}; should be at time ${detailsKeyframesDuration*(i)/(this.detailsObjects.length)} */
            // ${100*(i)/(this.detailsObjects.length)}%,
            // ${100*(i+0.66)/(this.detailsObjects.length)}%${(i+1==this.detailsObjects.length) && !returning ?', 100%':''} {
            //   grid-template-columns: ${ d.text ? (runningColumns=textsColWidths.join(" ")) : runningColumns };
            //   transform: ${ d.transform ? (runningTransform=d.transform) : runningTransform };
            // }
            // `;
            //--------------------

          });


        // if mode 3 or 4, we move back to the starting point real quick
        // if ( returning && (this.mode>1) ) {
        if ( returning ) {
          // keyframes+=`
          //     100% {
          //       grid-template-columns: ${ [this.detailsObjects[0].width, ...textsColWidthsOG.slice(1)].join(" ") };
          //       transform: ${ this.detailsObjects[0].transform };
          //     }
          //   }`;
          anim.steps.push( {...anim.steps[0], 'percent': 100} );
        } else {
          // keyframes+=`}`; // else just close it up
          0;
        }
        // console.log( anim.steps);

        // new modulalr version: build the keyframes:
        // keyframes = this.buildKeyframe(anim);



      // old method ---------------
      // insert into stylesheet at index 0
      // document.styleSheets[0].insertRule(keyframes);

      // // apply the animation ("forwards" might be important?)
      // this.details.style.animation = `${detailsName} ${(this.mode==2)?detailsKeyframesDuration:detailsKeyframesDuration}s linear forwards`;
      // -------------------------


      



      // also animate the appearance of bubble around the cmd and maybe cmd1 and cmd2 bytes:
      var bblBoth = this.bblBoth;
      var bblLeft = this.bblLeft;
      var bblRight = this.bblRight;
      var bblNone = this.bblNone;
      var totalTime2 = detailsKeyframesDuration + this.bblTime;
      var cmdAnims = [];

      // cmd:
      let cmdDivAnim = new Animation();
      cmdDivAnim.name = "cmdDiv animation";
      cmdDivAnim.element = cmd;
      cmdDivAnim.baseDuration = totalTime2;
      cmdDivAnim.easingFunction = "ease";
      cmdDivAnim.keyframeName = `cmdDivStyle_${Date.now()}`;
      cmdDivAnim.steps = [];
      


      // 
      var cmdDivCompStyle = getComputedStyle(cmd);
      let origs = {
        'color':cmdDivCompStyle.getPropertyValue('color'),
        'background-color':cmdDivCompStyle.getPropertyValue('background-color'),
        'border':cmdDivCompStyle.getPropertyValue('border'),
        
      }


      var cmdBblTime = (this.mode==2) ? thirdToLastTextTimes[0] : detailsKeyframesDuration;
      if (this.mode==3) cmdBblTime = 0;

      cmdDivAnim.steps = [
        { 'percent': [0, 100*(cmdBblTime)/totalTime2],  'props': { ...origs } },
        // make it the same color from the start; we assume details div is over top anyway
        { 'percent': 0.02+(100*(cmdBblTime)/totalTime2), 'props': { 
          'background-color': `rgba(${this.bgColors[this.mode]},1)`,
          'color': `rgba(${this.fgColors[this.mode]},1)`,
          'border-radius': bblBoth} },
        // quickly morph to fit next
        { 'percent': 100*(cmdBblTime+this.bblTime)/totalTime2, 'props': {
          'border-radius': (this.mode==3) ? bblBoth : bblLeft
        } }
      ];
      cmdAnims.push( cmdDivAnim );


      // if mode 2 history, cmd 1 and cmd 2:
      if (this.mode==2){
        let histStart = 1;
        [cmd1, cmd2].forEach( (d,i)=>{

          let cmdxDivAnim = new Animation();
          cmdxDivAnim.name = "cmd"+(1+i)+" Div animation";
          cmdxDivAnim.element = d;
          cmdxDivAnim.baseDuration = totalTime2;
          cmdxDivAnim.easingFunction = "ease";
          cmdxDivAnim.keyframeName = `cmd${1+i}DivStyle_${Date.now()}`;

          cmdDivCompStyle = getComputedStyle(d);
          let xorigs = {
            'color':cmdDivCompStyle.getPropertyValue('color'),
            'background-color':cmdDivCompStyle.getPropertyValue('background-color'),
            'border':cmdDivCompStyle.getPropertyValue('border'),
            
          }

          cmdxDivAnim.steps = [
            { 'percent': [0, 100*thirdToLastTextTimes[0]/totalTime2], 'props': { ...xorigs} },
            // when the mover div appears, coming out of this, instantly* make it the same color:
            { 'percent': 0.02+(100*thirdToLastTextTimes[0]/totalTime2), 'props': { 
              'background-color': `rgba(${this.bgColors[this.mode]},1)`,
              'color': `rgba(${this.fgColors[this.mode]},1)`,
              'border-radius': bblBoth} },
            // quickly morph to fit adjacent cells
            { 'percent': 100*(thirdToLastTextTimes[0]+this.bblTime)/totalTime2, 'props': {
              'border-radius': (i==0) ? bblNone : bblRight
            } }
          ];

          // console.log(cmdxDivAnim.steps);

          cmdAnims.push( cmdxDivAnim );

        });

      }


      

      // new method : actually start animations -----------
      cmdAnims.forEach(d=> {this.initElement(d);});
      
      this.initElement(anim);
      // console.log(anim.keyframes);

      cmdAnims.forEach(d=> {this.startElement(d);});
      this.startElement(anim);

      // ---------------------
      

      // not sure if it matters...
      anim.element.addEventListener("animationend", ()=>{
      // this.details.addEventListener("animationend", ()=>{





        // console.log("LEVEL 1 finished\n");
        // find and delete this keframe to clean up the stylesheet

        // for (let i=0; i<document.styleSheets[0].cssRules.length; i++) {
        //   if ( document.styleSheets[0].cssRules[i].name === name ){
        //     document.styleSheets[0].deleteRule(i);
        //     break;
        //   }
        // }
        // // remove animation (?)
        // cmd.style.animation = ``;


        // ---------------------------------------------------------------
        //
        // LEVEL 2
        // Address scroll

        // --- highlight decomped data (temporary) ---
        // var highlightName = `Mode_${this.mode}_highlight_${Date.now()}`;
        // var highlightKeyframe = `@keyframes ${highlightName} {
        //   0% {
        //     background: linear-gradient(to left, rgba(0,0,0,0) 50%, rgba(${this.modeColor},0.4) 50%) right;
        //     background-size: 200% 100%;
        //     background-position: right;
        //     color: var(--textColorTransparent);
        //   }
        //   100% {
        //     background: linear-gradient(to left, rgba(0,0,0,0) 50%, rgba(${this.modeColor},0.4) 50%) right;
        //     background-size: 200% 100%;
        //     background-position: left;
        //     color: var(--textColor);
        //   }
        // }`;
        // // insert into stylesheet at index 0
        // document.styleSheets[0].insertRule(highlightKeyframe);
        // // apply the animation ("forwards" might be important?)
        // cmd.style.animation = `${highlightName} 1s linear forwards`;
        // this.highlight(this.numberAddedToDecomp, this.numberAddedToDecomp, highlightName);
        //--- end of temporary highlighting ----


          // LEVEL 3
          //
          // level 3 cloneAndMove outline
          //
          // SETUP:
          this.compIndex; // increment to the byte following the command byte
          // starting at an <index (mode 0 and 1: this.compIndex, modes 2 and 3: this.address)> of <panel (mode 0,1,3: comp; mode 2: decomp)>,
          var cloneTotal = 0;
          var cloneOffset = (this.mode<2) ? this.compIndex+1 : this.address;
          var clonePanel = (this.mode==2) ? this.decomp : this.comp;
          var clonePanelContent = (this.mode==2) ? this.decompContent : this.compContent;
          this.firstIncomplete = true;

          // ...highlight and clone <a (
          // mode 0: this.n,
          // mode 1: 1,
          // mode 2: this.n,
          // mode 3: 2
          // )> bytes...
          var a = [this.n, 1, this.n, 2][this.mode];
          //... <b (mode 1: n, else 1)> time(s) each...
          var b = (this.mode==1) ? this.n : 1;
          this.axb = a*b;
          this.axbi = a*b; // will count down

          // ... (decrementing the visible n value each time for modes 0,1, and 2)
          // scroll decomp into view if needed
          // this.decomp.scrollToView();

          // see if we'll need to scroll the decomp panel between picking up the data
          // and moving it to current output index:
          // if ( (this.mode==2) && !offsetPos.inView ){
          //   //checkOffsetPosition( this.decompIndex, 2, 2 );
          //   // var historyPos = this.decomp.checkOffsetPosition( this.address);
          //   this.decompScrollPos = this.decomp.checkOffsetPosition( this.decompIndex);
          //   //{inView: false, position: offsetPos, topMargin: topRowMargin*rowHeight, windowHeight:windowHeight, rowHeight:rowHeight}
          //   // we want to know where we'll need to scrol to: it'll actually just be hex_ccontent's top plus the margin
          //   // hc.y + topMargin;
          //   // for each: hcTop.y + ( thisToDiv_.position_from_checkOffsetPosition - positionWillScrollTo );
          //   var willNeedToScroll = (decompPos.position - historyPos.position - (2*decompPos.rowHeight)) > decompPos.windowHeight;
          //   setTimeout( ()=>{
          //     // try {
          //       console.log("1) in settimeout for scroll. panel content:");
          //       // console.log(panelContent);
          //       panelContent.scrollTo({top: historyPos.position-topMargin, behavior: 'smooth'});

          //     },
          //     scrollStartTime*1000
          //   );
          // } else {
          //   this.decompScrollPos = undefined;
          // }

          //...or, if we had to scroll up to get to history, we'll have to scroll down again, assuming we'll
          // go back to the first address+topMargin

          // offsetPos.position

          // move all clones into decomp starting at this.decompIndex
          // we usually do them in series,
          // but for mode 2 HISTORY we might want to do them  semi-parallel,
          // because we might need to scroll the entire page.
          this.moveBuffer = [];

          if ( ( (this.mode==2) && !offsetPos.inView ) || this.parallelize ){
            // console.log("first case");
            // move all in a batch
            var batch = [];
            for (let i = a; i>0; i--){
              for (let j = b; j>0; j--){
                batch.push(
                  clonePanelContent.querySelector(
                    `div > #g0x${hex( 32*(cloneOffset>>5), 6 )} div #byte_${hex( cloneOffset, 6 )}`
                  )
                );
              }
              cloneOffset++;
              // cloneTotal++;
            }
            this.moveBuffer.push( batch ); // note; not popping, won't reverse

          } else {
            // console.log("secnd case");
            // move all in series.
            for (let i = a; i>0; i--){
              for (let j = b; j>0; j--){
                this.moveBuffer.push(
                  [ clonePanelContent.querySelector(
                    `div > #g0x${hex( 32*(cloneOffset>>5), 6 )} div #byte_${hex( cloneOffset, 6 )}`
                  ) ]
                );
              }
              cloneOffset++;
              // cloneTotal++;
            }

          }

          this.cloneIndex = 0;
          this.previousFromDiv = null;
          this.previousToDiv = null;
          this.willScrollDecomp = ( (this.mode==2) && !offsetPos.inView );


          // reverse, because we'll be popping
          this.moveBuffer = this.moveBuffer.reverse();
          // console.log(this.moveBuffer)

          // Call the function to perform the moving (recursively iterates through the this.moveBuffer)
          this.cloneAndMove();

        }); // end of level 2, moving the details div vertically, and horizontally


          // // get the first decomp byte for this decomp span
          // let g32d = hex( 32*(this.decompIndex>>5), 6 ); // get g32 group by floor dividing by 32 (>>5)
          // let offsetd = hex( this.decompIndex, 6 );
          // let byt = this.decompContent.querySelector(`div > #g0x${g32d} div #byte_${offsetd}`);
          // console.log(`Decomp index ${this.decompIndex}:`);
          // console.log(byt);

          // // insert into stylesheet at index 0
          // // document.styleSheets[0].insertRule(highlightKeyframe);

          // // apply the animation ("forwards" might be important?)
          // byt.style.animation = `${name} 2s linear forwards`;

          // byt.addEventListener("animationend", ()=>{
          //   console.log("LEVEL 2 finished\n");
          //   // find and delete this keframe to clean up the stylesheet

          //   for (let i=0; i<document.styleSheets[0].cssRules.length; i++) {
          //     if ( document.styleSheets[0].cssRules[i].name === name ){
          //       document.styleSheets[0].deleteRule(i);
          //       break;
          //     }
          //   }
          //   // // remove animation (?)
          //   // byt.style.animation = ``;

          //   // increment the indices appropriately and then run next (recursive)

          //   switch(mode){
          //     case 0:
          //       this.compIndex += 1+n;
          //       this.decompIndex += n;
          //       break;
          //     case 1:
          //       this.compIndex += 2;
          //       this.decompIndex += n;
          //       break;
          //     case 2:
          //       this.compIndex += 3;
          //       this.decompIndex += n;
          //       break;
          //     case 3:
          //       this.compIndex += 1;
          //       this.decompIndex += 2;
          //       break;
          //   }

          //   if (this.compIndex < this.comp.source.data.length) this.decompSpan();

          // });

        // }); // end of level 1: details

        // increment to next decomp span

        // if there are more left, call this again (recursive)
        // if (index < input.length) this.decompSpan();


      }
      // skip: function(){
      //   if (!this.skipping){
      //     // 0) enter skipping mode if not already in it
      //     this.skipping = true;
      //     // 1) setting a global duration scaler to be very short,
      //     this.durationScale = 1*this.skippingDurationScale;
      //   }


      //   // 2) For each element:
      //   this.elements.forEach( d => {
      //     // pause element and recalculate the progress percentage
      //     this.pauseElement(d);
      //     // record the new shortened duration

      //     // apply the new duration and a negative delay so that it will begin at the same point.
      //     this.assignAnimation(d);
      //     // pause

      //   });

      //   // 3) pausing all elements

      // }
      // stepCount: 0,

      // step: function (){

      //   var ani = this.stack.pop();

      //   // for each element in this set of parallel animations:
      //   ani.forEach( d=> d() );

      //   // remove this one from this.animatingElements:
      //   this.animatingElements.filter(d=>d!=element);

      // },
      // pause: function (){

      //   this.animatingElements.forEach (d=>d.style.animationPlayState = 'paused');

      // }
      // play: function (){

      //   this.animatingElements.forEach (d=>d.style.animationPlayState = 'running');

      // }


    };



  }

  propagateSource(){
    // this propagates the update of a source (or addition) out to dependent panels
    console.log(`propagateSource on panel ${this.index}: ${this.name} ( ${this.kind} )`);
    switch (this.kind){
      case "fileIn":
        0;
        break;

      case "hexViewer":
        // decompress
        // if we have source compressed graphics (ignore for calls from others )
        if (this.links[0].source && !this.source ){
          this.source = {
              name: "Decompressed from "+this.links[0].source.file.name,
              kind: "bytes",
              data: dkc1decompress( this.links[0].source.data ),
              panel: this,
              from: this.links[0]
          };
          // updateBitplaneSeek(this.inner, this, 0 );
          // this.inner.querySelector(".panel_content > .hex_content").style.gridTemplateRows = `repeat(${Math.ceil(this.source.data.length/this.groupSize)}, ${ 4 * this.groupSize/32 }em)`;

          this.generateLineSpacingRange();

          this.generateHexHTML( this.source.data, 0, this.groupSize*2 ); // first two groups' worth
          // Truncated version for performance
          // this.generateHexHTML( this.source.data.slice(0,32*20), 0, 32*20);

          // download setup
          if (!this.downloadButton){
            let downloadFileName = this.links[0].source.file.name.replace(".bin","_Decompressed.bin");
            this.generateDownloadButton(
              this.source.data, downloadFileName,
              "Download Decompressed Graphics File (.bin)");
          }


          this.updateLines(); // should bring to full height, accurate scrollbar?
        }

        break;
      case "hexViewerComp":
        // compressed data hex viewer and animator
        // if we have source compressed graphics (ignore for calls from others )
        if (this.links[0].source && !this.source){
          this.source = {
              name: this.links[0].source.file.name,
              kind: "bytes",
              data: this.links[0].source.data,
              panel: this,
              from: this.links[0]
          };
          // updateBitplaneSeek(this.inner, this, 0 );
          // this.inner.querySelector(".panel_content > .hex_content").style.gridTemplateRows = `repeat(${Math.ceil(this.source.data.length/this.groupSize)}, ${ 4 * this.groupSize/32 }em)`;

          this.generateLineSpacingRange();

          this.generateHexHTML( this.source.data, 0, this.groupSize*2 ); // first two groups' worth
          // Truncated version for performance
          // this.generateHexHTML( this.source.data.slice(0,32*20), 0, 32*20);

          // download setup
          // if (!this.downloadButton){
          //   let downloadFileName = this.links[0].source.file.name;
          //   this.generateDownloadButton(
          //     this.source.data, downloadFileName,
          //     "Download Original Compressed Data File (.bin)");
          // }
          this.updateLines(); // should bring to full height, accurate scrollbar?

          // create the button used to run the decomp animation
          if (!this.animateDecompButton){
            this.generateAnimateDecompButton( );
          }
        }

        break;

      case "bitplaneViewer":
        // break;

        // decompress
        // if we have source compressed graphics (ignore for calls from others )
        if (this.links[0].source && !this.source){
          this.source = {
              name: this.links[0].source.name,
              kind: "bytes",
              data: this.links[0].source.data,
              panel: this,
              from: this.links[0]
          };
          // updateBitplaneSeek(this.inner, this, 0 );
          this.generateBitplaneHTML( this.source.data.slice(0,32), 0, "byte1", 32);
          //
          updateBitplaneSeek(this.inner, this, 0);

          // download setup
          // if (!this.downloadButton){
          //   let downloadFileName = this.name.replace(".bin","_Decompressed.bin");
          //   this.generateDownloadButton(
          //     this.source.data, downloadFileName,
          //     "Download Decompressed Graphics File (.bin)");
          // }
        }

        break;

      case "paletteViewer":
        this.source = {
            name: "Decompressed from "+this.links[0].source.file.name,
            kind: "bytes",
            data: palette2rgb( this.links[0].source.data ),
            panel: this,
            from: this.links[0]
        };
        this.generatePaletteHTML( this.source.data);
        break;

      case "tilesetViewer":
        break;
        // de-intertwine the bitplanes, show tilesets
        // (only if we have actual data (this.links[0]), not just palette (this.links[1]) )
        //TODO: better way to source filename
        if (this.links[0].source){
          this.source = {
              name: "De-intertwined from "+this.links[0].source.from.source.file.name,
              kind: "tiles",
              data: unbitplane( this.links[0].source.data ),
              panel: this,
              from: this.links[0]
          };
          // Don't actually use the imported big palette, bc we don't know which subset goes to each 8x8 tile
          // if (this.links[1].source){
          //   this.palette =  this.links[1].source.data ;
          // }
          this.generateTilesetHTML( this.source.data);
        }
        break;

      case "metatilesViewer":
        // create the 32x32 pixel meta tiles, composed of 4x4 tiles of 8x8 pixels, from tileset
        // (only if we palette (this.links[0]), tile data (this.links[1]), AND metatile32 map (this.links[2]) )
        //TODO: better way to source filename
        //TODO: have a default 8x16 palette in case we don't have a source
        if  (this.links[0].source && this.links[1].source && this.links[2].source ){
          console.log(`Building metatiles...`);
          this.source = {
              name: "Metatiles built from "+this.links[2].source.file.name,
              kind: "metatiles",
              data: metatile( this.links[1].source.data, this.links[2].source.data ), /* tiles, tilemap32  */
              panel: this,
              from: this.links[1]
          };
          // get palette from the palette viewer, which has converted SNES format to RGB
          if (this.links[0].source){
            this.palette =  this.links[0].source.data;
          }
          this.generateMetatilesetHTML( this.source.data);
        }
        break;

      case "levelMapViewer":
        // place the 32x32 pixel meta tiles, from metatileset
        // (only if we palette (this.links[0]), metatile data (this.links[1]), AND level map (this.links[2]) )
        //TODO: better way to source filename
        //TODO: have a default 8x16 palette in case we don't have a source
        if  (this.links[0].source && this.links[1].source && this.links[2].source ){
          console.log(`Building level map...`);
          this.source = {
              name: "Levels built from "+this.links[2].source.file.name,
              kind: "metatiles",
              data: levelMap( this.links[1].source.data, this.links[2].source.data ), /* metatiles, level map  */
              panel: this,
              from: this.links[1]
          };
          // get palette from the palette viewer, which has converted SNES format to RGB
          if (this.links[0].source){
            this.palette =  this.links[0].source.data;
          }
          this.generateLevelMapHTML( this.source.data);
        }
        break;

    }
    // now do the next one, if it exists:
    //HACK: paletteViewer was slowing things down,
    // propagating out to regenerate a bunch of stuff.
    // if (this.nexts[0] && (this.kind != "paletteViewer") ) { this.nexts[0].propagateSource(); }
    // if (this.nexts[0] ) { this.nexts[0].propagateSource(); }
    // this.nexts.forEach( d => d.propagateSource());

    if ( this.kind != "paletteViewer" ) {
      this.nexts.forEach( d => d.propagateSource());
    }

  }

}

function fileInput(e, ui, panel){

    // console.log("onchanged");
    // console.log(e);

    var file = e.target.files[0];

    // the hex viewer div
    //HACK: assumes there is only one hexViewercontent per panel...
    let hexContent = panel.panelContent.querySelector(" .hex_content");
    // console.log(panel.name+" hexContent");
    // console.log(hexContent);

    var fReader = new FileReader();
    fReader.readAsArrayBuffer(file);

    // console.log("this/e/ui");
    // console.log(this);
    // console.log(e);
    // console.log(ui);

    fReader.addEventListener('load', function (e) {

        panel.source = {
            name: "Raw data from "+file.name,
            kind: "bytes",
            data: new Uint8Array( e.target.result),
            panel: panel,
            file: file
        };

        // panel.generateHexHTML( panel.source.data );  // comment out for speed


        // Automatically do the next steps...
        // console.log(panel);
        // panel.nexts[0].propagateSource();
        panel.propagateSource();

    });

}

function changeByteWidth(panel, overrideMode=null){
  // var panel = e.target.parentNode.parentNode;

  var oldMode = panel.getAttribute("data-mode");
  var newMode = "";
  if (overrideMode){
    newMode = overrideMode;
  }
  else{
    newMode = oldMode=="byte16"?"byte1":"byte16"; // simplified: toggle
  }


  // console.log(panel);

  // panel.style.gridTemplateColumns = newMode=="byte1"?"2fr 4fr 14fr":"2fr 16fr 0fr";

  var hexOffsetHeaderLabels = panel.querySelector(".hex_header > .hex_offset_labels");
  var hexBaseLabels = panel.querySelector(".hex_header > .hex_base_labels");
  // hof.style.gridTemplateColumns = newMode=="byte1"?"2fr repeat(16, 0.25fr)":"2fr repeat(16, 1fr)";
  var hexContent = panel.querySelectorAll(".hex_content")[0];
  var g32l = hexContent.querySelectorAll(".g32l");
  // hc.style.gridTemplateColumns = newMode=="byte1"?"4fr 14fr":"18fr 0fr";

// hc.style.gridTemplateRows = newMode=="byte1"?`repeat(${g32.length},100%)`:`repeat(${g32.length},1fr)`;


  switch (newMode){
    case "byte16":
      panel.style.gridTemplateColumns = "2fr 16fr 0fr";
      // hexContent.style.gridTemplateRows = `repeat(${g32l.length},5ch)`;
      hexOffsetHeaderLabels.style.opacity = 1;
      hexBaseLabels.style.opacity = 0;
      break;
    case "byte1":
      panel.style.gridTemplateColumns = "2fr 4fr 25fr";
      // hexContent.style.gridTemplateRows = `repeat(${g32l.length},100%)`;
      hexOffsetHeaderLabels.style.opacity = 0;
      hexBaseLabels.style.opacity = 1;
      break;
    }

  // console.log(g32);
  // hc.height = "100%";

  // for grid elements, get the custom grid-template-rows and columns
  var g32rrs = hexContent.querySelectorAll(".g32rr");
  for (var g32rr of g32rrs){
    for (var gr32r of g32rr.querySelectorAll(".g32r")){

      let gcr = gr32r.getAttribute(`data-mode-${newMode}`).split(";");

      gr32r.style.gridTemplateColumns = gcr[0];
      gr32r.style.gridTemplateRows = gcr[1];
      let gr32rByte = gr32r.querySelector(".byte");
      let bp = gr32rByte.getAttribute('data-bitplane');
      let binSpan = gr32rByte.querySelector(".byteBin");
      let prefix = gr32rByte.querySelector(".byteOffsetPrefix");
      // console.log(gr32rByte);
      // console.log(bp);
      // gr.querySelectorAll(".byte")[0].style.justifyContent = newMode=="byte1"?"flex-end":"center";
      if (newMode == "byte16"){
        gr32rByte.classList.remove(`byte_bp${bp}`);
        binSpan.classList.remove(`byteBinOneByteWide`);
        // binSpan.style.width = "0%";
        // binSpan.style.opacity = 0;
        prefix.style.opacity = 0;
        // gr32rByte.style.gridTemplateColumns = "0fr 1fr"; //NOTE: backwards because rtl
      }
      else if (newMode == "byte1"){
        gr32rByte.classList.add(`byte_bp${bp}`);
        binSpan.classList.add(`byteBinOneByteWide`);
        // binSpan.style.width = "100%";
        // binSpan.style.opacity = 1;
        prefix.style.opacity = 1;
        // gr32rByte.style.gridTemplateColumns = "4fr 2fr";
      }
    }
    // console.log(g32);
  }


  panel.setAttribute("data-mode", newMode);

}

function updateBitplaneSeek(panelNode, panel, change, override=false ){


  // first update the total number
  let currentTile = panelNode.querySelector(".panel_content > .hex_header > .seekButtons > #currentTile");
  let totalTiles = panelNode.querySelector(".panel_content > .hex_header > .seekButtons > #totalTiles");

  // console.log("seek btn:");
  // [panelNode, panel, change, override, currentTile, totalTiles].forEach( d=> console.log(d));

  if (panel.source){

    let totalNumber = Math.ceil(panel.source.data.length/32);
    totalTiles.innerHTML = totalNumber;
    //
    let oldVal = (1*currentTile.innerHTML);
    let newVal =  (typeof(override)=='number' ) ? override : (oldVal+change);

    // min max/ clamp the range:
    if (newVal>totalNumber) newVal = totalNumber;
    if (newVal<1) newVal = 1;

    // if we have a valid change:
    if ( (newVal != oldVal) || (override!=false) ){
      currentTile.innerHTML = newVal;
      console.log(`Valid seek change: updating bitplane seek to ${newVal}`)

      panel.generateBitplaneHTML(panel.source.data, (newVal-1)*32 );

    } else{
      console.log("invalid seek change");
    }
  }
}


class UImodel {
  constructor(grid, panelsParams, name=null, cell=null) {
    this.grid = grid;
    this.panels = [];
    for (let i = 0; i<panelsParams.length; i++){
        //HACK: surely a better way to do this but whatever
        this.panels.push( new Panel(this,
            panelsParams[i][0], panelsParams[i][1], panelsParams[i][2],
            panelsParams[i][3], panelsParams[i][4], panelsParams[i][5],
            panelsParams[i][6] )
        );
    }

    this.name = name;
    this.sources = []; // will contain source data from files
    if (cell == null){
        let cell = document.createElement("div");
        cell.style.gridRow = 1;
        cell.style.gridColumn = 1;
        cell.style.background = "none";
        cell.style.zIndex = -10;
        this.grid.append(cell);
        this.cell = cell;
        console.log("assigning cell to ui");
    }
    else{
        this.cell = cell; // a reference cell within the grid
    }
    console.log("Appending to main grid...");
    // this.panels.forEach(p => this.grid.append(p.outer));
    // now that they're in the document, add event listeners

    // this.panels.forEach(
    //     p => p.eventListeners.forEach(
    //         // (el) => el[0].addEventListener(el[1], el[2] )
    //         (el) => el.tagName=="INPUT" ? el.onchange = fileInput : 0
    //     )
    // );
    //HACK: this is a weird way to assign the event listener, but it wasn't working otherwise...
    for (let panel of this.panels){

        // console.log(panel);
        //TODO: find a better way to find ALL inputs within a panel, instead
        // of searching through everything in the panelHeader ...?
        // for (let el of panel.panelHeader.children){

        //     if (el.tagName=="INPUT"){
        //         // where "this" will be the UImodel object.
        //         el.onchange = (e) => fileInput(e, this, panel);
        //         ;
        //         console.log("found input");
        //         console.log(el);
        //         console.log(el.onchange);
        //         console.log( [ this, panel ] );

        //     }
        // }

        // if (panel.byteWidthButton){
        //   // panel.inner.querySelectorAll(".panel_header > .byteWidthButton")[0].addEventListener("click",
        //   //     (event) => {changeByteWidth(event.target.parentNode.parentNode)});
        //   console.log("ADDED EVENT LISTENER");
        //   panel.inner.querySelector(".panel_content > .bitplane_header > .byteWidthButton").addEventListener("click",
        //       (event) => {
        //         console.log(event);
        //         // changeByteWidth(event.target.parentNode.parentNode);
        //         panel.animate16to1();
        //       });
        // }
        // if (panel.seekTileUpButton){
        //   // panel.inner.querySelector(".panel_header > div > .seekTileUpButton").addEventListener("click",
        //   //   (event) => {
        //   //     updateBitplaneSeek(event.target.parentNode.parentNode.parentNode, panel, +1)
        //   //   }
        //   // );
        //   console.log("ADDED EVENT LISTENER");
        //   panel.inner.querySelector(".panel_content > .bitplane_header > .seekButtons > .seekTileUpButton").addEventListener("click",
        //     (event) => {
        //       console.log(event);
        //       updateBitplaneSeek(event.target.parentNode.parentNode.parentNode, panel, +1)
        //     }
        //   );
        // }
        // if (panel.seekTileDownButton){
        //   // panel.inner.querySelector(".panel_header > div > .seekTileDownButton").addEventListener("click",
        //   //   (event) => {
        //   //     updateBitplaneSeek(event.target.parentNode.parentNode.parentNode, panel, -1)
        //   //   }
        //   // );
        //   console.log("ADDED EVENT LISTENER");
        //   panel.inner.querySelector(".panel_content > .bitplane_header > .seekButtons > .seekTileDownButton").addEventListener("click",
        //     (event) => {
        //       console.log(event);
        //       updateBitplaneSeek(event.target.parentNode.parentNode.parentNode, panel, -1)
        //     }
        //   );
        // }


        if (panel.fileInputs[0]){
          panel.inner.querySelectorAll(".panel_content > .fileInput")[0].onchange = (e) => fileInput(e, this, panel);
        }

        // also see if we need to link any panels:
        for (let link of panel.links){
            console.log(`Pushing link: [${link.name}] --> [${panel.name}]`);
            link.nexts.push(panel);
        }
    }
    //HACK
    // document.getElementById("ii").onchange = (e) => fileInput(e, this, this.panels[0]);
    // document.getElementById("btn").addEventListener("click",
    //   (event) => {changeByteWidth(event.target.parentNode.parentNode)});



    // changeByteWidth(this.panels[0].inner,"byte16");

    // window.addEventListener('resize', (e) => this.reflow(e), true);
    this.bpsvgs = [];
    let i = 0;

    // for (var g32s of document.getElementsByClassName("g32s")){
    //   this.bpsvgs.push(makeBitplaneSVG(g32s,"bpsvg_"+i));
    //   console.log(i);
    //   i++;
    // }

    // this.reflow(); // initial reflow

  }
  reflow(){

    // tries to automatically fit panels. Not used after adding more complicates setup.
    // console.log(this);

    let cellWidth = this.cell.getBoundingClientRect().width;
    let dl = 0; // running tracker of previous panels' width changes
    let dt = 0; // not fully implemented; top deltas

    for (let i=0; i<this.panels.length; i++){
        let panel = this.panels[i];
        // // Get the first child element to be of panel_inner class:
        // var inner;
        // for (let item of panel.element.children ){
        //     if (item.classList.contains("panel_inner")){
        //         inner = item;
        //         break;
        //     }
        // }
        let inner = panel.inner;
        let outer = panel.outer;
        let dw = 0, dh = 0;
        // console.log([inner.getBoundingClientRect().width , outer.getBoundingClientRect().width]);
        if (inner.getBoundingClientRect().width > outer.getBoundingClientRect().width){
            dw = 1;
            // console.log("largen");
        }
        else if (inner.getBoundingClientRect().width  + (1*cellWidth) < outer.getBoundingClientRect().width  ){
            dw = -1;
            // console.log("smallen");
        }
        panel.updateBox(dt, dt+dh, dl, dl+dw);
        // dl += i>0 ? dw : 0;
        dl += dw;
        dt += dh;

    }
  }
}


//
//   Create the ui and panels
//

// let c0 = 2, c1 = 11, c2 = 20, c3=29;
let c0 = 2, c1 = 12, c2 = 33, c3=40;
let cx = 33;
let dx = 33+5;
let d0 = c1-1, d1 = c2-1, d2=c3-1, d3=42;
//              _, kind,                  rows        cols     name=null, link
var inputPanel = ["fileIn",                1,  3,    c0, d0,  "Input - Compressed Data"];
var compHexPanel = ["hexViewerComp",       1, 14,    c1, d1,  "Hex Viewer - Compressed Data", [0]]; // 1
var paletteInputPanel = ["fileIn",        16, 18,    cx, dx,  "Input - Palette"];  //  2
var paletteViewer = ["paletteViewer",      2,  6,    c3, d3,  "Palette", [2]]; // 3
var decompHexPanel = ["hexViewer",        15, 27,    c1, d1,  "Hex Viewer - Decompressed Data", [0, 3, 1]]; // 4
var bitplanePanel = ["bitplaneViewer",     2, 27,    c2, d2,  "Bitplane Viewer - Decompressed Data", [4, 3]]; // 5
var tilesetViewer = ["tilesetViewer",      7, 12,    c3, d3,  "Tiles", [4, 3, 5]]; //  6
var metatilemapInputPanel = ["fileIn",    19, 21,    cx, dx,  "Input - Tilemap32 (Metatiles)"]; //  7
var metatilesViewer = ["metatilesViewer", 13, 18,    c3, d3,  "Tilemap32 (Metatiles)", [3,6,7]]; // 8 pal viewer, tileset vwr, metatile input
var levelMapInputPanel = ["fileIn",       22, 24,    cx, dx,  "Input - Level Map"]; //  9
var levelMapViewer = ["levelMapViewer",   19, 27,    c3, d3,  "Level Map", [3,8,9]]; // 10 paletteViewer, metatilesViewer, fileIn
var description = ["textDescription",      4, 27,    c0, d0,  "About"]; // 11

const ui = new UImodel(
        document.getElementById("panelgrid"),
        [ inputPanel, compHexPanel,
        paletteInputPanel, paletteViewer,
        decompHexPanel, bitplanePanel,
        tilesetViewer,
        metatilemapInputPanel, metatilesViewer,
        levelMapInputPanel, levelMapViewer,
        description ],
        "main"
    );

// ui.panels[0].toOneByteWide(); //HACK
// window.addEventListener('resize', ui.reflow, true);

let pg = document.getElementById("panelgrid");

//debug:
// ui.panels[1].generateHexHTML();

//checkerboard (sort of debug)
// for (let i=1; i<=28; i++){
//     for (let j=1; j<=32;j++){
//         let chkr = document.createElement("div");
//         chkr.className = "checker";
//         chkr.id = "checker_"+i+"_"+j;
//         chkr.style.gridRow = ""+i+"";
//         chkr.style.gridColumn = ""+j+"";
//         if ( (i%2) == (j%2) ){
//             chkr.style.backgroundColor = "black";
//         }
//         pg.append(chkr);


//     }
// }


//-----------------------------------------------------------------------------------------------
//
//  these are more like Utilities
//  (more in <head> as well...)
//-----------------------------------------------------------------------------------------------


// a lot of variations on __Hex, some unused now

// plain text version...
function appendHex(inp,el){
    var str = [];
    inp.forEach( (x, i) => {
        // console.log(x);
        str.push(hex(x));
    });
    // hexView.innerHTML = bin.map( (x) => hex(x)).join(" ");

    el.innerHTML += str.join(" ");

}

// special html div version...
function appendHexHTML(inp,el){
    // gets uint8 data bytes from inp,
    // then appends specially-formatted HTML representations to element el
    var str = [];
    inp.forEach( (x, i) => {
        let byte = document.createElement('div');
        byte.className = "hexAndBinByte";
        byte.innerHTML = (
                `<div class="hexByte">${hex(x)}</div>
                <div class="binByte">${binar(x)}</div>`
            ).trim();
        el.appendChild(byte);
    });
}
// offset html div version...
function appendHexOffsetHTML(inp,el){
    // gets uint8 data bytes from inp,
    // then appends specially-formatted HTML representations to element el
    var str = [];
    inp.forEach( (x, i) => {
        let byte = document.createElement('div');
        byte.className = "offset";
        byte.innerHTML = hex(x,6);
        el.appendChild(byte);
    });
}
// 1-wide special version...
function appendOneWideByteHTML(inp,el){
    // gets uint8 data bytes from inp,
    // then appends specially-formatted HTML representations to element el
    var str = [];
    inp.forEach( (x, i) => {
        let byte = document.createElement('div');
        byte.className = "oneWideByte";
        byte.innerHTML = (
                `${hex(x)} ${binar(x)}`
            ).trim();
        el.appendChild(byte);
    });
}


function dkc1decompress(inp, offset=0){
    // the decompression function.
    // After a block of data dedicates to a look up table,
    // the compressed data consists of spans of data, each starting with a
    // command / control byte. There are 4 types of commands modes.
    let input = inp.slice(offset);
    const modeNames = ["Copy", "RLE", "History", "LUT"];

    var index = 128; // index of byte within data;
    // start after the LUT of 64 16-bit words (64*2=128).
    var output = [];
    var highestDiff = 0, diff=0;
    while(index < input.length){
        var control = input[index]; // or "command"
        var mode = control >> 6; // same as extracting leftmost 2 bits
        var detail = control & 0b00111111; // extracts rightmost 6 bits
        // console.log(modeNames[mode]+": "+detail);
        switch(mode){
            // COPY
            case 0:
                // here, the detail refers to number of subsequent bytes to copy
                for (let i = 1; i <= detail; i++){
                    output.push(input[index + i]);
                }
                // output.push(input.slice(index + 1, index + 1 + detail));
                index += 1 + detail;
                break;
            // Run-length Encoding ("RLE")
            case 1:
                // here, the detail refers to number of times to copy the subsequent byte
                for (let i = detail; i > 0; i--){
                    output.push(input[index+1]);
                }
                index += 2;
                break;
            // HISTORY
            case 2:
                // Get the next 2 bytes, swap them, treat this as a word.
                // This word is the starting address within the existing OUTPUT data
                // from which to extract <detail> number of bytes
                let addr = input[index+1] | (input[index+2] << 8);
                output.push(...output.slice(addr, addr + detail));
                diff = output.length-addr;
                highestDiff = Math.max(highestDiff,diff);
                // console.log(`HISTORY: addr ${addr} to index ${output.length} (dec) = ${diff} / 0x${hex(diff,6)}`);
                index += 3;
                break;
            // Lookup Table ("LUT")
            case 3:
                // Take the detail and << 1. This value is our lookup table address.
                // take the 2 bytes of data starting at this address within the input.
                var lutAddress = detail << 1; // Multiplies by 2, ensures evenness
                output.push( input[lutAddress] );
                output.push( input[lutAddress+1] );
                index += 1;

                break;

        }
    }
    console.log(`Decompressed ${input.length} bytes to ${output.length} bytes.`);
    console.log(`Highest difference in offsets for History mode: ${highestDiff} / 0x${hex(highestDiff,6)}`);
    return new Uint8Array(output);
}


function unbitplane(input){
    // Takes SNES 4 bit-per-pixel (4bpp) data and rearranges into image data.
    // Usage:
    // opim=unbitplane(op4);
    //NOTE: for the opposite process, probably want to use .flatmap()
    // returns

    var output = [];
    // 32 bytes in a tile
    for (var tileIndex = 0; tileIndex<(input.length); tileIndex+=32){
        // console.log("Tile index "+tileIndex);
        let tile = [];
        for (var rowIndex = 0; rowIndex < 8; rowIndex++){
            // console.log("Row index "+rowIndex);
            let row = [
                input[tileIndex + (rowIndex*2) ],
                input[tileIndex + (rowIndex*2) + 1],
                input[tileIndex + (rowIndex*2) + 16],
                input[tileIndex + (rowIndex*2) + 17]
            ];
            let rowOut = [];
            // This uses a lot of bit masking and stuff.
            // Essentially, we go through each column, masking the nth bit of each bitplane,
            // or'ing them together into the appropriate significant bits, then shift back.
            for (columnIndex = 0; columnIndex < 8; columnIndex++){
                let columnValue = 0;
                for (bitplaneIndex = 0; bitplaneIndex < 4; bitplaneIndex++){ // previously was < 8, error?
                    columnValue |= ( row[bitplaneIndex] & (0b10000000 >> columnIndex) ) << bitplaneIndex;
                }
                rowOut.push( columnValue >> ( 7 - columnIndex) );
            }
            tile.push(rowOut);
            // ------------debug
            // console.log();
            var str = [];
            rowOut.forEach( (x, i) => {
                // console.log(x);
                str.push(hex(x));
            });
            // console.log(str.join(" "));
            // -------------------------
        }
        output.push(tile);
    }
    return output;
}




function snes2rgb(color){
  // converts the SNES two-byte RGB (5bits per color channel, plus extra bit)
  // into typical RGB.
  // SNES two-byte format is 0bbb bbgg gggr rrrr
  // so, for each color channel, we shift the number to the right by the appropriate
  // amount to get that channel aligned on the right (red is already aligned),
  // then AND it with 0b11111 to get only those 5 bits, then shift that back by 3 (*2 *2 *2 = *8).
  // then we add the floor division of this by 32.
  //NOTE: this multiplies by 8; actual SNES uses a slightly more advanced conversion...?

  // ( uses ~~(a/b), not Math.floor() floor division, for efficiency:
  // behaves differently for negative numbers; not of concern here)
  return [
    (color & 0b11111) << 3,
    ( (color >> 5) & 0b11111) << 3,
    ( (color >> 10) & 0b11111) << 3
  ].map(d => d + ~~(d/32));

}

function rgb2snes(rgb){
  // return ((rgb[0]>>3) & 0xFF) + (((rgb[1]>>3) & 0xFF) << 5) + (((rgb[2]>>3) & 0xFF) << 10)
  return rgb.reduce(
    (sum,val,i) => sum + (( (val>>3) & 0xFF) << (i*5)) ,0
  );
}
//(val,i) => (( (val>>3) & 0xFF) << (i*5))

function palette2rgb(inp, offset=0){
  let input = inp.slice(offset);

  var output = [];
  for (let i=0; i<input.length; i+=2){
    output.push( snes2rgb(
      // (input[i] << 8) + input[i+1] /* not swapped */
      (input[i+1] << 8) + input[i]  /* swapped */

    ) );
    // console.log(`Color ${snes2rgb( (input[i] << 8) + input[i+1] ) }` );
  }
  return output;
}


function display(dat, parent, palette, sc=1, title=null, classes=null){
    // use canvas to display image. Maybe try integrer scaling, and pixel-rendering CSS stuff for better look.
    // console.log(dat);
    // sc is pexel scale
    // const sc = 4; // integer scale for canvas

    var canvas = document.createElement("canvas");
    // canvas.id = "canvas";
    canvas = parent.appendChild(canvas);
    var w = dat[0].length;
    var h = dat[0][0].length;
    canvas.className = "tile_item";
    canvas.width = sc * w;
    canvas.height = dat.length*sc * h;
    if (title) canvas.title = title;
    if (classes) classes.forEach(d=>canvas.classList.add(d));
    var ctx = canvas.getContext("2d");
    // var pixels = new Uint8ClampedArray(8*8*4);
    for (var tileIndex = 0; tileIndex<(dat.length); tileIndex++){
      //TODO: can remove this outermost loop through tiles; this func is only ever called for 1, wrpped in an array???
        // let rowstr = "";
        for (let rowIndex = 0; rowIndex < dat[tileIndex].length; rowIndex++){

            for (let columnIndex = 0; columnIndex < dat[tileIndex][rowIndex].length; columnIndex++){

                let px = palette[ dat[tileIndex][rowIndex][columnIndex] ];
                // console.log(dat[tileIndex][rowIndex][columnIndex]);
                // console.log(px);
                // let fill = "#"+pal[ dat[tileIndex][rowIndex][columnIndex] ].map(d => hex(d)).join("")+"ff";
                let fill = `rgba(${px[0]}, ${px[1]}, ${px[2]}, 255)`;
                ctx.fillStyle = fill;
                ctx.fillRect(columnIndex*sc, (tileIndex*h*sc) + (rowIndex*sc), sc, sc);

                // rowstr+="R_"+rowIndex+";C_"+columnIndex+":_"+fill;
                // console.log([rowIndex*sc, tileIndex*8*sc + rowIndex*sc, sc, sc]);
            }
        }
        // console.log(rowstr);
    }

    // .putImageData(value, x, y);

    // let df = dat.flat();
    // let cvim = ctx.getImageData(0, 0, canvas.width, canvas.height);
    // console.log(cvim);
    // for (i=0; i<cvim.length/4;i++){
    //     let px = pal[df[i]];
    //     let ii = 4*i;
    //     cvim[ii] = px[0];
    //     cvim[ii+1] = px[1];
    //     cvim[ii+2] = px[2];
    //     cvim[ii+3] = 255;
    // }
    // console.log(cvim);
    // ctx.putImageData(cvim,0,0);
    return canvas;

}

//
function metatile(tiles, tilemap32){

  console.log(`Indexing metatiles...`);
  var tl = 8; // good placeholder for future...?

  var word = 0;
  var vflip = 0;
  var hflip = 0;
  var strow, stcof, rof, cof;
  var metatiles = [];  //TODO: modify so we initialize as one X x m x n array of zeros?
  var metatilesObj = [];
  var metatile;
  var overflows = [];
  let mtstr = [ ["","","",""],["","","",""],["","","",""],["","","",""]]; //HACK: not very clean
  let mtidx = 0;
  let metatileObj = [];
  let stobj = {paletteIndex: 0, colorIndices: zeros(8,8)};
  let stobjs = [];

  for ( let idx = 0; idx < tilemap32.length; idx+=2 ){

    mtidx = idx>>5; // same as floor dividing by 32
    // if starting the next metatile:
    if ( (((idx/2)) % 16 == 0) )  {
      // console.log(`Metatile ${idx/32}`);
      metatile = zeros(32, 32); // initially filled with zeros
      stobjs = [];
    }

    // Get the next 2 bytes, treat this as a word.
    // This word is the starting address within the existing OUTPUT data
    // from which to extract <detail> number of bytes
    // word = tilemap32[idx+1] | (tilemap32[idx] << 8); // not swapped
    word = tilemap32[idx] | (tilemap32[idx+1] << 8); // swapped
    // vh?t tttt tttt tttt // nope
    // vhPp pptt tttt tttt // yep
    vflip = (0x8000 & word) >> 15; // leftmost bit of the word (bit 0)
    hflip = (0x4000 & word) >> 14; // second leftmost bit (bit 1)
    prior = (0x2000 & word) >> 13; // bit 2
    palet = (0x1c00 & word) >> 10; // bit 3-5
    tilex = (0x03ff & word); // 10 rightmost bits (bits 6-15)


    // Get the row offset and column offset associated with
    // this submatrix/block within the metatile.
    // divide by 2 because each tile is represented by 2 bytes
    // floor divide by 4 (aka >> 2) and mod 4

    // get the 8x8 "subtile" indices
    strof = (( ((idx/2)%16)>>2 ));
    stcof = ((idx/2) %4);
    strof = Math.floor( ((idx/2)%16)/4 );
    mtstr[strof][stcof] = `${vflip},${hflip},${palet}`;

    // stcof = ((idx/2) %4)
    // now multiply that by the number of pixels in a subtile (usually 8)
    rof = tl*strof;
    cof = tl*stcof;

    // [["1","2"],["3","4"]].reduce((sum,d) => sum+="\n"+d.join(" "),"")
    // [["1","2"],["3","4"]].map((d) => d.join(" ")).join("\n")

    // console.log(`\nidx ${idx} (${strof},${stcof}): ${hex(word,4)} / ${binar(word,16)}\t  ${tileIndex}\t  /2=${tileIndex/2}`);
    // console.log(`(tile index ${(tiles[tileIndex])})`);

    // for ( let row = vflip ? 7 : 0; vflip ?( row > -1) : (row < 8); vflip ? row-- : row++){
    var tilestr = ``;
    var rowstr;

    stobjs.push( {
      paletteIndex: palet,
      colorIndices: zeros(8,8),
      tileIndex: tilex,
      vflip: vflip,
      hflip: hflip
    } );

    for ( let row = 0; row < tl;  row++){
      rowstr = ``;
      for ( let col = 0; col < tl;  col++){
        0;
        // rowstr += `${hex(tileIndex,4).slice(1)} `;
        // rowstr += ( `${rof + row},${cof + col}|${vflip?7-row:row},${hflip?7-col:col}  `);

        // index backwards from the end, if vflip and/or hflip:
        // console.log([hex(word,4), binar(word,16), binar(tileIndex,16), vflip?7-row:row, hflip?7-col:col]);
        if (tiles[tilex]){
          // console.log(`Tile inde xis ok. rof + row: ${rof + row}; cof + col ${cof + col}`);

          metatile[rof + row][cof + col] = tiles[tilex][vflip?7-row:row][hflip?7-col:col];
          stobjs[stobjs.length-1].colorIndices[row][col] = tiles[tilex][vflip?7-row:row][hflip?7-col:col];

        }

        else{
          0;
          overflows.push(tilex)
          // console.log(`Tile index too big!! rof + row: ${rof + row}; cof + col ${cof + col}`);
        };
      }
      tilestr+=`${rowstr}\n`;
    }

    // console.log(tilestr);
    // console.log(metatile);

    // push this if we're on the last of the 16 tiles.
    if ( (((idx/2)+1) % 16 == 0) )  {
      // metatiles.push( metatile ); old method, didn't include palette indices
      metatilesObj.push(stobjs);
      // console.log(mtstr);
      // console.log(`Metatile ${mtidx}:\n${mtstr.map((d) => d.join(" ")).join("\n")}`);
    }

  }

  // console.log(`Metatile: overflows from available tiles (${overflows.length} total).`);
  // console.log(overflows);

  // return metatiles;
  return metatilesObj;


}


function levelMap(metatiles, levelmetatiles){

  console.log(`Indexing level map...`);
  var tl = 8; // good placeholder for future...?

  var word = 0;
  var vflip = 0;
  var hflip = 0;

  let overflows = [];
  let levelobjs = [];


  for ( let idx = 0; idx < levelmetatiles.length; idx+=2 ){

    // Get the next 2 bytes, treat this as a word.
    // word = levelmetatiles[idx+1] | (levelmetatiles[idx] << 8); // not swapped
    word = levelmetatiles[idx] | (levelmetatiles[idx+1] << 8); // swapped
    // vh?t tttt tttt tttt // nope
    // vhPp pptt tttt tttt // yep
    vflip = (0x8000 & word) >> 15; // leftmost bit of the word (bit 0)
    hflip = (0x4000 & word) >> 14; // second leftmost bit (bit 1)
    prior = (0x2000 & word) >> 13; // bit 2 ...?
    tilex = (0x1fff & word); // 13 rightmost bits (bits 4-15)

    if (metatiles[tilex]){
      //TODO: would this cause an issue because we're sort of passing by reference...?
      levelobjs.push( { metatile: metatiles[tilex], vflip: vflip, hflip: hflip} );
    }
    else{
      overflows.push(tilex);
    }

  }

  // console.log(`Level Metatiles: overflows from available tiles (${overflows.length} total):`);
  // console.log(overflows);

  // return metatiles;
  return levelobjs;

}

// WIP...
function dkc1compress(input){
    var output = new Uint8Array();
    return output;
}



</script>

</body>

</html>

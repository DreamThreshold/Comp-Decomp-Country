<!DOCTYPE html>
    <html>
<!-- Created 2024-10-23 / Release 0.1 2024-11-21 -->
<head>
  <meta charset="UTF-8">
  <title>Comp/Decomp Country</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="icon" href="data:image/svg+xml;base64,PHN2ZwogICB3aWR0aD0iNjkuMzg5NTcybW0iCiAgIGhlaWdodD0iODcuNDI1MTg2bW0iCiAgIHZpZXdCb3g9IjAgMCA2OS4zODk1NzIgODcuNDI1MTg2IgogICB2ZXJzaW9uPSIxLjEiCiAgIGlkPSJzdmcxIgogICB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgogIDxkZWZzCiAgICAgaWQ9ImRlZnMxIiAvPgogIDxnCiAgICAgaWQ9ImxheWVyMSIKICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTIuMjU5NDUxLC0zLjcwMjU1MzUpIj4KICAgIDxwYXRoCiAgICAgICBpZD0icGF0aDEiCiAgICAgICBzdHlsZT0iZmlsbDojYjNiMzAwO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDowLjM2Njk7c3Ryb2tlLW9wYWNpdHk6MC42OSIKICAgICAgIGQ9Im0gNTkuNDA2NDQzLDMuNzAyNTUzNSAtMi4yNjczMDUsMC42NTI0MTQgLTIuNDI0OTE1LDEuOTIyMzY1IDMuOTI4Nyw3LjY1OTczNzUgYyAwLDAgLTAuMDI1NTcsMjQuMTMzMTExIC02LjY0NDI5NywzNC4wNDA1NjEgLTEwLjAyOTEsMTYuNjM0NDk3IC0zNS43MjU1MywyNi4yOTgwNjIgLTM3Ljk0OTg4LDM3LjUzMzg4MiBsIC0xLjc4OTI5NSwyLjYwMDYxOCAwLjkyMjQyMiwyLjM3NTgyNSAyLjc0NDAyLC0wLjIwNTQyNSBjIDAsMCAxMy4zNjQyMSw0LjcyNzU5NyAzMy4zOTMzMSwtOC4xNzkwODggQyA3MC44NzE1MjgsNjguMjE1MTk4IDgyLjg0OTc3MSw1NS42MTEyNzEgODEuNTUzNjcxLDM0LjI4MzM2NiA4MC40NjQyMjgsMTYuMzU1OTkgNjYuNDgyMjM4LDExLjgyMzQ5NSA2Ni40ODIyMzgsMTEuODIzNDk1IFoiIC8+CiAgPC9nPgo8L3N2Zz4K" />

<style></style>

<link href="main.css" rel="stylesheet" />

</head>

<!-- for various string, array/matrix, data interleaving, and formatting functions -->
<script src="utilities.js"></script>

<!-- for various string, array/matrix, data interleaving, and formatting functions -->
<script src="compression.js"></script>

<!-- Our "3D" SVG script, for bitplanes and more -->
<script src="svg3d.js"></script>

<body>

  <svg width="100vw" height="100vh" style="position:absolute;">
    <!-- oooh banana -->
    <pattern id="bananas" x="0" y="0" width="100" height="100" patternUnits="userSpaceOnUse">

      <path d="M 31.320569 9.8309245
      L 30.413647 10.09189
      L 29.443681 10.860836
      L 31.015161 13.924731
      C 31.015161 13.924731 31.004927 23.577975 28.357442 27.540955
      C 24.345802 34.194754 14.06723 38.06018 13.17749 42.554508
      L 12.461772 43.594755
      L 12.830741 44.545085
      L 13.928349 44.462919
      C 13.928349 44.462919 19.274033 46.353958 27.285673 41.191284
      C 35.906603 35.635986 40.6979 30.594415 40.17946 22.063253
      C 39.743683 14.892303 34.150887 13.079305 34.150887 13.079305
      L 31.320569 9.8309245
      z

      M 81.320618 59.830973
      L 80.413696 60.091939
      L 79.44373 60.860885
      L 81.01521 63.92478
      C 81.01521 63.92478 81.004976 73.578023 78.357491 77.541003
      C 74.345851 84.194802 64.067279 88.060229 63.177539 92.554557
      L 62.46182 93.594804
      L 62.83079 94.545133
      L 63.928398 94.462968
      C 63.928398 94.462968 69.274082 96.354007 77.285722 91.191333
      C 85.906652 85.636035 90.697948 80.594464 90.179508 72.063302
      C 89.743731 64.892352 84.150936 63.079354 84.150936 63.079354
      L 81.320618 59.830973
      z" stroke="none" fill="rgb(30, 30, 30)" ></path>
    </pattern>

    <rect x="0" y="0" width="100vw" height="100vh" fill="url(#bananas)"></rect>

  </svg>


  <div class="main" id="main">
    <!-- <div id="animationBottom" class="animationBottom"></div> -->
    <div id="navbar"><h4><i style="padding-left:5ch;">Comp / Decomp Country</i></h4></div>
    <div id="panelgrid"></div>

  </div>


  <div id="animationTop" class="animationTop"></div>

<!-- for animations (mainly decompression animations) -->
<script src="animation.js"></script>

<!-- for GUI panels and their methods -->
<script src="panels.js"></script>

<!-- this is the main, inline script. 
 Afer the first major refactoring,
 The remaining stuff in here is mainly file stuff, HTML/buttons/canvas interaction, and UI class, plus the creation of the page elements.
 -->
<script>



// class Animation {
//   constructor(name="anim"+Date.now()){

//   }

// }



function fileInput(e, ui, panel){

    // console.log("onchanged");
    // console.log(e);

    var file = e.target.files[0];

    // the hex viewer div
    //HACK: assumes there is only one hexViewercontent per panel...
    let hexContent = panel.panelContent.querySelector(" .hex_content");
    // console.log(panel.name+" hexContent");
    // console.log(hexContent);

    var fReader = new FileReader();
    fReader.readAsArrayBuffer(file);

    // console.log("this/e/ui");
    // console.log(this);
    // console.log(e);
    // console.log(ui);

    fReader.addEventListener('load', function (e) {

        panel.source = {
            name: "Raw data from "+file.name,
            filename: file.name,
            kind: "bytes",
            data: new Uint8Array( e.target.result),
            // panel: panel,
            // file: file
        };


        
        // save to local browser session storage
        sessionStorage.setItem( panel.nameValid+'_source', JSON.stringify(panel.source) );

        panel.source.panel = panel; // do this after to avoid cyclic objects
        // panel.generateHexHTML( panel.source.data );  // comment out for speed


        // Automatically do the next steps...
        // console.log(panel);
        // panel.nexts[0].propagateSource();
        panel.propagateSource();

    });

}

function changeByteWidth(panel, overrideMode=null){
  // var panel = e.target.parentNode.parentNode;

  var oldMode = panel.getAttribute("data-mode");
  var newMode = "";
  if (overrideMode){
    newMode = overrideMode;
  }
  else{
    newMode = oldMode=="byte16"?"byte1":"byte16"; // simplified: toggle
  }


  // console.log(panel);

  // panel.style.gridTemplateColumns = newMode=="byte1"?"2fr 4fr 14fr":"2fr 16fr 0fr";

  var hexOffsetHeaderLabels = panel.querySelector(".hex_header > .hex_offset_labels");
  var hexBaseLabels = panel.querySelector(".hex_header > .hex_base_labels");
  // hof.style.gridTemplateColumns = newMode=="byte1"?"2fr repeat(16, 0.25fr)":"2fr repeat(16, 1fr)";
  var hexContent = panel.querySelectorAll(".hex_content")[0];
  var g32l = hexContent.querySelectorAll(".g32l");
  // hc.style.gridTemplateColumns = newMode=="byte1"?"4fr 14fr":"18fr 0fr";

// hc.style.gridTemplateRows = newMode=="byte1"?`repeat(${g32.length},100%)`:`repeat(${g32.length},1fr)`;


  switch (newMode){
    case "byte16":
      panel.style.gridTemplateColumns = "2fr 16fr 0fr";
      // hexContent.style.gridTemplateRows = `repeat(${g32l.length},5ch)`;
      hexOffsetHeaderLabels.style.opacity = 1;
      hexBaseLabels.style.opacity = 0;
      break;
    case "byte1":
      panel.style.gridTemplateColumns = "2fr 4fr 25fr";
      // hexContent.style.gridTemplateRows = `repeat(${g32l.length},100%)`;
      hexOffsetHeaderLabels.style.opacity = 0;
      hexBaseLabels.style.opacity = 1;
      break;
    }

  // console.log(g32);
  // hc.height = "100%";

  // for grid elements, get the custom grid-template-rows and columns
  var g32rrs = hexContent.querySelectorAll(".g32rr");
  for (var g32rr of g32rrs){
    for (var gr32r of g32rr.querySelectorAll(".g32r")){

      let gcr = gr32r.getAttribute(`data-mode-${newMode}`).split(";");

      gr32r.style.gridTemplateColumns = gcr[0];
      gr32r.style.gridTemplateRows = gcr[1];
      let gr32rByte = gr32r.querySelector(".byte");
      let bp = gr32rByte.getAttribute('data-bitplane');
      let binSpan = gr32rByte.querySelector(".byteBin");
      let prefix = gr32rByte.querySelector(".byteOffsetPrefix");
      // console.log(gr32rByte);
      // console.log(bp);
      // gr.querySelectorAll(".byte")[0].style.justifyContent = newMode=="byte1"?"flex-end":"center";
      if (newMode == "byte16"){
        gr32rByte.classList.remove(`byte_bp${bp}`);
        binSpan.classList.remove(`byteBinOneByteWide`);
        // binSpan.style.width = "0%";
        // binSpan.style.opacity = 0;
        prefix.style.opacity = 0;
        // gr32rByte.style.gridTemplateColumns = "0fr 1fr"; //NOTE: backwards because rtl
      }
      else if (newMode == "byte1"){
        gr32rByte.classList.add(`byte_bp${bp}`);
        binSpan.classList.add(`byteBinOneByteWide`);
        // binSpan.style.width = "100%";
        // binSpan.style.opacity = 1;
        prefix.style.opacity = 1;
        // gr32rByte.style.gridTemplateColumns = "4fr 2fr";
      }
    }
    // console.log(g32);
  }


  panel.setAttribute("data-mode", newMode);

}

function updateBitplaneSeek(panelNode, panel, change, override=false ){


  // first update the total number
  let currentTile = panelNode.querySelector(".panel_content > .hex_header > .seekButtons > #currentTile");
  let totalTiles = panelNode.querySelector(".panel_content > .hex_header > .seekButtons > #totalTiles");

  // console.log("seek btn:");
  // [panelNode, panel, change, override, currentTile, totalTiles].forEach( d=> console.log(d));

  if (panel.source){

    let totalNumber = Math.ceil(panel.source.data.length/32);
    totalTiles.innerHTML = totalNumber;
    //
    let oldVal = (1*currentTile.innerHTML);
    let newVal =  (typeof(override)=='number' ) ? override : (oldVal+change);

    // min max/ clamp the range:
    if (newVal>totalNumber) newVal = totalNumber;
    if (newVal<1) newVal = 1;

    // if we have a valid change:
    if ( (newVal != oldVal) || (override!=false) ){
      currentTile.innerHTML = newVal;
      console.log(`Valid seek change: updating bitplane seek to ${newVal}`)

      panel.generateBitplaneHTML(panel.source.data, (newVal-1)*32 );

    } else{
      console.log("invalid seek change");
    }
  }
}

class UImodel {
  constructor(grid, panelsParams, name=null, cell=null) {
    this.grid = grid;
    this.panels = [];
    for (let i = 0; i<panelsParams.length; i++){
        //HACK: surely a better way to do this but whatever
        this.panels.push( new Panel(this,
            panelsParams[i][0], panelsParams[i][1], panelsParams[i][2],
            panelsParams[i][3], panelsParams[i][4], panelsParams[i][5],
            panelsParams[i][6] )
        );
    }

    this.name = name;
    this.sources = []; // will contain source data from files
    if (cell == null){
        let cell = document.createElement("div");
        cell.style.gridRow = 1;
        cell.style.gridColumn = 1;
        cell.style.background = "none";
        cell.style.zIndex = -10;
        this.grid.append(cell);
        this.cell = cell;
        console.log("assigning cell to ui");
    }
    else{
        this.cell = cell; // a reference cell within the grid
    }
    console.log("Appending to main grid...");
    // this.panels.forEach(p => this.grid.append(p.outer));
    // now that they're in the document, add event listeners

    // this.panels.forEach(
    //     p => p.eventListeners.forEach(
    //         // (el) => el[0].addEventListener(el[1], el[2] )
    //         (el) => el.tagName=="INPUT" ? el.onchange = fileInput : 0
    //     )
    // );
    //HACK: this is a weird way to assign the event listener, but it wasn't working otherwise...
    for (let panel of this.panels){

        // console.log(panel);
        //TODO: find a better way to find ALL inputs within a panel, instead
        // of searching through everything in the panelHeader ...?
        // for (let el of panel.panelHeader.children){

        //     if (el.tagName=="INPUT"){
        //         // where "this" will be the UImodel object.
        //         el.onchange = (e) => fileInput(e, this, panel);
        //         ;
        //         console.log("found input");
        //         console.log(el);
        //         console.log(el.onchange);
        //         console.log( [ this, panel ] );

        //     }
        // }

        // if (panel.byteWidthButton){
        //   // panel.inner.querySelectorAll(".panel_header > .byteWidthButton")[0].addEventListener("click",
        //   //     (event) => {changeByteWidth(event.target.parentNode.parentNode)});
        //   console.log("ADDED EVENT LISTENER");
        //   panel.inner.querySelector(".panel_content > .bitplane_header > .byteWidthButton").addEventListener("click",
        //       (event) => {
        //         console.log(event);
        //         // changeByteWidth(event.target.parentNode.parentNode);
        //         panel.animate16to1();
        //       });
        // }
        // if (panel.seekTileUpButton){
        //   // panel.inner.querySelector(".panel_header > div > .seekTileUpButton").addEventListener("click",
        //   //   (event) => {
        //   //     updateBitplaneSeek(event.target.parentNode.parentNode.parentNode, panel, +1)
        //   //   }
        //   // );
        //   console.log("ADDED EVENT LISTENER");
        //   panel.inner.querySelector(".panel_content > .bitplane_header > .seekButtons > .seekTileUpButton").addEventListener("click",
        //     (event) => {
        //       console.log(event);
        //       updateBitplaneSeek(event.target.parentNode.parentNode.parentNode, panel, +1)
        //     }
        //   );
        // }
        // if (panel.seekTileDownButton){
        //   // panel.inner.querySelector(".panel_header > div > .seekTileDownButton").addEventListener("click",
        //   //   (event) => {
        //   //     updateBitplaneSeek(event.target.parentNode.parentNode.parentNode, panel, -1)
        //   //   }
        //   // );
        //   console.log("ADDED EVENT LISTENER");
        //   panel.inner.querySelector(".panel_content > .bitplane_header > .seekButtons > .seekTileDownButton").addEventListener("click",
        //     (event) => {
        //       console.log(event);
        //       updateBitplaneSeek(event.target.parentNode.parentNode.parentNode, panel, -1)
        //     }
        //   );
        // }


        if (panel.fileInputs[0]){
          panel.inner.querySelectorAll(".panel_content > .fileInput")[0].onchange = (e) => fileInput(e, this, panel);
        }

        // also see if we need to link any panels:
        for (let link of panel.links){
            console.log(`Pushing link: [${link.name}] --> [${panel.name}]`);
            link.nexts.push(panel);
        }
    }
    //HACK
    // document.getElementById("ii").onchange = (e) => fileInput(e, this, this.panels[0]);
    // document.getElementById("btn").addEventListener("click",
    //   (event) => {changeByteWidth(event.target.parentNode.parentNode)});



    // changeByteWidth(this.panels[0].inner,"byte16");

    // window.addEventListener('resize', (e) => this.reflow(e), true);
    this.bpsvgs = [];
    let i = 0;

    // for (var g32s of document.getElementsByClassName("g32s")){
    //   this.bpsvgs.push(makeBitplaneSVG(g32s,"bpsvg_"+i));
    //   console.log(i);
    //   i++;
    // }

    // this.reflow(); // initial reflow

  }
  reflow(){

    // tries to automatically fit panels. Not used after adding more complicates setup.
    // console.log(this);

    let cellWidth = this.cell.getBoundingClientRect().width;
    let dl = 0; // running tracker of previous panels' width changes
    let dt = 0; // not fully implemented; top deltas

    for (let i=0; i<this.panels.length; i++){
        let panel = this.panels[i];
        // // Get the first child element to be of panel_inner class:
        // var inner;
        // for (let item of panel.element.children ){
        //     if (item.classList.contains("panel_inner")){
        //         inner = item;
        //         break;
        //     }
        // }
        let inner = panel.inner;
        let outer = panel.outer;
        let dw = 0, dh = 0;
        // console.log([inner.getBoundingClientRect().width , outer.getBoundingClientRect().width]);
        if (inner.getBoundingClientRect().width > outer.getBoundingClientRect().width){
            dw = 1;
            // console.log("largen");
        }
        else if (inner.getBoundingClientRect().width  + (1*cellWidth) < outer.getBoundingClientRect().width  ){
            dw = -1;
            // console.log("smallen");
        }
        panel.updateBox(dt, dt+dh, dl, dl+dw);
        // dl += i>0 ? dw : 0;
        dl += dw;
        dt += dh;

    }
  }
}

//
//   Create the ui and panels
//

// let c0 = 2, c1 = 11, c2 = 20, c3=29;
let c0 = 1, c1 = 6, c2 = 16, c3=27;
let cx = c2*1;
let dx = cx+5;
let d0 = c1, d1 = c2, d2=c3, d3=33;
//              _, kind,                  rows        cols     name=null, link
var inputPanel = ["fileIn",                1,  3,    c0, d0,  "Input - Compressed Data"];
var compHexPanel = ["hexViewerComp",       1, 15,    c1, d1,  "Hex Viewer - Compressed Data", [0]]; // 1
var paletteInputPanel = ["fileIn",         1,  3,    c3, d3,  "Input - Palette"];  //  2
var paletteViewer = ["paletteViewer",      3,  6,    c3, d3,  "Palette", [2]]; // 3
var decompHexPanel = ["hexViewer",        15, 28,    c1, d1,  "Hex Viewer - Decompressed Data", [0, 3, 1]]; // 4
var bitplanePanel = ["bitplaneViewer",     1, 18,    c2, d2,  "Bitplane Viewer - Decompressed Data", [4, 3]]; // 5
var tilesetViewer = ["tilesetViewer",     18, 29,    c2, d2,  "Tiles", [4, 3, 5]]; //  6   4, 3, 5
var metatilemapInputPanel = ["fileIn",     6,  8,    c3, d3,  "Input - Tilemap32 (Metatiles)"]; //  7
var metatilesViewer = ["metatilesViewer",  8, 15,    c3, d3,  "Tilemap32 (Metatiles)", [3,6,7]]; // 8 pal viewer, tileset vwr, metatile input
var levelMapInputPanel = ["fileIn",       15, 17,    c3, d3,  "Input - Level Map"]; //  9
var levelMapViewer = ["levelMapViewer",   17, 29,    c3, d3,  "Level Map", [3,8,9]]; // 10 paletteViewer, metatilesViewer, fileIn
var description = ["textDescription",      3, 29,    c0, d0,  "About"]; // 11

const ui = new UImodel(
        document.getElementById("panelgrid"),
        [ inputPanel, compHexPanel,
        paletteInputPanel, paletteViewer,
        decompHexPanel, bitplanePanel,
        tilesetViewer,
        metatilemapInputPanel, metatilesViewer,
        levelMapInputPanel, levelMapViewer,
        description ],
        "main"
    );

// ui.panels[0].toOneByteWide(); //HACK
// window.addEventListener('resize', ui.reflow, true);

let pg = document.getElementById("panelgrid");

//debug:
// ui.panels[1].generateHexHTML();

//checkerboard (sort of debug)
// for (let i=1; i<=28; i++){
//     for (let j=1; j<=32;j++){
//         let chkr = document.createElement("div");
//         chkr.className = "checker";
//         chkr.id = "checker_"+i+"_"+j;
//         chkr.style.gridRow = ""+i+"";
//         chkr.style.gridColumn = ""+j+"";
//         if ( (i%2) == (j%2) ){
//             chkr.style.backgroundColor = "black";
//         }
//         pg.append(chkr);


//     }
// }
//

function displayRaw(dat, parent, sc=1){
  
  // console.log(dat);
  var canvas = document.createElement("canvas");
  // canvas.id = "canvas";
  canvas = parent.appendChild(canvas);
  canvas.style.width = '100%';
  canvas.style.height = '100%';
  
  var w = dat.length;
  var h = dat[0].length;

  canvas.width = sc * w;
  canvas.height = sc * h;

  var ctx = canvas.getContext("2d");

  for (let rowIndex = 0; rowIndex < dat.length; rowIndex++){
  
    for (let columnIndex = 0; columnIndex < dat[rowIndex].length; columnIndex++){

      // let fill = "#"+pal[ dat[tileIndex][rowIndex][columnIndex] ].map(d => hex(d)).join("")+"ff";

      ctx.fillStyle = `rgb(${dat[rowIndex][columnIndex].join()})`;
      ctx.fillRect(columnIndex*sc, rowIndex*sc, sc, sc);

      // rowstr+="R_"+rowIndex+";C_"+columnIndex+":_"+fill;
      // console.log([rowIndex*sc, tileIndex*8*sc + rowIndex*sc, sc, sc]);
    }
  }

  return canvas;
}

function display(dat, parent, palette, sc=1, title=null, classes=null){
    // use canvas to display image. Maybe try integrer scaling, and pixel-rendering CSS stuff for better look.
    // console.log(dat);
    // sc is pexel scale
    // const sc = 4; // integer scale for canvas

    var canvas = document.createElement("canvas");
    // canvas.id = "canvas";
    canvas = parent.appendChild(canvas);
    var w = dat[0].length;
    var h = dat[0][0].length;
    canvas.className = "tile_item";
    canvas.width = sc * w;
    canvas.height = dat.length*sc * h;
    if (title) canvas.title = title;
    if (classes) classes.forEach(d=>canvas.classList.add(d));
    var ctx = canvas.getContext("2d");
    // var pixels = new Uint8ClampedArray(8*8*4);
    for (var tileIndex = 0; tileIndex<(dat.length); tileIndex++){
      //TODO: can remove this outermost loop through tiles; this func is only ever called for 1, wrpped in an array???
        // let rowstr = "";
        for (let rowIndex = 0; rowIndex < dat[tileIndex].length; rowIndex++){

            for (let columnIndex = 0; columnIndex < dat[tileIndex][rowIndex].length; columnIndex++){

                let px = palette[ dat[tileIndex][rowIndex][columnIndex] ];
                // console.log(dat[tileIndex][rowIndex][columnIndex]);
                // console.log(px);
                // let fill = "#"+pal[ dat[tileIndex][rowIndex][columnIndex] ].map(d => hex(d)).join("")+"ff";
                let fill = `rgba(${px[0]}, ${px[1]}, ${px[2]}, 255)`;
                ctx.fillStyle = fill;
                ctx.fillRect(columnIndex*sc, (tileIndex*h*sc) + (rowIndex*sc), sc, sc);

                // rowstr+="R_"+rowIndex+";C_"+columnIndex+":_"+fill;
                // console.log([rowIndex*sc, tileIndex*8*sc + rowIndex*sc, sc, sc]);
            }
        }
        // console.log(rowstr);
    }

    // .putImageData(value, x, y);

    // let df = dat.flat();
    // let cvim = ctx.getImageData(0, 0, canvas.width, canvas.height);
    // console.log(cvim);
    // for (i=0; i<cvim.length/4;i++){
    //     let px = pal[df[i]];
    //     let ii = 4*i;
    //     cvim[ii] = px[0];
    //     cvim[ii+1] = px[1];
    //     cvim[ii+2] = px[2];
    //     cvim[ii+3] = 255;
    // }
    // console.log(cvim);
    // ctx.putImageData(cvim,0,0);
    return canvas;

}

</script>

</body>

</html>